import { gql } from "@apollo/client";
import * as Apollo from "@apollo/client";
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
    };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string };
  String: { input: string; output: string };
  Boolean: { input: boolean; output: boolean };
  Int: { input: number; output: number };
  Float: { input: number; output: number };
  BigInt: { input: any; output: any };
  File: { input: any; output: any };
  JSON: { input: any; output: any };
  Number: { input: any; output: any };
  Requirements: { input: any; output: any };
  SanitizedString: { input: any; output: any };
  StringFloat: { input: any; output: any };
  Timestamp: { input: any; output: any };
  UrlString: { input: any; output: any };
};

/** An abuse report category */
export type AbuseReportCategory = {
  __typename?: "AbuseReportCategory";
  /** The additional filter on the abuse report category */
  additionalFilter?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the category */
  id: Scalars["ID"]["output"];
  /** The resource type that is being reported */
  resourceType: AbuseReportCategoryResourceTypes;
  /** The sub categories for this category */
  subCategories?: Maybe<AbuseReportSubCategoryConnection>;
  /** The title of the category */
  title: Scalars["String"]["output"];
  /** The visibility of the category */
  visibility: AbuseReportCategoryVisibility;
};

/** An abuse report category */
export type AbuseReportCategorySubCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  visibility?: InputMaybe<AbuseReportCategoryVisibility>;
};

/** The connection type for AbuseReportCategory. */
export type AbuseReportCategoryConnection = {
  __typename?: "AbuseReportCategoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AbuseReportCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AbuseReportCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AbuseReportCategoryEdge = {
  __typename?: "AbuseReportCategoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AbuseReportCategory>;
};

/** The name of the resource type that is being reported. */
export enum AbuseReportCategoryResourceTypes {
  /** Page */
  Page = "Page",
}

/** Visibility of an abuse report category */
export enum AbuseReportCategoryVisibility {
  /** Hidden */
  Hidden = "hidden",
  /** Live */
  Live = "live",
}

export type AbuseReportInterface = {
  /** The category of the abuse report */
  abuseReportCategory: AbuseReportCategory;
  /** The sub category of the abuse report */
  abuseReportSubCategory: AbuseReportSubCategory;
  /** The attachments for the abuse report */
  attachments: Array<AttachmentInterface>;
  /** When the abuse report was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the abuse report */
  description: Scalars["String"]["output"];
  /** The ID of the abuse report */
  id: Scalars["ID"]["output"];
  /** The images for the abuse report */
  images: Array<Image>;
  /** The status of the abuse report */
  status: AbuseReportStatus;
  /** The user who made this report */
  user: User;
};

/** The status of the abuse report */
export enum AbuseReportStatus {
  /** Accepted */
  Accepted = "accepted",
  /** Canceled */
  Canceled = "canceled",
  /** Pending */
  Pending = "pending",
  /** Rejected */
  Rejected = "rejected",
}

/** An abuse report sub category */
export type AbuseReportSubCategory = {
  __typename?: "AbuseReportSubCategory";
  /** The ID of the category */
  id: Scalars["ID"]["output"];
  /** The title of the category */
  title: Scalars["String"]["output"];
  /** The visibility of the category */
  visibility: AbuseReportCategoryVisibility;
};

/** The connection type for AbuseReportSubCategory. */
export type AbuseReportSubCategoryConnection = {
  __typename?: "AbuseReportSubCategoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AbuseReportSubCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AbuseReportSubCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AbuseReportSubCategoryEdge = {
  __typename?: "AbuseReportSubCategoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AbuseReportSubCategory>;
};

/** The high level payment processor options. */
export enum AcceptedPaymentMethods {
  Coinbase = "coinbase",
  Free = "free",
  Paypal = "paypal",
  Sezzle = "sezzle",
  Splitit = "splitit",
  Stripe = "stripe",
}

/** The access level a given user (or company) has to an access pass. */
export enum AccessLevel {
  Admin = "admin",
  Customer = "customer",
  NoAccess = "no_access",
}

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPass = {
  __typename?: "AccessPass";
  /** The order of this access pass in relation to other access passes of the same company */
  accessPassOrder: Scalars["Int"]["output"];
  /** The access pass restriction set for this access pass */
  accessPassRestrictionSet: AccessPassRestrictionSet;
  /** The access pass stat for this access pass */
  accessPassStat?: Maybe<AccessPassStat>;
  /** The type of access pass */
  accessPassType: AccessPassTypes;
  /** The number of active members (users) for this access pass. */
  activeMembersCount: Scalars["Int"]["output"];
  /** A count of the active memberships on this access pass. */
  activeMembershipsCount: Scalars["Int"]["output"];
  /** The number of plans that are currently visible for this access pass. */
  activePlansCount: Scalars["Int"]["output"];
  /** The number of active users for this access pass. */
  activeUsersCount: Scalars["Int"]["output"];
  /** The total revenue an access pass has ever brought in. */
  allTimeRevenue: Scalars["String"]["output"];
  /** Marks whether the customer has already purchased this pass. */
  alreadyOwned: Scalars["Boolean"]["output"];
  /** The app that this AccessPass grants access to. */
  app?: Maybe<App>;
  /**
   * App sessions for this access pass.
   * @deprecated Use app_sessions_count instead
   */
  appSessions: AccessPassAppSessions;
  /**
   * The number of app sessions for this access pass.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  appSessionsCount: Scalars["Int"]["output"];
  /** The criteria for the company to be on the marketplace. */
  applicationCriteria: Array<MarketplaceApplicationCriteria>;
  /** The current step of the application criteria. */
  applicationCriteriaCurrentStep?: Maybe<ApplicationCriteriaIdentifier>;
  /** The unique apps of all experiences in this access pass. */
  apps: PublicAppConnection;
  /** The attachments for the access pass. */
  attachments: AttachmentInterfaceConnection;
  /** The automated messages triggers for this access pass */
  automatedMessagesTriggers: Array<AutomatedMessagesTrigger>;
  /** The banner image for the access pass. */
  bannerImage?: Maybe<AttachmentInterface>;
  /** The bounties for this access pass. */
  bounties: BountyConnection;
  /**
   * The number of times the card has been clicked.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  cardClickCount: Scalars["Int"]["output"];
  /**
   * The number of times the card has been viewed.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  cardImpressionCount: Scalars["Int"]["output"];
  /** The number of upcoming cancelations for this access pass. */
  churnedMemberships: Scalars["Int"]["output"];
  /** A short type of the company that this access pass belongs to. */
  company: PublicCompany;
  /** The competitions for this access pass. */
  competitions: Array<Competition>;
  /** When the public access pass was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was created */
  createdAtMs: Scalars["BigInt"]["output"];
  /** The creator pitch for the access pass. */
  creatorPitch?: Maybe<Scalars["String"]["output"]>;
  /** The custom call to action for the access pass. */
  customCta: CustomCtas;
  /** The custom call to action URL for the access pass, if any. */
  customCtaUrl?: Maybe<Scalars["String"]["output"]>;
  /** The reason why the access pass was denied from the marketplace, if any. */
  declineReason?: Maybe<Scalars["String"]["output"]>;
  /** The default plan for this access pass */
  defaultPlan?: Maybe<Plan>;
  /** Whether the access pass can be deleted. */
  deletable: Scalars["Boolean"]["output"];
  /**
   * A written description of the access pass.
   * @deprecated No longer used
   */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The direct link to purchase the access pass. */
  directLink: Scalars["String"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was soft deleted. If it's null, the access pass is still active. */
  discardedAtMs?: Maybe<Scalars["BigInt"]["output"]>;
  /** The date and time when the access pass went on Discovery. */
  discoverableAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Discovery Tags applied to this AccessPass. */
  discoveryTags: DiscoveryTagConnection;
  /** Whether or not the company publicly displays discover stats */
  displayDiscoverStats: Scalars["Boolean"]["output"];
  /** An array of experience IDs that this pass has */
  experiences: Array<Experience>;
  /** Custom frequently asked questions to display. */
  faq: Array<FaqObject>;
  /** The featured access passes for this access pass. */
  featuredAccessPasses: Array<PublicAccessPass>;
  /** The featured reviews of the access pass. */
  featuredReviews: Array<Review>;
  /** The featured users of the access pass. */
  featuredUsers: Array<PublicProfileUser>;
  /**
   * The file attachments for the access pass.
   * @deprecated use attachments instead
   */
  fileAttachments: FileAttachmentConnection;
  /** The date and time when the access pass was first approved for the marketplace. */
  firstApprovedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** All of the forum experiences connected to the access pass. */
  forumExperiences: PublicExperienceConnection;
  /** The percentage of a transaction a user is eligible to earn from the whop marketplace global affiliate program. */
  globalAffiliatePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The status of the global affiliate program for this access pass. */
  globalAffiliateStatus: GlobalAffiliateStatuses;
  /** Whether the access pass has a free available plan. */
  hasFreeAvailablePlan: Scalars["Boolean"]["output"];
  /** Whether the current user has liked the access pass. */
  hasLiked: Scalars["Boolean"]["output"];
  /** Whether the access pass has a paid available plan. */
  hasPaidAvailablePlan: Scalars["Boolean"]["output"];
  /** Whether or not the access pass has plans with waitlist release method. */
  hasWaitlistPlans: Scalars["Boolean"]["output"];
  /** The headline of the access pass. */
  headline?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the public access pass. */
  id: Scalars["ID"]["output"];
  /**
   * The image for the public access pass.
   * @deprecated Use imageSrcset instead.
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The image for the public access pass. Deprecated, use logo instead. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The marketplace/branding images for the company. */
  images: Array<Image>;
  /** Whether the current user is an affiliate access pass. */
  isAccessPassAffiliate: Scalars["Boolean"]["output"];
  /** Whether the access pass has a free plan that doesn't have any requirements. */
  isFreeAndJoinableWithoutRequirements: Scalars["Boolean"]["output"];
  /** Whether or not the access pass is in the leaderboard */
  isInLeaderboard: Scalars["Boolean"]["output"];
  /** Returns true if they are not in the current leaderboard and also have no fake rank (ex. Not on discover but would be ranked if they were) */
  isUnrankedInLeaderboard: Scalars["Boolean"]["output"];
  /** The access_passes's item ordering. */
  itemOrdering: ItemOrdering;
  /** The total number of published reviews for this access pass. */
  last7DaysPublishedReviews: Scalars["Int"]["output"];
  /** The affiliate earnings in the last 24 hours. */
  last24HoursAffiliateEarnings: Scalars["Float"]["output"];
  /** The average time spent in the last 24 hours, in seconds. */
  last24HoursAverageTimeSpent: Scalars["Int"]["output"];
  /** The GMV in the last 24 hours. */
  last24HoursGmv: Scalars["Float"]["output"];
  /** The number of new users in the last 24 hours. */
  last24HoursNewUsers: Scalars["Int"]["output"];
  /** The number of reviews in L24 hours */
  last24HoursPublishedReviews: Scalars["Int"]["output"];
  /** The total seconds spent on this access pass' experiences on the last day. This is tracked using our time tracking mechanism. It combines iOS, Web, and Android, and only tracks when users with access are looking at experiences. It excludes Discord & Telegram */
  last24HoursTotalSeconds: Scalars["Int"]["output"];
  /** The total number of users last 24 hours that make up the last_24_hours_total_seconds field */
  last24HoursTotalUsers: Scalars["Int"]["output"];
  /** The number of new users in the last 30 days. */
  last30DaysNewUsers: Scalars["Int"]["output"];
  /** A leaderboard result for this access pass */
  leaderboard?: Maybe<Leaderboard>;
  /** The preceding characters before a randomly generated license key. */
  licenseKeyPrefix?: Maybe<Scalars["String"]["output"]>;
  /** The total number of likes for the access pass. */
  likeCount: Scalars["Int"]["output"];
  /** The logo for the access pass. */
  logo?: Maybe<AttachmentInterface>;
  /** The marketplace applications for this access pass. */
  marketplaceApplications: MarketplaceApplicationConnection;
  /** The marketplace categories for the page. */
  marketplaceCategories: MarketplaceCategoryConnection;
  /** Fetch a marketplace category in respect to the level. */
  marketplaceCategory?: Maybe<MarketplaceCategory>;
  /** The status of the access pass in the marketplace. */
  marketplaceStatus: MarketplaceStatuses;
  /** Metadata to store on the access pass. */
  metadata: Scalars["JSON"]["output"];
  /** The most recent review for the access pass. */
  mostRecentReview?: Maybe<Review>;
  /** The rank of the access_pass on the leaderboard */
  myLeaderboardRank: Leaderboard;
  /**
   * The name of the access pass. It must be max 50 characters.
   * @deprecated Use title instead
   */
  name: Scalars["String"]["output"];
  /** The access pass's onboarding version. */
  onboardingVersion?: Maybe<AccessPassOnboardingVersionTypes>;
  /**
   * A user can/cannot own multiple of this pass.
   * @deprecated No longer used
   */
  onePerUser: Scalars["Boolean"]["output"];
  /** The user that owns the access pass (company owner). */
  ownerUser: PublicProfileUser;
  /** The experience that is pinned in this access pass */
  pinnedExperience?: Maybe<PublicExperience>;
  /** The experiences that current user sees as pinned in this access pass */
  pinnedExperiences: PublicExperienceConnection;
  /** All of the plans connected to the company. */
  plans: PlanConnection;
  /** The popup promo code for the access pass, if any. */
  popupPromoCode?: Maybe<PublicPromoCode>;
  /** Product highlights displayed on the product detail screen. */
  productHighlights: ProductHighlightConnection;
  /** The public affiliate earnings chart for this access pass */
  publicAffiliateEarningsChart?: Maybe<ChartsDataNumber>;
  /** The public average time spent chart for this access pass */
  publicAverageTimeSpentChart?: Maybe<ChartsDataNumber>;
  /** The public experiences for this access pass. */
  publicExperiences: PublicExperienceConnection;
  /** The public GMV chart for this access pass */
  publicGmvChart?: Maybe<ChartsDataNumber>;
  /** The public new users chart for this access pass */
  publicNewUsersChart?: Maybe<ChartsDataNumber>;
  /** The public reviews chart for this access pass */
  publicReviewsChart?: Maybe<ChartsDataNumber>;
  /** The number of reviews that have been published for the access pass. */
  publishedReviewsCount: Scalars["Int"]["output"];
  /** The URL to redirect the customer to after a purchase, if applicable. */
  redirectPurchaseUrl?: Maybe<Scalars["String"]["output"]>;
  /** Whether all marketplace application criteria have been met */
  requiredCriteriaMet: Scalars["Boolean"]["output"];
  /** Ratings real customers have written for the company. */
  reviews: ReviewConnection;
  /** The average of all reviews for this access pass. */
  reviewsAverage: Scalars["Float"]["output"];
  /** The percentage of reviews that makes up each star rating from 5 to 1. */
  reviewsBreakdown?: Maybe<Array<Scalars["Int"]["output"]>>;
  /** The route of the access pass. */
  route: Scalars["String"]["output"];
  /** The total number of shares for the access pass. */
  shareCount: Scalars["Int"]["output"];
  /** A short description of what the company offers or does. */
  shortenedDescription?: Maybe<Scalars["String"]["output"]>;
  /** Whether to show the custom CTA on discover. */
  showCustomCtaOnDiscover: Scalars["Boolean"]["output"];
  /** Whether to show the member count. */
  showMemberCount: Scalars["Boolean"]["output"];
  /** Whether to show the offers on the access pass. */
  showOffers: Scalars["Boolean"]["output"];
  /** Whether to show the owner user. */
  showOwnerUser: Scalars["Boolean"]["output"];
  /** Whether to show reviews on the access pass. */
  showReviewsDtc: Scalars["Boolean"]["output"];
  /** A license key can/can't be scrambled. */
  shuffleable: Scalars["Boolean"]["output"];
  /** The social links for the access pass. */
  socialLinks: Array<SocialLink>;
  /**
   * The number of times the store page has been clicked.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  storePageClicksCount: Scalars["Int"]["output"];
  /**
   * The number of times the store page has been viewed.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  storePageViewsCount: Scalars["Int"]["output"];
  /** The title of the access pass. Use for Whop 4.0. */
  title: Scalars["String"]["output"];
  /** The total bounty amount for this access pass. */
  totalBountyAmount: Scalars["Float"]["output"];
  /** The number of upcoming cancelations for this access pass. */
  totalMemberships: Scalars["Int"]["output"];
  /** This access pass can/cannot be transferred to another user. */
  transferable: Scalars["Boolean"]["output"];
  /** The number of upcoming cancelations for this access pass. */
  upcomingCancelationsMemberships: Scalars["Int"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** Whether or not customers can upgrade to different plans on this Access Pass. */
  upgradeable: Scalars["Boolean"]["output"];
  /** The description of the upsell for the access pass. */
  upsellDescription?: Maybe<Scalars["String"]["output"]>;
  /** The media for the upsell of the access pass in png, jpeg, or gif format */
  upsellMedia?: Maybe<AttachmentInterface>;
  /** The title of the upsell for the access pass. */
  upsellTitle?: Maybe<Scalars["String"]["output"]>;
  /** The upsells for this access pass. */
  upsells: PublicAccessPassConnection;
  /** The all time GMV for the access pass, converted to USD. */
  usdGmv: Scalars["Int"]["output"];
  /** The users of the access pass. */
  users: PublicProfileUserConnection;
  /** The users that have access passes in common with the current user. */
  usersWithAccessPassesInCommon: PublicProfileUserConnection;
  /** Whether this product is Whop verified. */
  verified: Scalars["Boolean"]["output"];
  /** This access pass will/will not be displayed publicly. */
  visibility: Visibility;
  /** A count of the visible plans on this access pass */
  visiblePlans: PublicPlanConnection;
  /** A count of the visible plans on this access pass */
  visiblePlansCount: Scalars["Int"]["output"];
  /**
   * the welcome message to be shown to users when they buy an access pass
   * @deprecated No longer used.
   */
  welcomeMessage?: Maybe<Scalars["String"]["output"]>;
  /** The date and time when the access pass was ready for the marketplace. */
  whopFourReadyAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ranking of the access pass in the marketplace. */
  whopRanking?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The users of the access pass.
   * @deprecated Use whop_users_sidebar_with_rank instead
   */
  whopUsersSidebar: PublicProfileUserConnection;
  /** The users of the access pass ranked by earnings on the platform. */
  whopUsersSidebarWithEarnings: EarningsSidebarOutput;
  /** The users of the access pass. */
  whopUsersSidebarWithRank: SidebarOutput;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassAppsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  category: AccessPassAttachmentCategories;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassBountiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassExperiencesArgs = {
  experienceType?: InputMaybe<ExperienceTypes>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  category: AccessPassAttachmentCategories;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassForumExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ProductImageStyles>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassIsInLeaderboardArgs = {
  competitionId?: InputMaybe<Scalars["String"]["input"]>;
  leaderboardType: LeaderboardTypes;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassIsUnrankedInLeaderboardArgs = {
  leaderboardType: LeaderboardTypes;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassItemOrderingArgs = {
  orderType: ItemOrderingOrderTypes;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassLeaderboardArgs = {
  competitionId?: InputMaybe<Scalars["String"]["input"]>;
  latestPaginationRank?: InputMaybe<Scalars["Int"]["input"]>;
  leaderboardType: LeaderboardTypes;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassMarketplaceApplicationsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassMarketplaceCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassMarketplaceCategoryArgs = {
  level: Scalars["Int"]["input"];
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassMyLeaderboardRankArgs = {
  competitionId?: InputMaybe<Scalars["String"]["input"]>;
  leaderboardType: LeaderboardTypes;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassPinnedExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassPlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  direction?: InputMaybe<Direction>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<PlansOrder>;
  releaseMethod?: InputMaybe<ReleaseMethod>;
  visibility?: InputMaybe<VisibilityFilter>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassProductHighlightsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  highlightType?: InputMaybe<ProductHighlightTypes>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassPublicExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  stars?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassUpsellsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassUsersWithAccessPassesInCommonArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassVisiblePlansArgs = {
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassWhopUsersSidebarArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ProductUserFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassWhopUsersSidebarWithEarningsArgs = {
  filter?: InputMaybe<WhopSidebarWithEarningsFilters>;
};

/** An access pass for a company, which gives access to an experience, and is paid for with a plan. */
export type AccessPassWhopUsersSidebarWithRankArgs = {
  filter?: InputMaybe<WhopSidebarFilters>;
};

/** An affiliate associated with an AccessPass */
export type AccessPassAffiliate = {
  __typename?: "AccessPassAffiliate";
  /** The AccessPass this affiliate is associated with */
  accessPass: PublicAccessPass;
  /** The number of referrals this affiliate has made */
  cachedReferralsCount: Scalars["Int"]["output"];
  /** The total USD rewards this affiliate has earned */
  cachedUsdRewards: Scalars["Float"]["output"];
  /** The date and time this affiliate was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The unique ID of this object */
  id: Scalars["ID"]["output"];
  /** The url for this affiliate */
  referralLink: Scalars["String"]["output"];
  /** The status of this affiliate */
  status: AccessPassAffiliateStatuses;
};

/** The connection type for AccessPassAffiliate. */
export type AccessPassAffiliateConnection = {
  __typename?: "AccessPassAffiliateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessPassAffiliateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessPassAffiliate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AccessPassAffiliateEdge = {
  __typename?: "AccessPassAffiliateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessPassAffiliate>;
};

/** An AccessPassAffiliate status */
export enum AccessPassAffiliateStatuses {
  /** Active */
  Active = "active",
  /** Archived */
  Archived = "archived",
}

/** An object that contains app session metrics for an access pass */
export type AccessPassAppSessions = {
  __typename?: "AccessPassAppSessions";
  /** The number of app sessions in the last 24 hours */
  last24hActiveUsers: Scalars["Int"]["output"];
};

/** The types of categories that can be used for AccessPass attachments. */
export enum AccessPassAttachmentCategories {
  AffiliateAssets = "affiliate_assets",
  GalleryImages = "gallery_images",
}

/** The conditions that an access pass can have */
export enum AccessPassConditions {
  HasPlans = "has_plans",
}

/** The connection type for AccessPass. */
export type AccessPassConnection = {
  __typename?: "AccessPassConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessPassEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessPass>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** A user's eligibility to join an access pass. */
export type AccessPassControlCenterJoinEligibility = {
  __typename?: "AccessPassControlCenterJoinEligibility";
  /** Whether or not the user can join the access pass. */
  canJoin: Scalars["Boolean"]["output"];
  /** The code representing the reason why the user cannot join the access pass. */
  reasonCode?: Maybe<RestrictionSetReasonCodes>;
};

/** An edge in a connection. */
export type AccessPassEdge = {
  __typename?: "AccessPassEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessPass>;
};

/** Values to filter access passes on */
export type AccessPassFilters = {
  /**
   * Whether or not this creator achieved the 3k in 30 milestone
   * @deprecated No longer available.
   */
  achievedThreeKInThirty?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** Whether or not to only return discoverable access passes. */
  discoverable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The discovery category to filter by
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The max global affiliate percentage */
  globalAffiliatePercentageMaximum?: InputMaybe<Scalars["Float"]["input"]>;
  /** The min global affiliate percentage */
  globalAffiliatePercentageMinimum?: InputMaybe<Scalars["Float"]["input"]>;
  /** The global affiliate status */
  globalAffiliateStatus?: InputMaybe<GlobalAffiliateStatuses>;
  /** An array, in order, of the category route tree that is being traversed. */
  marketplaceCategoryRoutes?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** What to order the results by. */
  order?: InputMaybe<PublicAccessPassesOrder>;
  /** The max price */
  priceMaximum?: InputMaybe<Scalars["Float"]["input"]>;
  /** The min price */
  priceMinimum?: InputMaybe<Scalars["Float"]["input"]>;
  /** Filter to show only passes owned by students of the specified access pass */
  studentsOfAccessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * Whether or not the access pass' company uses whop four
   * @deprecated No longer applies.
   */
  usesWhopFour?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An access pass member represents a user or company relationship to an access pass. It's access is denoted by accessLevel */
export type AccessPassMember = {
  __typename?: "AccessPassMember";
  /** The access level of the access pass member. If its admin, the member is an authorized user of the access pass. If its customer, the member has a valid membership to the access pass. If its no_access, the member does not have access to the access pass. */
  accessLevel: AccessLevel;
  /** The access pass object */
  accessPass: PublicAccessPass;
  /** The company buyer object. This is only present if the user is null. A company buyer is present when a company installs an app. It's kinda tech debt...you shouldn't have to worry about it. */
  companyBuyer?: Maybe<PublicCompany>;
  /** The timestamp (in milliseconds since epoch) of when the access pass member was created */
  createdAtMs: Scalars["BigInt"]["output"];
  /** The ID of the access pass member */
  id: Scalars["ID"]["output"];
  /** The order of the access pass member */
  order?: Maybe<Scalars["Float"]["output"]>;
  /** The timestamp (in milliseconds since epoch) of when the access pass member was last updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** The user object */
  user?: Maybe<PublicProfileUser>;
};

/** The connection type for AccessPassMember. */
export type AccessPassMemberConnection = {
  __typename?: "AccessPassMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessPassMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessPassMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AccessPassMemberEdge = {
  __typename?: "AccessPassMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessPassMember>;
};

/** An object representing the members by country for an access pass. */
export type AccessPassMembersByCountry = {
  __typename?: "AccessPassMembersByCountry";
  /** The country code of the members by country. */
  countryCode: Scalars["String"]["output"];
  /** The number of members in the country. */
  memberCount: Scalars["Int"]["output"];
};

/** The onboarding versions for access passes */
export enum AccessPassOnboardingVersionTypes {
  Mar_2025 = "mar_2025",
}

/** The ways a relation of AccessPasses can be ordered */
export enum AccessPassOrder {
  ActiveMembershipsCount = "active_memberships_count",
  CreatedAt = "created_at",
  UsdGmv = "usd_gmv",
  UsdGmv_30Days = "usd_gmv_30_days",
}

/** Input type for updating the order of an access pass member */
export type AccessPassOrderInput = {
  /** The ID of the access pass member */
  accessPassId: Scalars["ID"]["input"];
  /** The new order value */
  order?: InputMaybe<Scalars["Float"]["input"]>;
};

/** The access pass recommendations for a user */
export type AccessPassRecommendations = {
  __typename?: "AccessPassRecommendations";
  /** The recommended access passes */
  accessPasses: Array<PublicAccessPass>;
  /** The ID of the recommendation set */
  recommendationId: Scalars["ID"]["output"];
};

/** An abuse report for an access pass */
export type AccessPassReport = AbuseReportInterface &
  PublicAbuseReportInterface & {
    __typename?: "AccessPassReport";
    /** The category of the abuse report */
    abuseReportCategory: AbuseReportCategory;
    /** The sub category of the abuse report */
    abuseReportSubCategory: AbuseReportSubCategory;
    /** The access pass that the abuse report is for */
    accessPass: PublicAccessPass;
    /** The attachments for the abuse report */
    attachments: Array<AttachmentInterface>;
    /** When the abuse report was created */
    createdAt: Scalars["Timestamp"]["output"];
    /** The description of the abuse report */
    description: Scalars["String"]["output"];
    /** The ID of the abuse report */
    id: Scalars["ID"]["output"];
    /** The images for the abuse report */
    images: Array<Image>;
    /** The url of the company reporting the page */
    merchantUrl?: Maybe<Scalars["UrlString"]["output"]>;
    /** The company reporting the page */
    reporterCompany?: Maybe<PublicCompany>;
    /** The status of the abuse report */
    status: AbuseReportStatus;
    /** The user who made this report */
    user: User;
  };

/** An object the restrictions for a current access pass. */
export type AccessPassRestrictionSet = {
  __typename?: "AccessPassRestrictionSet";
  /** The country codes that are blocked from joining the access pass. */
  blockedCountryCodes: Array<Scalars["String"]["output"]>;
  /** The members by country for the access pass. */
  membersByCountry: Array<AccessPassMembersByCountry>;
};

/** A user's eligibility to review an access pass. */
export type AccessPassReviewEligibility = {
  __typename?: "AccessPassReviewEligibility";
  /** Whether or not the user can review the access pass. */
  canReview: Scalars["Boolean"]["output"];
  /** The reason the user cannot review the access pass. */
  reason?: Maybe<Scalars["String"]["output"]>;
  /**
   * Whether or not the user must wait until a certain date to review the access pass.
   * @deprecated Stop using this
   */
  waitUntil?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** An object representing a card that is displayed on the business homepage. */
export type AccessPassStat = {
  __typename?: "AccessPassStat";
  /** The average time spent in the last 24 hours, in seconds. */
  averageTimeSpent24Hours: Scalars["Int"]["output"];
};

/** The different types an access pass can be. */
export enum AccessPassTypes {
  /** App */
  App = "app",
  /** Experience Upsell */
  ExperienceUpsell = "experience_upsell",
  /** Regular */
  Regular = "regular",
}

/** Which columns can be used to sort. */
export enum AccessPassesSortableColumns {
  ActiveMembersCount = "active_members_count",
  ActiveMembershipsCount = "active_memberships_count",
  CreatedAt = "created_at",
  Id = "id",
}

/** An experience the current user has access to */
export type AccessibleExperience = {
  __typename?: "AccessibleExperience";
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The relevant access pass for the experience */
  accessPass?: Maybe<PublicAccessPass>;
  /** The access passes that are associated with this experience. */
  accessPasses: Array<PublicAccessPass>;
  /** The livestream for the experience */
  activeLivestreamFeed?: Maybe<PublicLivestreamFeed>;
  /** The experience interface for this experience. */
  app: PublicApp;
  /** The chat feed IDs associated with this experience */
  chatFeedIds: Array<Scalars["ID"]["output"]>;
  /** The chat feeds associated with this experience */
  chatFeeds: Array<ChatFeed>;
  /** The company that owns this experience. */
  company: PublicCompany;
  /** Retrieve a specific content rewards campaign */
  contentRewardsCampaign: PublicCampaign;
  /** The content rewards campaigns for this experience */
  contentRewardsCampaigns: PublicCampaignConnection;
  /** The timestamp of when this experience was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when this experience was created. */
  createdAtMs: Scalars["BigInt"]["output"];
  /** A short written description of what is being offered */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp (in milliseconds since epoch) of when the experience was soft deleted. If it's null, the experience is still active. */
  discardedAtMs?: Maybe<Scalars["BigInt"]["output"]>;
  /** The type of product/service being delivered. */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The features enabled for the experience */
  features: Array<Scalars["String"]["output"]>;
  /** The forum feed associated with this experience. */
  forumFeed?: Maybe<ForumFeed>;
  /** Whether the current user has access to this experience */
  hasAccess: Scalars["Boolean"]["output"];
  /** Whether to hide the experience if it is not accessible. */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The unique ID representing this experience */
  id: Scalars["ID"]["output"];
  /** The iframe link for the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface. Deprecated, use logo instead. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The image with fallback for this experience (uses app icon if no image is present). Deprecated, use logo instead. */
  imageWithFallbackSrcset: ImgSrcset;
  /** Whether or not this experience is in dev mode */
  interfaceDevMode: Scalars["Boolean"]["output"];
  /** Whether the current user is an authorized user of the company that owns this experience */
  isAuthorizedUser: Scalars["Boolean"]["output"];
  /** The timestamp of the last activity on this experience */
  lastActivityAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /**
   * The timestamp of the last activity on this experience
   * @deprecated Use last_activity_at instead
   */
  lastFeedContentItemAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The access passes that can be linked to the experience */
  linkableAccessPasses: PublicAccessPassConnection;
  /** The livestream feeds associated with this experience */
  livestreamFeeds: LivestreamFeedConnection;
  /** The logo for the experience. */
  logo?: Maybe<AttachmentInterface>;
  /** The marketplace access pass for the experience */
  marketplaceAccessPass?: Maybe<PublicAccessPass>;
  /** The most recent activity in this experience */
  mostRecentActivity?: Maybe<ExperienceActivityCardInterface>;
  /** The written name of the description. */
  name: Scalars["String"]["output"];
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed: Scalars["Boolean"]["output"];
  /** Whether or not experience content is shown in the explore page */
  showExploreContent: Scalars["Boolean"]["output"];
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The target link to request */
  targetLink?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the experience was updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<PublicPlan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
  /** The access pass for the experience */
  userDefaultAccessPass?: Maybe<PublicAccessPass>;
  /** The token for the websocket channel for this experience */
  websocketChannelToken?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the experience went live */
  wentLiveAt?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** An experience the current user has access to */
export type AccessibleExperienceAccessPassArgs = {
  direction: Direction;
  order: AccessPassOrder;
};

/** An experience the current user has access to */
export type AccessibleExperienceContentRewardsCampaignArgs = {
  id: Scalars["ID"]["input"];
};

/** An experience the current user has access to */
export type AccessibleExperienceContentRewardsCampaignsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ContentRewardsPublicCampaignsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An experience the current user has access to */
export type AccessibleExperienceImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An experience the current user has access to */
export type AccessibleExperienceImageWithFallbackSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An experience the current user has access to */
export type AccessibleExperienceLinkableAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An experience the current user has access to */
export type AccessibleExperienceLivestreamFeedsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An experience the current user has access to */
export type AccessibleExperienceTargetLinkArgs = {
  appViewType: AppViewTypes;
  mode: ExperienceLinkModes;
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** The connection type for AccessibleExperience. */
export type AccessibleExperienceConnection = {
  __typename?: "AccessibleExperienceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessibleExperienceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessibleExperience>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AccessibleExperienceEdge = {
  __typename?: "AccessibleExperienceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AccessibleExperience>;
};

/** Attributes specific to account managers */
export type AccountManagerAttributes = {
  __typename?: "AccountManagerAttributes";
  /** The Calendly link for scheduling meetings with the account manager */
  calendlyLink?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of AddAuthorizedUser */
export type AddAuthorizedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The email of the user to add. */
  email: Scalars["String"]["input"];
  /** The role to apply to the user */
  role: AuthorizedUserRoles;
};

/** Autogenerated input type of AddExperienceToAccessPass */
export type AddExperienceToAccessPassInput = {
  /** The ID of the Access Pass to add the Experience to. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Experience to be added to an Access Pass. */
  experienceId: Scalars["ID"]["input"];
};

/** Autogenerated input type of AddExternalAccount */
export type AddExternalAccountInput = {
  /** A token generated by Stripe JS for the external account. */
  accountToken: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the connected account to add the external account to. */
  connectedAccountId: Scalars["ID"]["input"];
};

/** Autogenerated input type of AddFcmToken */
export type AddFcmTokenInput = {
  /** Which app are you adding this FCM token for? Marketplace or dash? */
  app: FcmTokenAppTypes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The unique device identifier */
  deviceId?: InputMaybe<Scalars["String"]["input"]>;
  /** The device info for the device you're adding it to. Pass whatever you want up */
  deviceInfo?: InputMaybe<Scalars["JSON"]["input"]>;
  /** The firebase token (FCM) for the device you're adding it to */
  fcmToken: Scalars["String"]["input"];
  /** The mobile notification statuses for the device you're adding it to */
  mobileNotificationStatuses?: InputMaybe<MobileNotificationStatusesInput>;
};

/** Autogenerated input type of AddLedgerExternalAccount */
export type AddLedgerExternalAccountInput = {
  /** A token generated by Stripe JS for the external account. */
  accountToken: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account to add the external account to. */
  ledgerAccountId: Scalars["ID"]["input"];
};

/** Autogenerated input type of AddOauthEmail */
export type AddOauthEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Email sent by user on sign up */
  email: Scalars["String"]["input"];
  /** Auth provider */
  provider: OauthProviders;
  /** Auth state */
  state: Scalars["String"]["input"];
};

/** Autogenerated input type of AddRedirectUri */
export type AddRedirectUriInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL to whitelist */
  redirectUri: Scalars["String"]["input"];
};

/** The types of interactions */
export enum AddUserActions {
  Added = "added",
  Invited = "invited",
}

/** A physical address (usually from Stripe). */
export type Address = {
  __typename?: "Address";
  /** The city of the address. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** The country of the address. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** The line 1 of the address. */
  line1?: Maybe<Scalars["String"]["output"]>;
  /** The line 2 of the address. */
  line2?: Maybe<Scalars["String"]["output"]>;
  /** The name of the customer. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The postal code of the address. */
  postalCode?: Maybe<Scalars["String"]["output"]>;
  /** The state of the address. */
  state?: Maybe<Scalars["String"]["output"]>;
};

export type AddressInput = {
  /** The city of the address. */
  city?: InputMaybe<Scalars["String"]["input"]>;
  /** The country of the address. */
  country?: InputMaybe<Scalars["String"]["input"]>;
  /** The line 1 of the address. */
  line1?: InputMaybe<Scalars["String"]["input"]>;
  /** The line 2 of the address. */
  line2?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the customer. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The postal code of the address. */
  postalCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of the address. */
  state?: InputMaybe<Scalars["String"]["input"]>;
};

/** An affiliate of a company or a global affiliate */
export type Affiliate = {
  __typename?: "Affiliate";
  /** The total active members of the affiliate */
  activeMembersCount: Scalars["Int"]["output"];
  /** The overrides for this affiliate */
  affiliateOverrides: AffiliateOverrideConnection;
  /** The logs of this affiliate */
  affiliateReferralLogs?: Maybe<Array<AffiliateReferralLog>>;
  /** The type of this affiliate */
  affiliateType?: Maybe<AffiliateTypes>;
  /** All of the plan affiliates for this affiliate */
  affiliateWithPlans: PlanAffiliateConnection;
  /** The company attached to this affiliate */
  company: Company;
  /** The company member for this affiliate */
  companyMember?: Maybe<CompanyMember>;
  /** How many referrals have remained since they joined as members */
  customerRetention: Scalars["String"]["output"];
  /** A rolling 90-day retention rate for this affiliate */
  customerRetention90Days: Scalars["String"]["output"];
  /** The ID of the affiliate */
  id: Scalars["ID"]["output"];
  /** The total MRR of the affiliate */
  mrr: Scalars["String"]["output"];
  /** The company members that this affiliate has referred */
  referredCompanyMembers: CompanyMemberConnection;
  /** The status of the affiliate */
  status?: Maybe<Status>;
  /** The total count of all overrides for this affiliate */
  totalOverridesCount: Scalars["Int"]["output"];
  /** The total count of all plans this member is an affiliate for */
  totalPlanCount: Scalars["Int"]["output"];
  /** The total earnings of the affiliate from the users they referred */
  totalReferralEarnings: Scalars["String"]["output"];
  /** The total referrals of the affiliate */
  totalReferrals: Scalars["Int"]["output"];
  /** The total revenue of the affiliate from their referrals */
  totalRevenue: Scalars["String"]["output"];
  /**
   * The user attached to this affiliate
   * @deprecated This type has been deprecated. Use userAccount instead.
   */
  user: PublicUser;
  /** The user account that performed the action. */
  userAccount: PublicProfileUser;
  /**
   * The username of the affiliate
   * @deprecated Use the user object
   */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** An affiliate of a company or a global affiliate */
export type AffiliateAffiliateOverridesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An affiliate of a company or a global affiliate */
export type AffiliateAffiliateWithPlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An affiliate of a company or a global affiliate */
export type AffiliateReferredCompanyMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Affiliate. */
export type AffiliateConnection = {
  __typename?: "AffiliateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AffiliateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Affiliate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AffiliateEdge = {
  __typename?: "AffiliateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Affiliate>;
};

/** Stats for the affiliate landing page */
export type AffiliateLandingStats = {
  __typename?: "AffiliateLandingStats";
  /** The total number of referrals made by affiliates. */
  affiliateReferrals: Scalars["Int"]["output"];
  /** The total number of earnings made by affiliates. */
  rewardsToAffiliates: Scalars["Int"]["output"];
  /** The total number of referrals made by affiliates. */
  totalAffiliates: Scalars["Int"]["output"];
};

/** An object storing information about the affiliate */
export type AffiliateOverride = {
  __typename?: "AffiliateOverride";
  /** The direct link for the plan to refer. */
  directLink: Scalars["String"]["output"];
  /** The fee for the affiliate override */
  fee: Scalars["Float"]["output"];
  /** The ID of the plan affiliate */
  id: Scalars["ID"]["output"];
  /** Whether the affiliate override is a one time payout */
  onlyOnePayout: Scalars["Boolean"]["output"];
  /** The type of payout for the affiliate override */
  payoutType: AffiliatePayoutTypes;
  /** The plan that the affiliate override is associated with */
  plan: Plan;
  /** The total earnings of the affiliate from the users they referred */
  totalReferralEarnings: Scalars["Float"]["output"];
  /** The total referrals of the affiliate */
  totalReferrals: Scalars["Int"]["output"];
};

/** An object storing information about the affiliate */
export type AffiliateOverrideDirectLinkArgs = {
  linkType?: InputMaybe<PlanDirectLink>;
};

/** The connection type for AffiliateOverride. */
export type AffiliateOverrideConnection = {
  __typename?: "AffiliateOverrideConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AffiliateOverrideEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AffiliateOverride>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AffiliateOverrideEdge = {
  __typename?: "AffiliateOverrideEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AffiliateOverride>;
};

/** The types of payouts an affiliate can have */
export enum AffiliatePayoutTypes {
  FlatFee = "flat_fee",
  Percentage = "percentage",
}

/** Which columns can be used to sort. */
export enum AffiliatePlansSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** A log to track affiliate referrals. */
export type AffiliateReferralLog = {
  __typename?: "AffiliateReferralLog";
  /** The discord username of the affiliate, pulled from the default Discord on their Whop account. */
  affiliateDiscordUsername?: Maybe<Scalars["String"]["output"]>;
  /** The type the affiliate has been created as. */
  affiliateType?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the affiliate user. */
  affiliateUserId?: Maybe<Scalars["ID"]["output"]>;
  /** The username of the affiliate (aka their referral code). */
  affiliateUsername?: Maybe<Scalars["String"]["output"]>;
  /** The amount the affiliate received for the referral. */
  amount?: Maybe<Scalars["String"]["output"]>;
  /** The company member for the referred user. */
  buyerCompanyMember?: Maybe<CompanyMember>;
  /** The internal ID of the buyer. */
  buyerId?: Maybe<Scalars["ID"]["output"]>;
  /** The username of the buyer (aka their Whop username). */
  buyerUsername?: Maybe<Scalars["String"]["output"]>;
  /** When the log was created. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether or not this was the first payment for the affiliate. */
  firstPayment?: Maybe<Scalars["Boolean"]["output"]>;
  /** The internal ID of the log. */
  id: Scalars["ID"]["output"];
  /** The plan that was purchased by the buyer. */
  plan?: Maybe<Plan>;
  /** The details of the affiliate setup. */
  planAffiliate?: Maybe<PlanAffiliate>;
  /** The name of the plan that was purchased by the buyer. */
  planName?: Maybe<Scalars["String"]["output"]>;
  /** The raw amount the affiliate received for the referral. */
  rawAmount?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for AffiliateReferralLog. */
export type AffiliateReferralLogConnection = {
  __typename?: "AffiliateReferralLogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AffiliateReferralLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AffiliateReferralLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AffiliateReferralLogEdge = {
  __typename?: "AffiliateReferralLogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AffiliateReferralLog>;
};

/** Values to filter affiliate referral logs on */
export type AffiliateReferralLogFilters = {
  /** Specific affiliates. */
  affiliateIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A specific affiliate type. */
  affiliateType?: InputMaybe<AffiliateTypes>;
  /** Specific plans. */
  planIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** Specific users. */
  userIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** Which columns can be used to sort. */
export enum AffiliateReferralLogsSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** The settings for an affiliate program for a company. */
export type AffiliateSettings = {
  __typename?: "AffiliateSettings";
  /** Whether or not the affiliate is currently enabled */
  enabled?: Maybe<Scalars["Boolean"]["output"]>;
  /** The fee charged for each referral */
  fee?: Maybe<Scalars["Float"]["output"]>;
  /** Whether or not the affiliate can only payout once per month */
  onlyOnePayout?: Maybe<Scalars["Boolean"]["output"]>;
  /** The payout type of the affiliate */
  payoutType?: Maybe<PayoutTypes>;
  /** The reward for each referral */
  reward?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the affiliate has completed the setup process */
  setup?: Maybe<Scalars["Boolean"]["output"]>;
  /** The total amount of earnings made by the affiliate */
  totalReferralEarnings?: Maybe<Scalars["String"]["output"]>;
  /** The total number of referrals made by the affiliate */
  totalReferrals?: Maybe<Scalars["Int"]["output"]>;
};

export type AffiliateSettingsInput = {
  /** Whether or not affiliates are enabled for this plan. */
  enabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The percentage/flat price of the sale that is awarded to the affiliate. */
  fee: Scalars["StringFloat"]["input"];
  /** Marks whether or not the affiliate can only receive one payout per sale. */
  onlyOnePayout: Scalars["Boolean"]["input"];
  /** Whether the affiliate is paid by a percentage or flat amount. */
  payoutType: PayoutTypes;
};

/** The stats for an affiliate */
export type AffiliateStats = {
  __typename?: "AffiliateStats";
  /** The average customer retention, excluding affiliates with no referrals */
  customerRetention: Scalars["String"]["output"];
  /** The total number of referrals affiliates have accrued */
  totalReferrals: Scalars["Int"]["output"];
  /** The total amount of revenue affiliates have generated */
  totalRevenue: Scalars["String"]["output"];
  /** The total amount of rewards affiliates have earned */
  totalRewards: Scalars["String"]["output"];
};

/** The scope of an affiliate (company based, global, etc.) */
export enum AffiliateTypes {
  /** Custom */
  Custom = "custom",
  /** Global */
  Global = "global",
  /** Marketplace */
  Marketplace = "marketplace",
  /** Passholder */
  Passholder = "passholder",
}

/** Which columns can be used to sort. */
export enum AffiliatesSortableColumns {
  CachedTotalReferrals = "cached_total_referrals",
  CachedTotalRewards = "cached_total_rewards",
  CreatedAt = "created_at",
  Id = "id",
}

/** Allowed file types for uploading to the platform */
export enum AllowedFileExtensions {
  Aac = "aac",
  Ai = "ai",
  Avi = "avi",
  Avif = "avif",
  Csv = "csv",
  Doc = "doc",
  Docx = "docx",
  Eps = "eps",
  Flac = "flac",
  Gif = "gif",
  Heic = "heic",
  Ics = "ics",
  Jpeg = "jpeg",
  Jpg = "jpg",
  Keynote = "keynote",
  M4a = "m4a",
  M4v = "m4v",
  Mkv = "mkv",
  Mov = "mov",
  Mp3 = "mp3",
  Mp4 = "mp4",
  Mpga = "mpga",
  Numbers = "numbers",
  Ods = "ods",
  Odt = "odt",
  Pages = "pages",
  Pdf = "pdf",
  Png = "png",
  Ppt = "ppt",
  Pptx = "pptx",
  Psd = "psd",
  Qt = "qt",
  Rar = "rar",
  Rtf = "rtf",
  Svg = "svg",
  Tiff = "tiff",
  Txt = "txt",
  Vcf = "vcf",
  Wav = "wav",
  Webp = "webp",
  Wmv = "wmv",
  Xls = "xls",
  Xlsx = "xlsx",
  Zip = "zip",
}

/** Autogenerated input type of AnalyzeAttachment */
export type AnalyzeAttachmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID returned by the direct upload mutation */
  directUploadId: Scalars["String"]["input"];
  /** The type of media to analyze */
  mediaType: Media;
  /** The parts of the multipart upload */
  multipartParts?: InputMaybe<Array<UploadPartInput>>;
  /** The ID returned by the direct upload mutation */
  multipartUploadId?: InputMaybe<Scalars["String"]["input"]>;
};

/** A specific API endpoint that a permission can be granted for. */
export type ApiEndpoint = {
  __typename?: "ApiEndpoint";
  /** The specific endpoint that the permission is for. */
  identifier: ApiKeyPermissions;
  /** The readable name of the endpoint. */
  name: Scalars["String"]["output"];
};

/** An API resource (object class) and the endpoints that can be accessed for that resource. */
export type ApiKeyPermission = {
  __typename?: "ApiKeyPermission";
  /** The specific endpoint that the permission is for. */
  endpoints?: Maybe<Array<ApiEndpoint>>;
  /** The resource the endpoint under. */
  resource: Scalars["String"]["output"];
};

/** The different types of permissions an api key can have. */
export enum ApiKeyPermissions {
  /** Add free days membership */
  AddFreeDaysMembership = "add_free_days_membership",
  /** Cancel membership */
  CancelMembership = "cancel_membership",
  /** Create checkout session */
  CreateCheckoutSession = "create_checkout_session",
  /** Create plan */
  CreatePlan = "create_plan",
  /** Create promo code */
  CreatePromoCode = "create_promo_code",
  /** Create push notification */
  CreatePushNotification = "create_push_notification",
  /** Create quick link */
  CreateQuickLink = "create_quick_link",
  /** Create webhook */
  CreateWebhook = "create_webhook",
  /** Delete checkout session */
  DeleteCheckoutSession = "delete_checkout_session",
  /** Delete experience */
  DeleteExperience = "delete_experience",
  /** Delete promo code */
  DeletePromoCode = "delete_promo_code",
  /** Delete webhook */
  DeleteWebhook = "delete_webhook",
  /** List access passes */
  ListAccessPasses = "list_access_passes",
  /** List checkout sessions */
  ListCheckoutSessions = "list_checkout_sessions",
  /** List customers */
  ListCustomers = "list_customers",
  /** List experiences */
  ListExperiences = "list_experiences",
  /** List licenses */
  ListLicenses = "list_licenses",
  /** List members */
  ListMembers = "list_members",
  /** List memberships */
  ListMemberships = "list_memberships",
  /** List payment fees */
  ListPaymentFees = "list_payment_fees",
  /** List payments */
  ListPayments = "list_payments",
  /** List plans */
  ListPlans = "list_plans",
  /** List products */
  ListProducts = "list_products",
  /** List promo codes */
  ListPromoCodes = "list_promo_codes",
  /** List reviews */
  ListReviews = "list_reviews",
  /** List webhooks */
  ListWebhooks = "list_webhooks",
  /** Retrieve access pass */
  RetrieveAccessPass = "retrieve_access_pass",
  /** Retrieve checkout session */
  RetrieveCheckoutSession = "retrieve_checkout_session",
  /** Retrieve company */
  RetrieveCompany = "retrieve_company",
  /** Retrieve customer */
  RetrieveCustomer = "retrieve_customer",
  /** Retrieve experience */
  RetrieveExperience = "retrieve_experience",
  /** Retrieve member */
  RetrieveMember = "retrieve_member",
  /** Retrieve membership */
  RetrieveMembership = "retrieve_membership",
  /** Retrieve payment */
  RetrievePayment = "retrieve_payment",
  /** Retrieve plan */
  RetrievePlan = "retrieve_plan",
  /** Retrieve product */
  RetrieveProduct = "retrieve_product",
  /** Retrieve promo code */
  RetrievePromoCode = "retrieve_promo_code",
  /** Retrieve review */
  RetrieveReview = "retrieve_review",
  /** Retrieve webhook */
  RetrieveWebhook = "retrieve_webhook",
  /** Send notification customers */
  SendNotificationCustomers = "send_notification_customers",
  /** Send notification members */
  SendNotificationMembers = "send_notification_members",
  /** Terminate membership */
  TerminateMembership = "terminate_membership",
  /** Update access pass */
  UpdateAccessPass = "update_access_pass",
  /** Update experience */
  UpdateExperience = "update_experience",
  /** Update membership */
  UpdateMembership = "update_membership",
  /** Update plan */
  UpdatePlan = "update_plan",
  /** Update product */
  UpdateProduct = "update_product",
  /** Update promo code */
  UpdatePromoCode = "update_promo_code",
  /** Update webhook */
  UpdateWebhook = "update_webhook",
  /** Validate license */
  ValidateLicense = "validate_license",
}

/** An API key connected to an application */
export type ApiKeyV2 = {
  __typename?: "ApiKeyV2";
  /** When this API key was created at */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of this API key */
  id: Scalars["ID"]["output"];
  /** A user set name to identify an API key */
  nickname?: Maybe<Scalars["String"]["output"]>;
  /** The permissions this api key has enabled. If its empty, the api key is unscoped. */
  permissions: Array<ApiKeyPermissions>;
  /** This is the API key used to authenticate requests */
  token: Scalars["String"]["output"];
  /** If true, the api key is unscoped and has access to all endpoints. */
  unscoped: Scalars["Boolean"]["output"];
};

/** The connection type for ApiKeyV2. */
export type ApiKeyV2Connection = {
  __typename?: "ApiKeyV2Connection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApiKeyV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ApiKeyV2>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ApiKeyV2Edge = {
  __typename?: "ApiKeyV2Edge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ApiKeyV2>;
};

/** The different API versions */
export enum ApiVersion {
  V2 = "v2",
  V5 = "v5",
}

/** An object representing an experience interface */
export type App = {
  __typename?: "App";
  /** The access pass that is used to sell the app */
  accessPass?: Maybe<AccessPass>;
  /** The agent users that are owned by this application. */
  agentUsers: UserConnection;
  /** The API keys for the app */
  apiKeys: PrivateApiKeyConnection;
  /** The app views for this app */
  appViews: AppViewConnection;
  /** The developer base url of the app */
  baseDevUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The preview base url of the app, used primarily by Whop admins for pre-release versions of apps. */
  basePreviewUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The base url of the app */
  baseUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The capabilities of the app */
  capabilities: Array<Scalars["String"]["output"]>;
  /** The company that owns the app */
  company: PublicCompany;
  /** The number of experiences on a company that use this app */
  count?: Maybe<Scalars["Int"]["output"]>;
  /** The default experience description for this app */
  defaultExperienceDescription?: Maybe<Scalars["String"]["output"]>;
  /** The description of the app */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The unique part of the proxied domain for this app. */
  domainId: Scalars["String"]["output"];
  /** The path for the hub view of the app */
  experiencePath?: Maybe<Scalars["String"]["output"]>;
  /** If the apps experience's should force showing the pre-checkout iframe, and not rely on app connections. */
  forceCheckoutIframe: Scalars["Boolean"]["output"];
  /** The hub call to action text for this app */
  hubCta?: Maybe<Scalars["String"]["output"]>;
  /** The icon for the app */
  icon?: Maybe<AttachmentInterface>;
  /** The ID of the app */
  id: Scalars["ID"]["output"];
  /**
   * The image for the app
   * @deprecated Use imageSrcset instead.
   */
  image: Scalars["String"]["output"];
  /** The image for the experience interface. Deprecated, use icon instead. */
  imageSrcset: ImgSrcset;
  /** The internal identifier for the app */
  internalIdentifier?: Maybe<Scalars["String"]["output"]>;
  /**
   * whether or not this experience is internal to Whop
   * @deprecated No longer implemented. Always returns false.
   */
  isInternalExperience: Scalars["Boolean"]["output"];
  /** The name of the app */
  name: Scalars["String"]["output"];
  /** The notification topics that have been created by an app */
  notificationTopics: NotificationTopicConnection;
  /** If the app can only create experiences with the private access level */
  onlyPrivate: Scalars["Boolean"]["output"];
  /**
   * The paths of the app
   * @deprecated Use app_views instead
   */
  paths: ExperienceInterfacePaths;
  /** The product page text for this app */
  productPageText?: Maybe<Scalars["String"]["output"]>;
  /**
   * The status for the app
   * @deprecated Use status_v2
   */
  status: ExperienceInterfaceStatuses;
  /** The status for the app */
  statusV2: AppStatuses;
  /** Total installs */
  totalInstalls: Scalars["Int"]["output"];
  /** If the experience is verified by Whop or not */
  verified: Scalars["Boolean"]["output"];
  /** The webhooks that have been set by an app */
  webhooks: WebhookConnection;
};

/** An object representing an experience interface */
export type AppAgentUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience interface */
export type AppApiKeysArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience interface */
export type AppAppViewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience interface */
export type AppImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an experience interface */
export type AppNotificationTopicsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience interface */
export type AppWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for App. */
export type AppConnection = {
  __typename?: "AppConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<App>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AppEdge = {
  __typename?: "AppEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<App>;
};

/** Image styles for app. */
export enum AppImageStyles {
  S16 = "s16",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S80 = "s80",
}

/** The status of an experience interface */
export enum AppStatuses {
  /** Hidden */
  Hidden = "hidden",
  /** Live */
  Live = "live",
  /** Unlisted */
  Unlisted = "unlisted",
}

/** An object representing an app view for an app */
export type AppView = {
  __typename?: "AppView";
  /** When the app view was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the app view */
  id: Scalars["ID"]["output"];
  /** The path of the app view */
  path: Scalars["String"]["output"];
  /** The type of the app view */
  viewType: AppViewTypes;
};

/** The connection type for AppView. */
export type AppViewConnection = {
  __typename?: "AppViewConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppViewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AppView>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AppViewEdge = {
  __typename?: "AppViewEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AppView>;
};

/** The different types of an app view */
export enum AppViewTypes {
  /** Analytics */
  Analytics = "analytics",
  /** Checkout */
  Checkout = "checkout",
  /** Dash */
  Dash = "dash",
  /** Hub */
  Hub = "hub",
  /** Preview */
  Preview = "preview",
  /** Seller */
  Seller = "seller",
  /** Seo Api */
  SeoApi = "seo_api",
}

/** Any additional data required for processing an Apple IAP checkout. */
export type AppleData = {
  __typename?: "AppleData";
  /** The app account token to be used for the Apple IAP checkout. */
  appAccountToken: Scalars["String"]["output"];
  /** The IAP product ID to be used for the Apple IAP checkout. */
  iapProductId?: Maybe<Scalars["String"]["output"]>;
};

/** How the app is made available. */
export enum AppleEnvironments {
  Production = "production",
  Sandbox = "sandbox",
}

/** The criteria for an application to the marketplace. */
export enum ApplicationCriteriaIdentifier {
  /** App */
  App = "app",
  /** Available Plan */
  AvailablePlan = "available_plan",
  /** Benefit */
  Benefit = "benefit",
  /** Choose Category */
  ChooseCategory = "choose_category",
  /** Description */
  Description = "description",
  /** Gallery Images */
  GalleryImages = "gallery_images",
  /** Headline */
  Headline = "headline",
  /** Logo */
  Logo = "logo",
  /** Setup Payouts */
  SetupPayouts = "setup_payouts",
  /** Title */
  Title = "title",
  /** Visibility */
  Visibility = "visibility",
}

/** Autogenerated input type of ApplyPromoCode */
export type ApplyPromoCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the membership to update. */
  membershipId: Scalars["ID"]["input"];
  /** The promo code to apply to the membership. */
  promoCodeId: Scalars["ID"]["input"];
};

/** Autogenerated input type of ApplyPromoCodeToMembership */
export type ApplyPromoCodeToMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the membership to update. */
  membershipId: Scalars["ID"]["input"];
  /** The code of the promo code to apply to the membership. */
  promoCodeCode: Scalars["String"]["input"];
};

/** Autogenerated input type of ApplyPromoCodeToMyMembership */
export type ApplyPromoCodeToMyMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the membership to update. */
  membershipId: Scalars["ID"]["input"];
  /** The code of the promo code to apply to the membership. */
  promoCodeCode: Scalars["String"]["input"];
};

/** Autogenerated input type of ApproveAllEntries */
export type ApproveAllEntriesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the plan you want to approve all waitlist entries for. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of ApproveAllWaitlistEntries */
export type ApproveAllWaitlistEntriesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of ApproveEntry */
export type ApproveEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the entry to approve. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of ApproveFlaggedSubmission */
export type ApproveFlaggedSubmissionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the submission to approve */
  submissionId: Scalars["ID"]["input"];
};

/** Autogenerated input type of ApproveSubmission */
export type ApproveSubmissionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the submission to approve */
  submissionId: Scalars["ID"]["input"];
};

/** Autogenerated input type of ArchiveAffiliate */
export type ArchiveAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the affiliate to archive. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of ArchiveCampaign */
export type ArchiveCampaignInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the campaign to archive */
  id: Scalars["ID"]["input"];
};

/** An asset associated with a content rewards campaign object */
export type Asset = {
  __typename?: "Asset";
  /** The URL of the favicon for the linked site */
  favicon?: Maybe<Scalars["String"]["output"]>;
  /** ID of the asset */
  id: Scalars["ID"]["output"];
  /** The URL of an image representing the linked content */
  image?: Maybe<Scalars["String"]["output"]>;
  /** Whether the link embed is still being processed */
  processing: Scalars["Boolean"]["output"];
  /** The title of the linked content */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the linked content */
  url: Scalars["String"]["output"];
};

/** The connection type for Asset. */
export type AssetConnection = {
  __typename?: "AssetConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Asset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AssetEdge = {
  __typename?: "AssetEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Asset>;
};

/** Autogenerated input type of AssignAccountManager */
export type AssignAccountManagerInput = {
  /** The email of the account manager to use. */
  accountManagerEmail?: InputMaybe<Scalars["String"]["input"]>;
  /** The time of when the Account Manager started. */
  amStartedAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company to update. */
  companyId: Scalars["String"]["input"];
};

/** Autogenerated input type of AttachAffiliate */
export type AttachAffiliateInput = {
  /** The identifier of the affiliate to attach to the membership (either a username, email, or user ID). */
  affiliateIdentifier: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the membership to update. */
  membershipId: Scalars["ID"]["input"];
};

/** The types of records that an attachment can be attached to */
export enum AttachableRecords {
  AbuseReport = "abuse_report",
  AccessPass = "access_pass",
  App = "app",
  AutomatedMessagesConfig = "automated_messages_config",
  Bot = "bot",
  Bounty = "bounty",
  BountySubmission = "bounty_submission",
  CompetitionPrize = "competition_prize",
  ContentRewardCampaign = "content_reward_campaign",
  ContentRewardSubmission = "content_reward_submission",
  Dispute = "dispute",
  DmsPost = "dms_post",
  Experience = "experience",
  ForumPost = "forum_post",
  ResolutionEventUpload = "resolution_event_upload",
  Review = "review",
  ReviewReport = "review_report",
  User = "user",
}

/** Input for an attachment */
export type AttachmentInput = {
  /** The ID returned by the direct upload mutation, only use this to attach a new upload */
  directUploadId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the attachment, use this when updating a resource and keeping a subset of the attachments */
  id?: InputMaybe<Scalars["ID"]["input"]>;
};

export type AttachmentInterface = {
  /** Whether the attachment has been analyzed */
  analyzed: Scalars["Boolean"]["output"];
  /**
   * The size of the file in bytes
   * @deprecated Use byteSizeV2 instead
   */
  byteSize?: Maybe<Scalars["Int"]["output"]>;
  /** The size of the file in bytes */
  byteSizeV2?: Maybe<Scalars["BigInt"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The name of the file */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the attachment */
  id: Scalars["ID"]["output"];
  /** The moderation result of the attachment */
  moderationResult?: Maybe<ModerationResults>;
  /** The position of the attachment */
  position?: Maybe<Scalars["Int"]["output"]>;
  /** A signed ID of the attachment to directly query the attachment */
  signedId?: Maybe<Scalars["ID"]["output"]>;
  /** The source of the attachment */
  source: AttachmentSource;
  /** The source URL of the attachment */
  sourceUrl?: Maybe<Scalars["String"]["output"]>;
};

export type AttachmentInterfaceSourceArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** The connection type for AttachmentInterface. */
export type AttachmentInterfaceConnection = {
  __typename?: "AttachmentInterfaceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AttachmentInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AttachmentInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AttachmentInterfaceEdge = {
  __typename?: "AttachmentInterfaceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AttachmentInterface>;
};

/** Represents an attachment source */
export type AttachmentSource = {
  __typename?: "AttachmentSource";
  /** The URL to access the 2x scaled variant */
  doubleUrl?: Maybe<Scalars["String"]["output"]>;
  /** The URL to access the attachment */
  url: Scalars["String"]["output"];
};

/** Represents an audio attachment */
export type AudioAttachment = AttachmentInterface & {
  __typename?: "AudioAttachment";
  /** Whether the attachment has been analyzed */
  analyzed: Scalars["Boolean"]["output"];
  /** The bitrate of the audio */
  bitrate?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The size of the file in bytes
   * @deprecated Use byteSizeV2 instead
   */
  byteSize?: Maybe<Scalars["Int"]["output"]>;
  /** The size of the file in bytes */
  byteSizeV2?: Maybe<Scalars["BigInt"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The duration of the audio in seconds */
  duration?: Maybe<Scalars["Float"]["output"]>;
  /** The name of the file */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the attachment */
  id: Scalars["ID"]["output"];
  /** The moderation result of the attachment */
  moderationResult?: Maybe<ModerationResults>;
  /** The position of the attachment */
  position?: Maybe<Scalars["Int"]["output"]>;
  /** A signed ID of the attachment to directly query the attachment */
  signedId?: Maybe<Scalars["ID"]["output"]>;
  /** The source of the attachment */
  source: AttachmentSource;
  /** The source URL of the attachment */
  sourceUrl?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the waveform for the audio */
  waveformUrl?: Maybe<Scalars["String"]["output"]>;
};

/** Represents an audio attachment */
export type AudioAttachmentSourceArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Which columns can be used to sort. */
export enum AuditLogsSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** The possible 2FA authentication types. */
export enum AuthenticationMethods {
  Authenticator = "authenticator",
  Sms = "sms",
}

/** An object representing an authenticator setup. */
export type AuthenticatorData = {
  __typename?: "AuthenticatorData";
  /** A Base 64 representation of a QR code for the authenticator. */
  qrCode: Scalars["String"]["output"];
  /** The URL for the authenticator. */
  url: Scalars["String"]["output"];
};

/** Autogenerated input type of AuthenticatorData */
export type AuthenticatorDataInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** A user who has elevated security privileges for a company */
export type AuthorizedUser = {
  __typename?: "AuthorizedUser";
  /** Whether or not the current_user in context can transfer ownership of the company to this authorized user. */
  canTransferOwnershipTo: Scalars["Boolean"]["output"];
  /** The company associated with the authorized user. */
  company: PublicCompany;
  /** The email of the authorized user. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** A unique ID representing the authorized user object. */
  id: Scalars["ID"]["output"];
  /** The name of the authorized user. */
  name?: Maybe<Scalars["String"]["output"]>;
  /**
   * The URL of the user's profile picture
   * @deprecated Use profileImageSrcset instead
   */
  profilePic: Scalars["String"]["output"];
  /** The user's profile image. Deprecated, use profilePicture instead. */
  profilePicSrcset: ImgSrcset;
  /** The user's profile picture */
  profilePicture?: Maybe<AttachmentInterface>;
  /** The role of the authorized user in the company. */
  role: AuthorizedUserRoles;
  /** Whether or not the authorized user has 2FA enabled. */
  security: SecurityLevels;
  /** The user ID of the authorized user. */
  userId: Scalars["ID"]["output"];
  /** The Whop username of the authorized user. */
  username: Scalars["String"]["output"];
  /** Whether this whop shows on the profile page */
  visibilityOnProfile: ProfileVisibilities;
};

/** A user who has elevated security privileges for a company */
export type AuthorizedUserProfilePicSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** The connection type for AuthorizedUser. */
export type AuthorizedUserConnection = {
  __typename?: "AuthorizedUserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuthorizedUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuthorizedUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AuthorizedUserEdge = {
  __typename?: "AuthorizedUserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AuthorizedUser>;
};

/** An invitation to add someone to a company. */
export type AuthorizedUserInvite = {
  __typename?: "AuthorizedUserInvite";
  /** The date and time the invite was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The email of the person being invited. */
  email: Scalars["String"]["output"];
  /** A unique ID representing the invite object. */
  id: Scalars["ID"]["output"];
  /** The role assigned to the invite. */
  role: AuthorizedUserRoles;
};

/** The connection type for AuthorizedUserInvite. */
export type AuthorizedUserInviteConnection = {
  __typename?: "AuthorizedUserInviteConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuthorizedUserInviteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AuthorizedUserInvite>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type AuthorizedUserInviteEdge = {
  __typename?: "AuthorizedUserInviteEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<AuthorizedUserInvite>;
};

/** Possible roles an authorized user can have */
export enum AuthorizedUserRoles {
  /** Admin */
  Admin = "admin",
  /** App Manager */
  AppManager = "app_manager",
  /** Manager */
  Manager = "manager",
  /** Moderator */
  Moderator = "moderator",
  /** Owner */
  Owner = "owner",
  /** Sales Manager */
  SalesManager = "sales_manager",
  /** Support */
  Support = "support",
}

/** Autogenerated input type of AutoJoinDormantUsers */
export type AutoJoinDormantUsersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the destination access pass */
  destinationAccessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the destination company */
  destinationCompanyId: Scalars["String"]["input"];
  /** The ID of the origin company */
  originCompanyId: Scalars["ID"]["input"];
};

/** A configuration for an automated message */
export type AutomatedMessagesConfig = {
  __typename?: "AutomatedMessagesConfig";
  /** The attachments for this config */
  attachments: Array<AttachmentInterface>;
  /** The content of this automated message config */
  content: Scalars["String"]["output"];
  /** When this automated message config was created at */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether or not this automated message config sends an email when triggered */
  emailEnabled: Scalars["Boolean"]["output"];
  /**
   * The file attachments for this message
   * @deprecated Use the 'attachments' field instead, it also returns attachments.
   */
  fileAttachments: Array<FeedFileAttachment>;
  /** The ID of this automated message config */
  id: Scalars["ID"]["output"];
  /** Whether or not this automated message config is enabled */
  isEnabled: Scalars["Boolean"]["output"];
  /** The team member that will send this automated message. If not specified, defaults to the original bot owner. */
  sendFromTeamMember?: Maybe<AuthorizedUser>;
};

/** A configuration for an automated message */
export type AutomatedMessagesTrigger = {
  __typename?: "AutomatedMessagesTrigger";
  /** The config for this automated message trigger */
  config?: Maybe<AutomatedMessagesConfig>;
  /** When this automated message config was created at */
  createdAt: Scalars["Timestamp"]["output"];
  /** The default content of this automated message trigger */
  defaultContent: Scalars["String"]["output"];
  /** The description of this automated message trigger */
  description: Scalars["String"]["output"];
  /** The ID of this automated message config */
  identifier: Scalars["ID"]["output"];
  /** Whether or not this automated message trigger is visible */
  isVisible: Scalars["Boolean"]["output"];
  /** The order of this automated message trigger */
  order: Scalars["Int"]["output"];
  /** The title of this automated message trigger */
  title: Scalars["String"]["output"];
};

/** A calendar availability */
export type Availability = {
  __typename?: "Availability";
  /** When the availability was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the availability */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The duration of the availability in minutes */
  durationInMinutes: Scalars["Int"]["output"];
  /** The ID of the availability */
  id: Scalars["ID"]["output"];
  /** The title of the availability */
  title: Scalars["String"]["output"];
};

/** An experience activity card about a calendar booking availability */
export type AvailabilityCard = ExperienceActivityCardInterface & {
  __typename?: "AvailabilityCard";
  /** The availability that this card is about */
  availability?: Maybe<Availability>;
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** Image styles for avatar. */
export enum AvatarImageStyles {
  S16 = "s16",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S64 = "s64",
  S80 = "s80",
  S128 = "s128",
  S180 = "s180",
}

/** A cached balance for a LedgerAccount in respect to a currency. */
export type BalanceCache = {
  __typename?: "BalanceCache";
  /** The amount of the balance. */
  balance: Scalars["Float"]["output"];
  /** The currency of the balance. */
  currency: Currencies;
  /** The amount of the balance that is in transit to the bank. */
  inTransitToBankBalance: Scalars["Float"]["output"];
  /** The amount of the balance that is lifetime earnings. */
  lifetimeEarningsBalance: Scalars["Float"]["output"];
  /** The minimum balance to retain in the account after an automatic withdrawal. */
  minimumBalanceToRetain?: Maybe<Scalars["Float"]["output"]>;
  /** The amount of the balance that is nonwithdrawable. */
  nonwithdrawableBalance: Scalars["Float"]["output"];
  /** The amount of the balance that is pending. */
  pendingBalance: Scalars["Float"]["output"];
  /** The amount of the balance that has been received. */
  receivedFunds?: Maybe<Scalars["Float"]["output"]>;
  /** The amount of the balance that is reserved. */
  reserveBalance: Scalars["Float"]["output"];
  /** The amount of the balance that is withdrawable. */
  totalWithdrawableBalance: Scalars["Float"]["output"];
  /** The amount of the balance that has been withdrawn. */
  totalWithdrawn?: Maybe<Scalars["Float"]["output"]>;
  /** The amount of the balance that has been transferred. */
  transferredFunds?: Maybe<Scalars["Float"]["output"]>;
};

/** The connection type for BalanceCache. */
export type BalanceCacheConnection = {
  __typename?: "BalanceCacheConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BalanceCacheEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BalanceCache>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BalanceCacheEdge = {
  __typename?: "BalanceCacheEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BalanceCache>;
};

/** The reasons for banning a user */
export enum BanReasons {
  BottingContentRewards = "botting_content_rewards",
  BottingNegativeReviews = "botting_negative_reviews",
  Harassment = "harassment",
  Other = "other",
  Spamming = "spamming",
}

/** Autogenerated input type of BanUser */
export type BanUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The custom reason for banning the user */
  customReason?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the feed to delete messages from */
  deleteMessagesInFeedId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The reason for banning the user */
  reason?: InputMaybe<BanReasons>;
  /** The ID of the user to ban */
  userId: Scalars["ID"]["input"];
};

export type BaseEntityInterface = {
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The type of the card */
  entityType: EntityTypes;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
};

export type BasisTheoryInput = {
  /** An ID for a BasisTheory 3DS session. */
  basisTheory3dsSessionId?: InputMaybe<Scalars["String"]["input"]>;
  /** An ID for a BasisTheory token that represents an ApplePay/GooglePay cryptogram. */
  basisTheoryCryptogramToken?: InputMaybe<Scalars["String"]["input"]>;
  /** An ID for a BasisTheory token representing a credit/debit card or a DPAN. */
  basisTheoryToken?: InputMaybe<Scalars["String"]["input"]>;
};

/** The reason why a specific payment was billed */
export enum BillingReasons {
  Manual = "manual",
  OneTime = "one_time",
  SubscriptionCreate = "subscription_create",
  SubscriptionCycle = "subscription_cycle",
  Upcoming = "upcoming",
}

/** Autogenerated input type of BlockUser */
export type BlockUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The source of the report in the Whop UI */
  source: UserReportSources;
  /** The ID of the user to block */
  userId: Scalars["ID"]["input"];
};

/** A calendar booking */
export type Booking = {
  __typename?: "Booking";
  /** The availability of the booking */
  availability: Availability;
  /** When the booking was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the booking */
  id: Scalars["ID"]["output"];
  /** Until what time the booking is reserved for. null if successfully booked. */
  reservedUntil?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** An experience activity card about a calendar booking */
export type BookingCard = ExperienceActivityCardInterface & {
  __typename?: "BookingCard";
  /** The booking that this card is about */
  booking?: Maybe<Booking>;
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** An object representing a bounty */
export type Bounty = {
  __typename?: "Bounty";
  /** When the bounty was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the bounty */
  description: Scalars["String"]["output"];
  /** The internal ID of the bounty */
  id: Scalars["ID"]["output"];
  /** The title of the bounty */
  title: Scalars["String"]["output"];
  /** The total amount available for the bounty */
  totalAvailable: Scalars["Float"]["output"];
};

/** An experience activity card about a bounty */
export type BountyCard = ExperienceActivityCardInterface & {
  __typename?: "BountyCard";
  /** The bounty that this card is about */
  bounty?: Maybe<PublicBounty>;
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The connection type for Bounty. */
export type BountyConnection = {
  __typename?: "BountyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BountyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Bounty>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BountyEdge = {
  __typename?: "BountyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Bounty>;
};

/** Values to filter bounties on */
export type BountyFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** Ability to filter bounties by access passes in specific marketplace categories. */
  marketplaceCategoryRoutes?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Whether to only include bounties that are not whop bounties. */
  nonWhopOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** What to order the results by. */
  order?: InputMaybe<PublicBountiesOrder>;
};

/** An experience activity card about a bounty submission */
export type BountySubmissionCard = ExperienceActivityCardInterface & {
  __typename?: "BountySubmissionCard";
  /** The bounty submission that this card is about */
  bountySubmission?: Maybe<PublicBountySubmission>;
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** An object representing a bulk task */
export type BulkTask = {
  __typename?: "BulkTask";
  /** When the bulk task was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The internal ID of the bulk task */
  id: Scalars["ID"]["output"];
  /** The logs of the bulk task */
  logs: Array<Log>;
  /** The name of the bulk task */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The status of the bulk task */
  status: BulkTaskStatusTypes;
  /** When the bulk task was updated. Likely when it was complete if the status is executed. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for BulkTask. */
export type BulkTaskConnection = {
  __typename?: "BulkTaskConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BulkTaskEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BulkTask>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BulkTaskEdge = {
  __typename?: "BulkTaskEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BulkTask>;
};

/** The status of the bulk task */
export enum BulkTaskStatusTypes {
  /** Approved */
  Approved = "approved",
  /** Canceled */
  Canceled = "canceled",
  /** Executed */
  Executed = "executed",
  /** Failed */
  Failed = "failed",
  /** Pending */
  Pending = "pending",
  /** Processing */
  Processing = "processing",
  /** Rejected */
  Rejected = "rejected",
}

/** The badge and the number of times it has been given to a user on their public profile */
export type BulletinBoardBadgeCount = {
  __typename?: "BulletinBoardBadgeCount";
  /** How many times this badge has been given */
  count: Scalars["Int"]["output"];
  /** The name of the badge */
  name: Scalars["String"]["output"];
};

/** Represents a referral that a user made for a company to join the platform. */
export type BusinessAffiliate = {
  __typename?: "BusinessAffiliate";
  /** Whether or not the referral is complete (still earning money of this). */
  completed: Scalars["Boolean"]["output"];
  /** When the referral was made. Ex. When the company was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** How much the user has earned from the referral */
  formattedEarnings: Scalars["String"]["output"];
  /** The ID (tag) of the company. */
  id: Scalars["ID"]["output"];
  /**
   * The company's logo.
   * @deprecated Use imageSrcset instead.
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The company's logo. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** When the user who referred the company stops getting money from the referral. */
  referralExpiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The title of the company. */
  title: Scalars["String"]["output"];
};

/** Represents a referral that a user made for a company to join the platform. */
export type BusinessAffiliateImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<BusinessAffiliateImageStyles>;
};

/** The connection type for BusinessAffiliate. */
export type BusinessAffiliateConnection = {
  __typename?: "BusinessAffiliateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BusinessAffiliateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<BusinessAffiliate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type BusinessAffiliateEdge = {
  __typename?: "BusinessAffiliateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<BusinessAffiliate>;
};

/** Image styles for business_affiliate. */
export enum BusinessAffiliateImageStyles {
  S16 = "s16",
  S20 = "s20",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S64 = "s64",
  S80 = "s80",
  S128 = "s128",
  S180 = "s180",
  S600x200 = "s600x200",
  S800x200 = "s800x200",
  S900x300 = "s900x300",
  S1200x630 = "s1200x630",
  S1600x400 = "s1600x400",
}

/** The status of this user and if they can be a business affiliate */
export enum BusinessAffiliateStatuses {
  /** Accepted */
  Accepted = "accepted",
  /** Not Business Affiliate */
  NotBusinessAffiliate = "not_business_affiliate",
  /** Rejected */
  Rejected = "rejected",
  /** Submitted */
  Submitted = "submitted",
}

/** The names of places where the user should be re-directed when clicking the buy box button. */
export enum BuyButtonLocations {
  Checkout = "checkout",
  HubEntries = "hub_entries",
}

/** The modes for the buyer fee. */
export enum BuyerFeeMode {
  UseAccountFee = "use_account_fee",
  UseExperimentFee = "use_experiment_fee",
}

/** Autogenerated input type of CalculateTax */
export type CalculateTaxInput = {
  /** The ID of the access pass being purchased. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The address to use for the guest tax calculation, if any. */
  address?: InputMaybe<AddressInput>;
  /** The amount to calculate the quote for. */
  amount: Scalars["Float"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company buyer to calculate tax for. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The currency of the purchase. */
  currency: Currencies;
  /** The IP address of the customer purchasing. */
  ipAddress?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account to calculate tax for. */
  ledgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the line item being purchased. */
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the mailing address object to calculate tax for. */
  mailingAddressId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The payment processor to use for the transaction. */
  paymentProcessor?: InputMaybe<PaymentProcessor>;
  /** The ID of the plan to calculate tax for. */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An EU VAT ID to use for the tax calculation. */
  vatId?: InputMaybe<Scalars["String"]["input"]>;
};

/** A content reward campaign object */
export type Campaign = {
  __typename?: "Campaign";
  /** Whether to allow Instagram submissions */
  allowInstagram: Scalars["Boolean"]["output"];
  /** Whether to allow TikTok submissions */
  allowTiktok: Scalars["Boolean"]["output"];
  /** Whether to allow X submissions */
  allowX: Scalars["Boolean"]["output"];
  /** Whether to allow YouTube submissions */
  allowYoutube: Scalars["Boolean"]["output"];
  /** Number of approved submissions this campaign has */
  approvedSubmissionsCount: Scalars["Int"]["output"];
  /** The assets associated with the campaign */
  assets: AssetConnection;
  /** The attachments for this campaign */
  attachments: Array<AttachmentInterface>;
  /** The number of hours after which submissions get auto-approved */
  autoApproveSubmissionsInHours?: Maybe<Scalars["Int"]["output"]>;
  /** Which category to assign */
  category: ContentRewardsCategory;
  /** Which content type is accepted */
  contentType: ContentRewardsContentType;
  /** When this campaign was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Which currency should be used for payments */
  currency: Currencies;
  /** The experience this content reward is associated with */
  experience?: Maybe<PublicExperience>;
  /** When this campaign ends */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The file attachments for the campaign */
  fileAttachments: FileAttachmentConnection;
  /** Whether submissions to this campaign require file uploads */
  fileUploadRequired: Scalars["Boolean"]["output"];
  /** The fixed amount that will be paid out per approved submission */
  fixedRewardPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** Number of flagged submissions this campaign has */
  flaggedSubmissionsCount: Scalars["Int"]["output"];
  /** ID of the campaign */
  id: Scalars["ID"]["output"];
  /** The pool ledger account associated with the campaign. */
  ledgerAccount?: Maybe<LedgerAccount>;
  /** The maximum amount that can be paid out per submission */
  maxPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** The minimum amount owed before a submission is eligible for payouts */
  minPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** Number of pending submissions this campaign has */
  pendingSubmissionsCount: Scalars["Int"]["output"];
  /** Number of rejected submissions this campaign has */
  rejectedSubmissionsCount: Scalars["Int"]["output"];
  /** URL that must be present in the submitter's social account bio */
  requiredCreatorBioLink?: Maybe<Scalars["String"]["output"]>;
  /** Text patterns that must be present in the submitted post description */
  requiredDescriptionText?: Maybe<Array<Scalars["String"]["output"]>>;
  /** Instagram audio that must be used in the submissions */
  requiredInstagramAudio?: Maybe<Scalars["String"]["output"]>;
  /** TikTok audio that must be used in the submissions */
  requiredTiktokAudio?: Maybe<Scalars["String"]["output"]>;
  /** An array of requirements that the user must complete to collect a reward */
  requirements: Array<Scalars["String"]["output"]>;
  /** The amount that a user should be rewarded per thousand views submitted */
  rewardRatePerThousandViews: Scalars["Float"]["output"];
  /** The status of the campaign */
  status: ContentRewardsCampaignStatus;
  /** Number of submissions this campaign has */
  submissionsCount: Scalars["Int"]["output"];
  /** The title of this campaign */
  title: Scalars["String"]["output"];
  /** The total amount that will be paid out for this campaign */
  totalBudget: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign in the campaign's currency. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign, normalized to USD. */
  totalPaidInUsd: Scalars["Float"]["output"];
  /** Total number of views approved submissions generated for this campaign */
  totalViewCount: Scalars["Int"]["output"];
};

/** A content reward campaign object */
export type CampaignAssetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A content reward campaign object */
export type CampaignFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Campaign. */
export type CampaignConnection = {
  __typename?: "CampaignConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CampaignEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Campaign>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CampaignEdge = {
  __typename?: "CampaignEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Campaign>;
};

/** The different ways to order content rewards campaigns */
export enum CampaignOrder {
  /** Highest available budget */
  HighestAvailableBudget = "highest_available_budget",
  /** Newest */
  Newest = "newest",
  /** Reward rate per thousand views */
  RewardRatePerThousandViews = "reward_rate_per_thousand_views",
  /** Total Paid out */
  TotalPaidOut = "total_paid_out",
}

/** Autogenerated input type of CancelAbuseReport */
export type CancelAbuseReportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the report */
  id: Scalars["ID"]["input"];
};

/** The different reasons a user can choose for why they are canceling their membership. */
export enum CancelOptions {
  BadExperience = "bad_experience",
  MissingFeatures = "missing_features",
  Other = "other",
  Switching = "switching",
  TechnicalIssues = "technical_issues",
  Testing = "testing",
  TooExpensive = "too_expensive",
}

/** Represents the discount details of applying a promo code to an existing membership. */
export type CancelationDiscount = {
  __typename?: "CancelationDiscount";
  /** The promo code that the user will be eligible to use if they try to cancel. */
  cancelationPromoCode?: Maybe<PublicPromoCode>;
  /** The new renewal price the customer will pay after applying the promo code. */
  formattedNewRenewalPrice: Scalars["String"]["output"];
  /** The current renewal price of the membership. */
  formattedRenewalPrice: Scalars["String"]["output"];
};

/** Possible card brands that a payment token can have */
export enum CardBrands {
  /** Amex */
  Amex = "amex",
  /** Diners */
  Diners = "diners",
  /** Discover */
  Discover = "discover",
  /** Jcb */
  Jcb = "jcb",
  /** Mastercard */
  Mastercard = "mastercard",
  /** Unionpay */
  Unionpay = "unionpay",
  /** Visa */
  Visa = "visa",
}

/** The over-arching state of the resolution. */
export enum CaseStates {
  Closed = "closed",
  Open = "open",
}

/** Autogenerated input type of ChangeAccessPassStatus */
export type ChangeAccessPassStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the access pass to update. */
  id: Scalars["ID"]["input"];
  /** The new status of the page. */
  status: MarketplaceStatuses;
};

/** Autogenerated input type of ChangeCardMyMembership */
export type ChangeCardMyMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the membership to cancel at the end of the period. */
  membershipId: Scalars["ID"]["input"];
  /** The URL you want to take the user to when they return */
  redirectUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of ChangeEmail */
export type ChangeEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The email a user wishes to change to. */
  email: Scalars["String"]["input"];
};

/** An object representing a charge for a receipt. */
export type Charge = {
  __typename?: "Charge";
  /** The calculated statement descriptor for the charge. */
  calculatedStatementDescriptor?: Maybe<Scalars["String"]["output"]>;
  /** The funding method for the charge. */
  cardFunding?: Maybe<ChargeCardFunding>;
  /** The card issuer for the charge. */
  cardIssuer?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the charge. */
  id: Scalars["ID"]["output"];
  /** The risk level from Stripe for the charge. */
  outcomeRiskLevel?: Maybe<ChargeOutcomeRiskLevels>;
  /** The risk score from Stripe for the charge. */
  outcomeRiskScore?: Maybe<Scalars["Int"]["output"]>;
  /** The seller message from Stripe for the charge. */
  outcomeSellerMessage?: Maybe<Scalars["String"]["output"]>;
  /** The statement descriptor for the charge. */
  statementDescriptor?: Maybe<Scalars["String"]["output"]>;
};

/** The different card funding methods a charge can have. */
export enum ChargeCardFunding {
  /** Credit */
  Credit = "credit",
  /** Debit */
  Debit = "debit",
  /** Prepaid */
  Prepaid = "prepaid",
  /** Unknown */
  Unknown = "unknown",
}

/** The different risk levels a charge can have. */
export enum ChargeOutcomeRiskLevels {
  /** Elevated */
  Elevated = "elevated",
  /** Highest */
  Highest = "highest",
  /** Normal */
  Normal = "normal",
  /** Not Assessed */
  NotAssessed = "not_assessed",
  /** Unknown */
  Unknown = "unknown",
}

/** Chart interval (period). */
export enum ChartIntervals {
  Daily = "daily",
  Hourly = "hourly",
  Monthly = "monthly",
  Weekly = "weekly",
  Yearly = "yearly",
}

/** Data points with max and min values for a chart. */
export type ChartsDataNumber = {
  __typename?: "ChartsDataNumber";
  /** Data points. */
  data: Array<ChartsDataPointNumber>;
  /** Max value. */
  max: Scalars["Number"]["output"];
  /** Min value. */
  min: Scalars["Number"]["output"];
  /** Sum of all values. */
  sum: Scalars["Number"]["output"];
};

/** Data points with max and min values for a chart. */
export type ChartsDataNumberNoSum = {
  __typename?: "ChartsDataNumberNoSum";
  /** Data points. */
  data: Array<ChartsDataPointNumber>;
  /** Last value. */
  last: Scalars["Number"]["output"];
  /** Max value. */
  max: Scalars["Number"]["output"];
  /** Min value. */
  min: Scalars["Number"]["output"];
};

/** The data point for charts. */
export type ChartsDataPointNumber = {
  __typename?: "ChartsDataPointNumber";
  /** This is the first second of the data point. */
  t: Scalars["Timestamp"]["output"];
  /** Value. */
  v?: Maybe<Scalars["Number"]["output"]>;
};

/** Represents a Chat feed */
export type ChatFeed = BaseEntityInterface & {
  __typename?: "ChatFeed";
  /** Whether or not media is banned in this chat */
  banMedia: Scalars["Boolean"]["output"];
  /** Whether or not URLs are banned in this chat */
  banUrls: Scalars["Boolean"]["output"];
  /** List of banned words in this chat */
  bannedWords: Array<Scalars["String"]["output"]>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The type of the card */
  entityType: EntityTypes;
  /** The experience for this chat */
  experienceId?: Maybe<Scalars["ID"]["output"]>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The number of seconds a user needs to wait before posting again, if any */
  userPostsCooldownSeconds?: Maybe<Scalars["Int"]["output"]>;
  /** Users in this chat */
  users: PublicProfileUserConnection;
  /** The webhooks for the feed */
  webhooks: FeedWebhookConnection;
  /** Who can post on this chat */
  whoCanPost: WhoCanPostTypes;
  /** Who can react on this chat */
  whoCanReact: WhoCanReactTypes;
};

/** Represents a Chat feed */
export type ChatFeedUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** Represents a Chat feed */
export type ChatFeedWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Input for a chat feed */
export type ChatFeedInput = {
  /** Whether or not media is banned in this chat */
  banMedia?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not URLs are banned in this chat */
  banUrls?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** List of banned words in this chat */
  bannedWords?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The unique identifier for the feed */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The number of seconds a user needs to wait before posting again, if any */
  userPostsCooldownSeconds?: InputMaybe<Scalars["Int"]["input"]>;
  /** Who can post on this chat */
  whoCanPost?: InputMaybe<WhoCanPostTypes>;
  /** Who can react on this chat */
  whoCanReact?: InputMaybe<WhoCanReactTypes>;
};

/** Autogenerated input type of CheckAuthenticatorCode */
export type CheckAuthenticatorCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The one time passcode generated from the authenticator app. */
  otp: Scalars["String"]["input"];
};

/** An object representing the details needed to render a checkout before a plan or line item is made. */
export type CheckoutConfiguration = {
  __typename?: "CheckoutConfiguration";
  /** An array of the accepted payment methods for the line item. */
  acceptedPaymentMethods: Array<AcceptedPaymentMethods>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity: Scalars["Boolean"]["output"];
  /** Whether or not the line item requires a billing setup. */
  billingSetupRequired: Scalars["Boolean"]["output"];
  /** Whether or not the line item collects tax. */
  collectTax: Scalars["Boolean"]["output"];
  /** The description of the line item. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The fee cost structure to display to the user. */
  feeCostStructures?: Maybe<Array<FeeCostStructure>>;
  /** The ledger account for the line item. */
  ledgerAccount?: Maybe<PublicLedgerAccount>;
  /** Whether or not the company is the merchant of record. Uses the line item's current stripe account. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** Used for the Stripe Payment element. If present, pass this value as the on_behalf_of parameter. */
  onBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Payment Request Button. If present, pass this value as the on_behalf_of parameter. */
  paymentRequestOnBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** The capabilities of the stripe account. */
  paymentsCapabilities: Array<Scalars["String"]["output"]>;
  /** The setup future usage for the line item, if applicable. */
  setupFutureUsage?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the promo code input should be shown on checkout. */
  showPromoCodeInput: Scalars["Boolean"]["output"];
  /** The countries to skip tax quoting for. */
  skipTaxQuotingCountries: Array<Scalars["String"]["output"]>;
  /** The stripe account id to use for setting up this line item's stripe.js */
  stripeAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe payment method configuration id to use for setting up the stripe.js elements */
  stripePaymentMethodConfigurationId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe public key to use for setting up this line item's stripe.js */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the line item. */
  taxType: TaxTypes;
  /** The terms and conditions for the line item. */
  termsAndConditions: Scalars["String"]["output"];
  /** Whether or not to use the Basis Theory element during checkout. */
  useBasisTheory: Scalars["Boolean"]["output"];
};

/** An object representing a requirement that needs to be fulfilled on checkout */
export type CheckoutRequirement = {
  __typename?: "CheckoutRequirement";
  /** Whether the requirement has been fulfilled. If true, no action is needed. If false, it's unsatisfied (but could be fulfilled by further user action) */
  criteriaMet: Scalars["Boolean"]["output"];
  /** Any additional data that may be needed for the requirement */
  data?: Maybe<Scalars["JSON"]["output"]>;
  /** The identifier of the requirement */
  identifier: RequirementIdentifiers;
};

/** The ways a checkout can be processed */
export enum CheckoutServiceTypes {
  Iframe = "iframe",
  Redirect = "redirect",
}

/** A checkout session */
export type CheckoutSession = {
  __typename?: "CheckoutSession";
  /** The affiliate code to use for the checkout session */
  affiliateCode: Scalars["String"]["output"];
  /** The ID of the company to use for the checkout session */
  companyId: Scalars["ID"]["output"];
  /** The ID of the checkout session */
  id: Scalars["ID"]["output"];
  /** The metadata to use for the checkout session */
  metadata: Scalars["JSON"]["output"];
  /** The ID of the plan to use for the checkout session */
  planId: Scalars["ID"]["output"];
  /** The URL to redirect the user to after the checkout session is created */
  purchaseUrl: Scalars["String"]["output"];
  /** The URL to redirect the user to after the checkout session is created */
  redirectUrl: Scalars["String"]["output"];
};

/** The type of checkout session being made */
export enum CheckoutSessionTypes {
  InAppPurchase = "in_app_purchase",
  Purchase = "purchase",
}

/** The source where the checkout was initiated */
export enum CheckoutSource {
  /** The Swift iOS app */
  Swift = "swift",
  /** The Whop web app */
  Web = "web",
}

/** Autogenerated input type of CloneAccessPass */
export type CloneAccessPassInput = {
  /** The base AccessPass ID to clone */
  baseAccessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Information about a Coinbase Commerce payment account */
export type CoinbaseAccount = {
  __typename?: "CoinbaseAccount";
  /** The last 5 characters of the Coinbase API key */
  apiKeyLast5: Scalars["String"]["output"];
  /** Whether or not the account can be deleted to restart the setup process */
  canDelete: Scalars["Boolean"]["output"];
  /** Whether or not the Coinbase account is the default account for the company */
  defaultAccount: Scalars["Boolean"]["output"];
  /** The ID of the Coinbase account */
  id: Scalars["ID"]["output"];
  /** The status of the Coinbase account */
  status: CoinbaseCommerceStatuses;
  /** The last 5 characters of the Coinbase webhook secret */
  webhookSecretLast5: Scalars["String"]["output"];
  /** Whether or not the Coinbase webhook has been verified */
  webhookVerified: Scalars["Boolean"]["output"];
};

/** The connection type for CoinbaseAccount. */
export type CoinbaseAccountConnection = {
  __typename?: "CoinbaseAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CoinbaseAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CoinbaseAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CoinbaseAccountEdge = {
  __typename?: "CoinbaseAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CoinbaseAccount>;
};

/** The state of the Coinbase Commerce connection. */
export enum CoinbaseCommerceStatuses {
  /** The Coinbase commerce connection is broken and needs to be fixed with a new API key. */
  Broken = "broken",
  /** The Coinbase Commerce account is missing a settlement address. This needs to be set from the coinbase dashboard. */
  MissingSettlementAddress = "missing_settlement_address",
  /** The Coinbase commerce connection is setup and ready to be used. */
  Setup = "setup",
  /** The webhook connection has not been tested / verified. */
  WebhookNotVerified = "webhook_not_verified",
}

/** Any additional data required for processing a Coinbase checkout. */
export type CoinbaseData = {
  __typename?: "CoinbaseData";
  /** The URL of the coinbase hosted checkout page to navigate the user to. */
  url?: Maybe<Scalars["String"]["output"]>;
};

/** The ways a relation of Companies can be ordered */
export enum CompaniesOrder {
  CreatedAt = "created_at",
  Id = "id",
  TotalMembershipsEarnings = "total_memberships_earnings",
}

/** A company using the Whop dashboard */
export type Company = {
  __typename?: "Company";
  /** Get a specific access pass from a company */
  accessPass: AccessPass;
  /**
   * All of the access passes connected to the company.
   * @deprecated use access_passes_v2
   */
  accessPasses: AccessPassConnection;
  /** All of the access passes connected to the company. */
  accessPassesV2: AccessPassConnection;
  /** The account manager public profile for the company */
  accountManager?: Maybe<PublicProfileUser>;
  /** The number of active disputes the company has. */
  activeDisputesCount: Scalars["Int"]["output"];
  /** Get a specific affiliate from a company */
  affiliate: Affiliate;
  /** The affiliate referral logs for the company. */
  affiliateReferralLogs: AffiliateReferralLogConnection;
  /** An overview of the company's affiliate usage stats */
  affiliateStats: AffiliateStats;
  /**
   * The API keys for the company.
   * Roles: owner
   */
  apiKeysV2?: Maybe<ApiKeyV2Connection>;
  /** The app for the company */
  app: App;
  /** The app for the company */
  apps: AppConnection;
  /**
   * The audit logs for the company..
   * Roles: owner, admin
   */
  auditLogs: VersionConnection;
  /** The current user's authorized user */
  authorizedUser?: Maybe<AuthorizedUser>;
  /**
   * All of a company's added team members..
   * Roles: admin, owner
   */
  authorizedUsers: Array<AuthorizedUser>;
  /** The minimum USD amount in which we'll auto refund dispute warnings */
  autoRefundThreshold: Scalars["Int"]["output"];
  /** Whether or not this company's auto refund threshold is locked */
  autoRefundThresholdLocked: Scalars["Boolean"]["output"];
  /** The app store */
  availableAppAccessPasses: PublicAccessPassConnection;
  /** The payout methods that the company has successfully set up */
  availablePayoutMethods: Array<PayoutMethods>;
  /** The aggregate percentage of churn rate in the past month. */
  churnRate?: Maybe<Scalars["Float"]["output"]>;
  /**
   * The coinbase account for the company.
   * Roles: owner
   */
  coinbaseAccount: CoinbaseAccount;
  /**
   * The coinbase accounts that have been set by a company.
   * Roles: owner
   */
  coinbaseAccounts: CoinbaseAccountConnection;
  /** All the passes they are authorized to collab with. Other company's passes they have access to */
  collabsPasses: PublicAccessPassConnection;
  /** The company member for the current user */
  companyMember: CompanyMember;
  /** The user who owns this company */
  companyOwner: PublicProfileUser;
  /** A public profile for the company to be displayed on invoices and to their customers. */
  companyProfile?: Maybe<CompanyProfile>;
  /**
   * The type of company
   * @deprecated No longer used
   */
  companyType?: Maybe<CompanyTypes>;
  /** Retrieve a specific content rewards campaign */
  contentRewardsCampaign: Campaign;
  /** The content rewards campaigns for this company */
  contentRewardsCampaigns: CampaignConnection;
  /** Retrieve charts for a content rewards experience or campaign */
  contentRewardsCharts: ContentRewardsTotalViewsChartType;
  /** Distinct list of currencies for content rewards campaigns */
  contentRewardsCurrencies: Array<Currencies>;
  /** Retrieve statistics about a content rewards experience or campaign */
  contentRewardsStats: ContentRewardsStatsType;
  /** Retrieve a specific content reward for this company */
  contentRewardsSubmission: Submission;
  /** The content rewards submissions for this company */
  contentRewardsSubmissions: SubmissionConnection;
  /** The country the company is located in. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** When the company was created (signed up) */
  createdAt: Scalars["Timestamp"]["output"];
  /**
   * The charts for the creator dashboard..
   * Roles: owner
   */
  creatorDashboardCharts: CreatorDashboardCharts;
  /** The recent searches the current user has made for the creator dashboard. */
  creatorDashboardRecentSearches: RecentSearchConnection;
  /** Search for the creator dashboard. */
  creatorDashboardSearch: CreatorDashboardSearch;
  /** The creator dashboard table for the company */
  creatorDashboardTable: CreatorDashboardTable;
  /** Get a specific creator milestone from a company */
  creatorMilestone?: Maybe<CreatorMilestone>;
  /** All of company's achieved milestones */
  creatorMilestones: CreatorMilestoneConnection;
  /** The currencies the company accepts. */
  currencies?: Maybe<Array<Maybe<Currencies>>>;
  /**
   * The current sales for the company, normalized to USD.
   * Roles: owner
   */
  currentSales: Scalars["Int"]["output"];
  /** The default currency for the company. Ex. the currency with the most memberships. */
  defaultCurrency?: Maybe<Currencies>;
  /**
   * A written description of the company.
   * @deprecated No longer implemented
   */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Get a specific dispute from a company */
  dispute: Dispute;
  /** The total dispute rate for the company */
  disputeRateTotal: Scalars["Float"]["output"];
  /** The number of disputes needing attention */
  disputesNeedingAttentionCount: Scalars["Int"]["output"];
  /** All of the experiences connected to the company. */
  draftedExperiences: PublicExperienceConnection;
  /** The company's EULA. */
  eula?: Maybe<AttachmentInterface>;
  /**
   * The EULA PDF for the company.
   * @deprecated Use eula instead
   */
  eulaPdf?: Maybe<Scalars["File"]["output"]>;
  /** Get a specific experience from a company */
  experience: ExperienceInterface;
  /** A list of experience IDs connected to a given product */
  experienceIdsForProduct: Array<Scalars["ID"]["output"]>;
  /**
   * All of the experiences connected to the company.
   * @deprecated Use experiences v2 instead
   */
  experiences: ExperienceInterfaceConnection;
  /** All of the experiences connected to the company. */
  experiencesV2: ExperienceInterfaceConnection;
  /** An array of features this company has access to */
  features: Array<Scalars["String"]["output"]>;
  /** Whether a company has any type of fiat payment form setup. This means they could have any supported stripe integration setup */
  fiatPaymentsSetup?: Maybe<Scalars["Boolean"]["output"]>;
  /** A Google Analytics ID that the company can use to track page views for their company. */
  googleAnalyticsId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The google tag manager ID. */
  gtmId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** Whether or not the automated messages trigger is enabled for this company */
  hasAutomatedMessagesTriggerEnabled: Scalars["Boolean"]["output"];
  /** Whether or not the member transcription is enabled for this company */
  hasMember: Scalars["Boolean"]["output"];
  /** Whether or not the popup promo is enabled for this company */
  hasPopupPromoEnabled: Scalars["Boolean"]["output"];
  /** Whether or not the company has any unclaimed memberships. */
  hasUnclaimedMemberships: Scalars["Boolean"]["output"];
  /**
   * The header image for the company.
   * @deprecated Use headerImageSrcset instead
   */
  headerImage?: Maybe<Scalars["File"]["output"]>;
  /** The company's banner image (displayed on their product page and cards). */
  headerImageSrcset?: Maybe<ImgSrcset>;
  /** The slug/route of the company's hub page. */
  hubRoute?: Maybe<Scalars["String"]["output"]>;
  /** The Hyros API key */
  hyrosApiKey?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The Hyros pixel ID. */
  hyrosPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The ID of the company */
  id: Scalars["ID"]["output"];
  /**
   * The image for the company.
   * @deprecated Use imageSrcset instead
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The company's logo. */
  imageSrcset?: Maybe<ImgSrcset>;
  /**
   * The marketplace/branding images for the company.
   * @deprecated not used anymore
   */
  images: Array<Image>;
  /**
   * The Instagram username for the company (NOT IN USE).
   * @deprecated Use social links instead
   */
  instagram?: Maybe<Scalars["String"]["output"]>;
  /** Given the supplied string, returns whether or not the feature is enabled */
  isFeatureEnabled: Scalars["Boolean"]["output"];
  /** The company's item ordering. */
  itemOrdering: ItemOrdering;
  /** A boolean representing whether or not a company has fully launched. */
  launched: Scalars["Boolean"]["output"];
  /**
   * The ledger account for the company.
   * Roles: owner
   */
  ledgerAccount: LedgerAccount;
  /** The marketplace fee for the company. */
  marketplaceFee: Scalars["Int"]["output"];
  /** Get a specific member from a company */
  member: Member;
  /** Returns members count */
  membersCount: Scalars["Int"]["output"];
  /** The number of members who have downloaded the Whop consumer app. */
  membersWithApp: Scalars["Int"]["output"];
  /** Get a specific membership from a company */
  membership: Membership;
  /** The meta pixel ID. */
  metaPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /**
   * The oauth applications for the company.
   * Roles: owner
   */
  oauthApplication: OauthApplicationView;
  /**
   * The URL of an image to use for the company's preview display.
   * @deprecated Use ogImageSrcset instead
   */
  ogImage?: Maybe<Scalars["String"]["output"]>;
  /** The URL of an image to use for the company's preview display. */
  ogImageSrcset?: Maybe<ImgSrcset>;
  /** Whether the company is participating in custom creator milestones. */
  participatingInCustomCreatorMilestones: Scalars["Boolean"]["output"];
  /** Whether or not the company considers past_due memberships as valid. */
  pastDueIsValid: Scalars["Boolean"]["output"];
  /**
   * The number of payments the company has made today.
   * @deprecated No longer in use.
   */
  pastDuePayments?: Maybe<Scalars["Int"]["output"]>;
  /** The status of the payments banner */
  paymentsApprovalStatus?: Maybe<PaymentsApprovalStatuses>;
  /** Whether a company has any type of payment form setup. This means they could have any supported stripe integration setup */
  paymentsSetup?: Maybe<Scalars["Boolean"]["output"]>;
  /** The payout methods that the company needs to setup b/c they have plans that require it */
  payoutSetupNeeded: Array<PayoutMethods>;
  /** The company's paypal accounts */
  paypalAccounts: PaypalAccountConnection;
  /** The number of pending waitlist entries */
  pendingWaitlistEntriesCount: Scalars["Int"]["output"];
  /** The pinterest pixel ID. */
  pinterestPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** Get a specific plan from a company */
  plan: Plan;
  /** All of the plans connected to the company. */
  plans: PlanConnection;
  /** The company's privacy policy. */
  privacyPolicy?: Maybe<AttachmentInterface>;
  /**
   * The privacy policy PDF for the company.
   * @deprecated Use privacyPolicy instead
   */
  privacyPolicyPdf?: Maybe<Scalars["File"]["output"]>;
  /** The processing fee for the company. */
  processingFee: Scalars["Float"]["output"];
  /** A list of product IDs connected to a given experience */
  productIdsForExperience: Array<Scalars["ID"]["output"]>;
  /** Get a specific promo code from a company */
  promoCode: PromoCode;
  /** The number of promo codes used today */
  promoCodeUsesTodayCount: Scalars["Int"]["output"];
  /** All of a company's promo codes, with searching capabilities. */
  promoCodes: PromoCodeConnection;
  /** All of the experiences connected to the company. */
  publicExperiences: PublicExperienceConnection;
  /**
   * All the memberships a company has purchased and owns. This is due to purchasing apps
   * @deprecated Don't use this anymore.
   */
  purchasedMembership: Membership;
  /** All the memberships a company has purchased and owns. This is due to purchasing apps */
  purchasedMembershipV2: PublicMembership;
  /** Get a specific receipt that the company has purchased */
  purchasedReceipt: PublicReceipt;
  /** Get a specific receipt from a company */
  receipt: Receipt;
  /**
   * All of a company's payments, with searching capabilities..
   * Roles: owner, admin
   */
  receiptsV2?: Maybe<ReceiptConnection>;
  /** The reddit pixel ID. */
  redditPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** A URL where users will be redirected to after purchasing a pass. */
  redirectPurchaseUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** Username of the guy who referred */
  referredByUsername?: Maybe<Scalars["String"]["output"]>;
  /** A VAT or Tax ID for the company. */
  registeredCompanyNumber?: Maybe<Scalars["String"]["output"]>;
  /** Whether the company requires 2FA for its authorized users */
  require2fa: Scalars["Boolean"]["output"];
  /** Whether or not the company requires users to verify their phone on checkout. */
  requirePhoneVerification?: Maybe<Scalars["Boolean"]["output"]>;
  /** Whether or not the company requires users to agree to the tos on checkout. */
  requireTermsAgreement: Scalars["Boolean"]["output"];
  /** Whether or not the company shows the VAT ID input box on checkout. */
  requireVatId: Scalars["Boolean"]["output"];
  /** A specific resolution case for the company */
  resolution: PublicResolution;
  /** All of a company's resolution cases. */
  resolutions: PublicResolutionConnection;
  /** The number of resolutions needing attention */
  resolutionsNeedingAttentionCount: Scalars["Int"]["output"];
  /** The company's return policy. */
  returnPolicy?: Maybe<AttachmentInterface>;
  /**
   * The return policy PDF for the company.
   * @deprecated Use returnPolicy instead
   */
  returnPolicyPdf?: Maybe<Scalars["File"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewCounts: Array<Scalars["Int"]["output"]>;
  /** Load the reviews on a company */
  reviews: ReviewConnection;
  /** The average review rating for this company */
  reviewsAverage?: Maybe<Scalars["Float"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewsBreakdown?: Maybe<Scalars["JSON"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewsBreakdownV2?: Maybe<Array<Scalars["Int"]["output"]>>;
  /**
   * The slug/route of the company on the Whop site.
   * @deprecated Use store_route
   */
  route: Scalars["String"]["output"];
  /** Whether or not the company wants to send emails to their members. */
  sendEmails: Scalars["Boolean"]["output"];
  /** Whether or not the company will get an outh code after checkout. */
  sendOauthCode: Scalars["Boolean"]["output"];
  /** Whether or not the company allows Whop to send its members promotional emails. */
  sendPromoEmails: Scalars["Boolean"]["output"];
  /**
   * A shortened version of the company's description.
   * @deprecated No longer implemented
   */
  shortenedDescription?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not this company will get dispute alerts and auto refunds */
  showAutoRefundSettings: Scalars["Boolean"]["output"];
  /** Whether or not the company wants to have their company show in the joined_whops section on other accounts. */
  showJoinedWhops: Scalars["Boolean"]["output"];
  /** Whether or not the company wants to show reviews via direct to consumer links on their product page. */
  showReviewsDtc: Scalars["Boolean"]["output"];
  /** Whether or not the company wants to show their users in the user directory. */
  showUserDirectory: Scalars["Boolean"]["output"];
  /** The socials for the company */
  socials: Array<Social>;
  /** A specific stripe account under the company */
  stripeAccount: StripeAccount;
  /** The stripe accounts, if any, connected to the company */
  stripeAccounts: Array<StripeAccount>;
  /**
   * Whether or not the company has activated team preview
   * @deprecated No longer applies.
   */
  teamPreviewActivated: Scalars["Boolean"]["output"];
  /** The telegram channels for a company */
  telegramChannels: TelegramChannelConnection;
  /** The company's terms of service. */
  termsOfService?: Maybe<AttachmentInterface>;
  /** The tiktok pixel ID. */
  tiktokPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The written name of the company. */
  title: Scalars["String"]["output"];
  /**
   * The terms of service PDF for the company.
   * @deprecated Use termsOfService instead
   */
  tosPdf?: Maybe<Scalars["File"]["output"]>;
  /** The total amount of referral earnings the company has made. */
  totalReferralEarnings?: Maybe<Scalars["String"]["output"]>;
  /** The total number of referrals the company has made. */
  totalReferrals?: Maybe<Scalars["Int"]["output"]>;
  /** Tracking pixels for this company */
  trackingPixels: TrackingPixelConnection;
  /** The Twitter pixel ID. */
  twitterPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The number of upcoming cancelations for the company. */
  upcomingCancelations: Scalars["Int"]["output"];
  /** Whop verified status of the company */
  verifiedStatus?: Maybe<VerifiedStatuses>;
  /**
   * Whether or not the company is visible on the whop.com marketplace.
   * @deprecated No longer applies.
   */
  visible: Scalars["Boolean"]["output"];
  /** The number of visitors to the company's purchase page today. */
  visitorsToday?: Maybe<Scalars["Int"]["output"]>;
  /** The webhook that has been set by a company */
  webhook: Webhook;
  /**
   * The webhooks that have been set by a company.
   * Roles: owner
   */
  webhooks: Array<Webhook>;
  /**
   * Whether or not the company has activated Whop 4
   * @deprecated No longer applies.
   */
  whopFourActivated: Scalars["Boolean"]["output"];
};

/** A company using the Whop dashboard */
export type CompanyAccessPassArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyAccessPassesArgs = {
  accessPassTypes?: InputMaybe<Array<AccessPassTypes>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  excludeNftPasses?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  visibility?: InputMaybe<VisibilityFilter>;
};

/** A company using the Whop dashboard */
export type CompanyAccessPassesV2Args = {
  accessPassTypes?: InputMaybe<Array<AccessPassTypes>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  conditions?: InputMaybe<Array<AccessPassConditions>>;
  direction?: InputMaybe<Direction>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<AccessPassOrder>;
  visibility?: InputMaybe<VisibilityFilter>;
};

/** A company using the Whop dashboard */
export type CompanyAffiliateArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyAffiliateReferralLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<AffiliateReferralLogFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyAffiliateStatsArgs = {
  affiliateType?: InputMaybe<AffiliateTypes>;
};

/** A company using the Whop dashboard */
export type CompanyApiKeysV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyAppArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyAppsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyAuditLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<VersionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyAvailableAppAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyCoinbaseAccountArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyCoinbaseAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyCollabsPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  visibility?: InputMaybe<VisibilityFilter>;
};

/** A company using the Whop dashboard */
export type CompanyCompanyMemberArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsCampaignArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsCampaignsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ContentRewardsCampaignsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsChartsArgs = {
  config: ContentRewardsViewsChartConfigInput;
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsStatsArgs = {
  campaignId?: InputMaybe<Scalars["ID"]["input"]>;
  currency?: InputMaybe<Currencies>;
  experienceId: Scalars["ID"]["input"];
  from?: InputMaybe<Scalars["Timestamp"]["input"]>;
  platform?: InputMaybe<ContentRewardsPlatform>;
  status?: InputMaybe<ContentRewardsCampaignStatus>;
  to?: InputMaybe<Scalars["Timestamp"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsSubmissionArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyContentRewardsSubmissionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ContentRewardsSubmissionsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyCreatorDashboardChartsArgs = {
  config: CreatorDashboardChartConfigInput;
};

/** A company using the Whop dashboard */
export type CompanyCreatorDashboardRecentSearchesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyCreatorDashboardSearchArgs = {
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  query: Scalars["String"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyCreatorDashboardTableArgs = {
  tableFilters: Scalars["JSON"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyCreatorMilestoneArgs = {
  creatorMilestoneTierId: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyCreatorMilestonesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<CreatorMilestoneStatuses>;
};

/** A company using the Whop dashboard */
export type CompanyDisputeArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyDisputesNeedingAttentionCountArgs = {
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** A company using the Whop dashboard */
export type CompanyDraftedExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyExperienceArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyExperienceIdsForProductArgs = {
  productId: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  experienceType?: InputMaybe<ExperienceTypes>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyExperiencesV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ExperienceFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyHasAutomatedMessagesTriggerEnabledArgs = {
  identifier: Scalars["String"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyHeaderImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** A company using the Whop dashboard */
export type CompanyImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** A company using the Whop dashboard */
export type CompanyIsFeatureEnabledArgs = {
  feature: Scalars["String"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyItemOrderingArgs = {
  orderType: ItemOrderingOrderTypes;
};

/** A company using the Whop dashboard */
export type CompanyMemberArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyMembershipArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyOgImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** A company using the Whop dashboard */
export type CompanyPaypalAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyPendingWaitlistEntriesCountArgs = {
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** A company using the Whop dashboard */
export type CompanyPlanArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyPlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<PlanFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyProductIdsForExperienceArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyPromoCodeArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyPromoCodeUsesTodayCountArgs = {
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** A company using the Whop dashboard */
export type CompanyPromoCodesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<PromoCodeFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyPublicExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyPurchasedMembershipArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyPurchasedMembershipV2Args = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyPurchasedReceiptArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyReceiptArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyReceiptsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ReceiptV2Filters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyResolutionArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ResolutionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyResolutionsNeedingAttentionCountArgs = {
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
};

/** A company using the Whop dashboard */
export type CompanyReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ReviewFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyStripeAccountArgs = {
  id: Scalars["ID"]["input"];
};

/** A company using the Whop dashboard */
export type CompanyStripeAccountsArgs = {
  accountTypes?: InputMaybe<Array<StripeAccountTypes>>;
};

/** A company using the Whop dashboard */
export type CompanyTelegramChannelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyTrackingPixelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A company using the Whop dashboard */
export type CompanyWebhookArgs = {
  id: Scalars["ID"]["input"];
};

/** A collaboration between two companies */
export type CompanyCollab = {
  __typename?: "CompanyCollab";
  /** The time the company collab request was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The bot that received the collab */
  destinationCollaborator: PublicCompany;
  /** The ID of the company collab */
  id: Scalars["ID"]["output"];
  /** The bot that initiated the collab */
  originCollaborator: PublicCompany;
  /** The status of the company collab */
  status: CompanyCollabStatuses;
};

/** The connection type for CompanyCollab. */
export type CompanyCollabConnection = {
  __typename?: "CompanyCollabConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CompanyCollabEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CompanyCollab>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CompanyCollabEdge = {
  __typename?: "CompanyCollabEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CompanyCollab>;
};

/** Whether a company collab has been accepted or not. */
export enum CompanyCollabStatuses {
  /** Accepted */
  Accepted = "accepted",
  /** Pending */
  Pending = "pending",
}

/** Which columns can be used to sort. */
export enum CompanyCollabsSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** The connection type for Company. */
export type CompanyConnection = {
  __typename?: "CompanyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CompanyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Company>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CompanyEdge = {
  __typename?: "CompanyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Company>;
};

/** Image styles for company. */
export enum CompanyImageStyles {
  S16 = "s16",
  S20 = "s20",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S64 = "s64",
  S80 = "s80",
  S128 = "s128",
  S180 = "s180",
  S600x200 = "s600x200",
  S800x200 = "s800x200",
  S900x300 = "s900x300",
  S1200x630 = "s1200x630",
  S1600x400 = "s1600x400",
}

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMember = {
  __typename?: "CompanyMember";
  /** The affiliate for this member, if any. */
  affiliate?: Maybe<Affiliate>;
  /** The time the member was banned at */
  bannedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The cancelation reasons for the member. */
  cancelationReasons: MembershipConnection;
  /** The company for the member. */
  company: Company;
  /** When the member was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The custom field responses for the member. */
  customFieldResponses: CustomFieldResponseConnection;
  /** The entries for the member. */
  entries: EntryConnection;
  /** The header to show on the customers page */
  header: Scalars["String"]["output"];
  /** The ID of the member */
  id: Scalars["ID"]["output"];
  /** The image for the member, derived from either the User or the Company Buyer. */
  imageSrcset: ImgSrcset;
  /** When the member joined the company */
  joinedAt: Scalars["Timestamp"]["output"];
  /** The whops the member has joined. */
  joinedWhops: ExtraPublicMemberConnection;
  /** The logs for the member. */
  logs: LogConnection;
  /** An internal note a business can save regarding the member. */
  memberNotes: MemberNoteConnection;
  /** All of the member's memberships. */
  memberships: MembershipConnection;
  /** The most recent action the member has taken. */
  mostRecentAction?: Maybe<MemberMostRecentActions>;
  /** The time for the most recent action, if applicable. */
  mostRecentActionAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** An estimated MRR for the member. */
  mrr: Scalars["String"]["output"];
  /** The payment methods for the member. */
  paymentMethods: PaymentMethodConnection;
  /** The phone number for the member, if available. */
  phone?: Maybe<Scalars["String"]["output"]>;
  /** The payments for all of the member's memberships. */
  receipts: ReceiptConnection;
  /** The affiliate who referred this member, if any. */
  referredBy?: Maybe<Affiliate>;
  /** The reviews for the member. */
  reviews: ReviewConnection;
  /** Whether or not the creator can see this user's phone number (ex. the company had phone verification required when this user made a purchase). */
  showPhoneNumber: Scalars["Boolean"]["output"];
  /** The status of the member */
  status: MemberStatuses;
  /** How much they have spent on the company's passes. */
  totalSpent: Scalars["Float"]["output"];
  /** The traffic source for the member. */
  trafficSource?: Maybe<Scalars["String"]["output"]>;
  /**
   * An estimated MRR for the member.
   * @deprecated Use mrr instead.
   */
  usdMrr: Scalars["String"]["output"];
  /** How much they have spent on the company's passes. */
  usdTotalSpent: Scalars["String"]["output"];
  /** The user for this member, if any. */
  user?: Maybe<CompanyMemberUser>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberCancelationReasonsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberCustomFieldResponsesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberJoinedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberMemberNotesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberMembershipsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<MembershipHeaderStatus>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberPaymentMethodsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  currency?: InputMaybe<Currencies>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberReceiptsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<ReviewStatus>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type CompanyMemberTotalSpentArgs = {
  currency?: InputMaybe<Currencies>;
};

/** The connection type for CompanyMember. */
export type CompanyMemberConnection = {
  __typename?: "CompanyMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CompanyMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CompanyMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CompanyMemberEdge = {
  __typename?: "CompanyMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CompanyMember>;
};

/** A user who is connected to a member. */
export type CompanyMemberUser = {
  __typename?: "CompanyMemberUser";
  /** The city the user is from. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** The country the user is from. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** The name of the country the user is from (ex. United States). If not available, falls back to the country code. */
  countryName?: Maybe<Scalars["String"]["output"]>;
  /** The user's primary discord account. */
  discord?: Maybe<DiscordAccount>;
  /** The number of disputes the user has been involved in. */
  disputesAcrossWhop: Scalars["Int"]["output"];
  /** The digital mailing address of the user. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the user account. */
  id: Scalars["ID"]["output"];
  /**
   * The whops the user has joined.
   * @deprecated Use joinedWhops on companyMemberType instead.
   */
  joinedWhops: ExtraPublicMemberConnection;
  /** The user's full name. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The original ID of the user account. */
  ogId: Scalars["ID"]["output"];
  /** The number of referrals the user has made across Whop. */
  referralsAcrossWhop: Scalars["Int"]["output"];
  /** The resolution center cases the user has been involved in. */
  resolutionsAcrossWhop: Scalars["Int"]["output"];
  /** The number of reviews the user has left across Whop. */
  reviewsAcrossWhop: Scalars["Int"]["output"];
  /** The roles the user has. */
  roles: Array<Scalars["String"]["output"]>;
  /** The state the user is from. */
  state?: Maybe<Scalars["String"]["output"]>;
  /** The name of the state the user is from (ex. California). If not available, falls back to the state code. */
  stateName?: Maybe<Scalars["String"]["output"]>;
  /** The companies that the user is a current authorized user for. */
  teamMemberOf: PublicCompanyConnection;
  /** The user's first telegram account, if any. */
  telegramAccount?: Maybe<TelegramAccount>;
  /** The username for their TradingView account. */
  tradingViewUsername?: Maybe<Scalars["String"]["output"]>;
  /** The user's X account */
  twitterAccount?: Maybe<TwitterAccount>;
  /** The amount of money the user has spent across Whop. */
  usdSpendAcrossWhop: Scalars["Float"]["output"];
  /** The whop username. */
  username: Scalars["String"]["output"];
};

/** A user who is connected to a member. */
export type CompanyMemberUserJoinedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user who is connected to a member. */
export type CompanyMemberUserTeamMemberOfArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Attributes collected during company onboarding */
export type CompanyOnboardingPlanOptions = {
  /** The respective currency identifier for the plan. */
  baseCurrency?: InputMaybe<Currencies>;
  /** The interval at which the plan charges (renewal plans). */
  billingPeriod?: InputMaybe<Scalars["Int"]["input"]>;
  /** An array of custom field objects. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** An additional amount charged upon first purchase. */
  initialPrice?: InputMaybe<Scalars["Float"]["input"]>;
  /** Indicates if the plan is a one time payment or recurring. */
  planType?: InputMaybe<PlanTypes>;
  /** The method by which the plan is released to the public. */
  releaseMethod?: InputMaybe<ReleaseMethod>;
  /** The amount the customer is charged every billing period. */
  renewalPrice?: InputMaybe<Scalars["Float"]["input"]>;
  /** The visibility of the plan. */
  visibility?: InputMaybe<Visibility>;
};

/** Information about a company that is displayed to customers on their invoice */
export type CompanyProfile = {
  __typename?: "CompanyProfile";
  /** The business name of the company. */
  businessName?: Maybe<Scalars["String"]["output"]>;
  /** The city of the address. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** The country of the address. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** A support email address for the company. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The line 1 of the address. */
  line1?: Maybe<Scalars["String"]["output"]>;
  /** The line 2 of the address. */
  line2?: Maybe<Scalars["String"]["output"]>;
  /** The postal code of the address. */
  postalCode?: Maybe<Scalars["String"]["output"]>;
  /** The state of the address. */
  state?: Maybe<Scalars["String"]["output"]>;
};

/** An abuse report for a company (bot) */
export type CompanyReport = AbuseReportInterface &
  PublicAbuseReportInterface & {
    __typename?: "CompanyReport";
    /** The category of the abuse report */
    abuseReportCategory: AbuseReportCategory;
    /** The sub category of the abuse report */
    abuseReportSubCategory: AbuseReportSubCategory;
    /** The attachments for the abuse report */
    attachments: Array<AttachmentInterface>;
    /** When the abuse report was created */
    createdAt: Scalars["Timestamp"]["output"];
    /** The description of the abuse report */
    description: Scalars["String"]["output"];
    /** The ID of the abuse report */
    id: Scalars["ID"]["output"];
    /** The images for the abuse report */
    images: Array<Image>;
    /** The url of the company reporting the other company */
    merchantUrl?: Maybe<Scalars["UrlString"]["output"]>;
    /** The company reporting the other company */
    reporterCompany?: Maybe<PublicCompany>;
    /** The status of the abuse report */
    status: AbuseReportStatus;
    /** The user who made this report */
    user: User;
  };

/** DEPRECATED: The different types a company can be. */
export enum CompanyTypes {
  App = "app",
  Bot = "bot",
  Community = "community",
  Nft = "nft",
  Other = "other",
  Proxy = "proxy",
  Server = "server",
}

/** Represents a competition */
export type Competition = {
  __typename?: "Competition";
  /** If the competition is completed */
  completed: Scalars["Boolean"]["output"];
  /** The end time of the competition */
  endsAt: Scalars["Timestamp"]["output"];
  /** The id of the competition */
  id: Scalars["ID"]["output"];
  /** The metric of the competition */
  metric: CompetitionMetricTypes;
  /** The prizes for the competition */
  prizes: Array<CompetitionPrize>;
  /** The start time of the competition */
  startsAt: Scalars["Timestamp"]["output"];
  /** The name of the competition */
  title: Scalars["String"]["output"];
};

/** The different types a competition can be */
export enum CompetitionMetricTypes {
  /** Earnings Inside Access Pass */
  EarningsInsideAccessPass = "earnings_inside_access_pass",
  /** Global Earnings */
  GlobalEarnings = "global_earnings",
}

/** Represents a competition prize */
export type CompetitionPrize = {
  __typename?: "CompetitionPrize";
  /** The attachment for the prize */
  attachment?: Maybe<AttachmentInterface>;
  /** If the prize reward has been fulfilled */
  fulfilled: Scalars["Boolean"]["output"];
  /** The unique identifier for the prize */
  id: Scalars["ID"]["output"];
  /** The name for the prize */
  name: Scalars["String"]["output"];
  /** The amount to be awarded for the prize */
  prizeAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The position of this prize in the competition standings */
  prizeIndex?: Maybe<Scalars["Int"]["output"]>;
  /** The reward type for the prize */
  rewardType?: Maybe<CompetitionPrizeTypes>;
  /** The user who won the prize */
  user?: Maybe<PublicProfileUser>;
};

/** The different types a competition prize can be */
export enum CompetitionPrizeTypes {
  /** Cash */
  Cash = "cash",
  /** Custom */
  Custom = "custom",
}

/** Autogenerated input type of ConfirmAppleTransaction */
export type ConfirmAppleTransactionInput = {
  /** The app account token. */
  appAccountToken: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The environment. */
  environment: AppleEnvironments;
  /** The transaction ID. */
  transactionId: Scalars["String"]["input"];
};

/** Autogenerated input type of ConfirmPaypalOauth */
export type ConfirmPaypalOauthInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Their merchant ID */
  paypalMerchantId: Scalars["String"]["input"];
};

/** A Stripe Connected account which is tied to a company */
export type ConnectedAccount = {
  __typename?: "ConnectedAccount";
  /** The type of the connected account */
  accountType: ConnectedAccountTypes;
  /** The business type of the connected account. */
  businessType?: Maybe<StripeBusinessTypes>;
  /** Whether or not the connected account has charges enabled (mimics stripe). */
  chargesEnabled?: Maybe<Scalars["Boolean"]["output"]>;
  /** The country of the connected account. */
  country: Scalars["String"]["output"];
  /** The name of the country of the connected account. */
  countryName: Scalars["String"]["output"];
  /** The default currency of the connected account. */
  defaultCurrency?: Maybe<Currencies>;
  /** The default external account for the connected account. */
  defaultExternalAccount?: Maybe<StripeExternalAccount>;
  /** Whether or not the connected account has been flagged by the provider for fraud. */
  flaggedByProvider: Scalars["Boolean"]["output"];
  /** The internal ID of the connected account. */
  id: Scalars["ID"]["output"];
  /** Whether or not the connected account is disabled. */
  isDisabled: Scalars["Boolean"]["output"];
  /** The latest verification for the connected account. */
  latestVerification?: Maybe<Verification>;
  /** This is how frequently the connected account will be paid out. */
  monthlyAnchor?: Maybe<Scalars["Int"]["output"]>;
  /** The payout interval for the connected account (monthly, weekly, daily). */
  payoutIntervalV2?: Maybe<PayoutIntervals>;
  /** Whether or not the connected account has payouts enabled (mimics stripe). */
  payoutsEnabled?: Maybe<Scalars["Boolean"]["output"]>;
  /** Whether or not the connected account requires remediation. */
  requiresRemediation: Scalars["Boolean"]["output"];
  /** The RFIs associated with the connected account. */
  rfis: Array<Rfi>;
  /** A string that represents the connected account when seen in financial statements. */
  statementDescriptor?: Maybe<Scalars["String"]["output"]>;
  /** The status of the connected account. */
  status: ConnectedAccountStatuses;
  /** The address of the connected account. */
  supportAddress?: Maybe<Address>;
  /** The support email address of the connected account. */
  supportEmail?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the account, if it exists. */
  taxType?: Maybe<TaxTypes>;
  /** The URL of the connected account. */
  url?: Maybe<Scalars["String"]["output"]>;
  /** This is how frequently the connected account will be paid out. */
  weeklyAnchor?: Maybe<WeeklyAnchors>;
};

/** A session to access the connected account */
export type ConnectedAccountSession = {
  __typename?: "ConnectedAccountSession";
  /** The client secret of the connected account. */
  clientSecret: Scalars["String"]["output"];
  /** The timestamp of when the session expires. */
  expiresAt: Scalars["Timestamp"]["output"];
};

/** Statuses for connected accounts */
export enum ConnectedAccountStatuses {
  Connected = "connected",
  NeedsCompletion = "needs_completion",
  Rejected = "rejected",
  RequirementsNotMet = "requirements_not_met",
  UnderReview = "under_review",
}

/** Different types of how a company's marketplace card should display its pricing / access. */
export enum ConnectedAccountTypes {
  /** Custom */
  Custom = "custom",
  /** Express */
  Express = "express",
  /** Standard */
  Standard = "standard",
  /** Whop Credit */
  WhopCredit = "whop_credit",
}

/** An experience activity card about a content app document */
export type ContentCard = ExperienceActivityCardInterface & {
  __typename?: "ContentCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** The plain text content of the document */
  content?: Maybe<Scalars["String"]["output"]>;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The title of the document */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** An experience activity card about a content rewards campaign */
export type ContentRewardsCampaignCard = ExperienceActivityCardInterface & {
  __typename?: "ContentRewardsCampaignCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** The content rewards campaign that this card is about */
  contentRewardsCampaign?: Maybe<PublicCampaign>;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The ordering options for content rewards */
export enum ContentRewardsCampaignOrder {
  AmountPaidOut = "amount_paid_out",
  ExpiresAt = "expires_at",
  PendingSubmissionsCount = "pending_submissions_count",
  SubmissionsCount = "submissions_count",
  TotalBudget = "total_budget",
}

/** The different statuses content reward campaigns can be assigned to */
export enum ContentRewardsCampaignStatus {
  /** Active */
  Active = "active",
  /** Archived */
  Archived = "archived",
  /** Expired */
  Expired = "expired",
  /** Pending */
  Pending = "pending",
}

/** Values to filter content rewards on */
export type ContentRewardsCampaignsFilters = {
  /** The direction to order by */
  direction?: InputMaybe<Direction>;
  /** The ID to filter campaigns for */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The order of the rewards */
  order?: InputMaybe<ContentRewardsCampaignOrder>;
  /** The status of the reward */
  status?: InputMaybe<ContentRewardsCampaignStatus>;
};

/** The different categories content reward campaigns can be assigned to */
export enum ContentRewardsCategory {
  /** Brand */
  Brand = "brand",
  /** Creator */
  Creator = "creator",
  /** E Commerce */
  ECommerce = "e_commerce",
  /** Influencer */
  Influencer = "influencer",
  /** Logo */
  Logo = "logo",
  /** Music */
  Music = "music",
  /** Musician */
  Musician = "musician",
  /** Other */
  Other = "other",
  /** Podcast */
  Podcast = "podcast",
  /** Software */
  Software = "software",
  /** Stream */
  Stream = "stream",
  /** Streamer */
  Streamer = "streamer",
}

/** The different types of content accepted by a content reward campaign */
export enum ContentRewardsContentType {
  /** Clipping */
  Clipping = "clipping",
  /** Faceless */
  Faceless = "faceless",
  /** Other */
  Other = "other",
  /** Ugc */
  Ugc = "ugc",
}

/** The different platforms that content rewards submissions can be for */
export enum ContentRewardsPlatform {
  /** Instagram */
  Instagram = "instagram",
  /** Tiktok */
  Tiktok = "tiktok",
  /** X */
  X = "x",
  /** Youtube */
  Youtube = "youtube",
}

/** The ordering options for public content rewards campaigns */
export enum ContentRewardsPublicCampaignOrder {
  AmountPaidOut = "amount_paid_out",
  BudgetLeft = "budget_left",
  CreatedAt = "created_at",
  ExpiresAt = "expires_at",
}

/** Values to filter public content rewards on */
export type ContentRewardsPublicCampaignsFilters = {
  /** The direction to order by */
  direction?: InputMaybe<Direction>;
  /** The order of the rewards */
  order?: InputMaybe<ContentRewardsPublicCampaignOrder>;
  /** The status of the reward */
  status?: InputMaybe<ContentRewardsCampaignStatus>;
};

/** Statistics for a list of campaigns or a specific campaign */
export type ContentRewardsStatsType = {
  __typename?: "ContentRewardsStatsType";
  /** The effective CPM for this campaign. */
  effectiveCpm: Scalars["Float"]["output"];
  /** The start date to take into account */
  from?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The platform to filter the stats by */
  platform?: Maybe<ContentRewardsPlatform>;
  /** The status of the campaign */
  status: ContentRewardsCampaignStatus;
  /** The end date to take into account */
  to?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The total number of approved submissions. */
  totalApprovedSubmissions: Scalars["Int"]["output"];
  /** The total amount paid out. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount remaining budget for this/these campaign(s). */
  totalRemainingBudget: Scalars["Float"]["output"];
  /** The total submissions to this/these campaign(s). */
  totalSubmissions: Scalars["Int"]["output"];
  /** The total views generated by approved submissions. */
  totalViews: Scalars["Int"]["output"];
};

/** The different results of submission analysis */
export enum ContentRewardsSubmissionAnalysisResults {
  /** Fail */
  Fail = "fail",
  /** Pass */
  Pass = "pass",
  /** Unknown */
  Unknown = "unknown",
}

/** An experience activity card about a content rewards submission */
export type ContentRewardsSubmissionCard = ExperienceActivityCardInterface & {
  __typename?: "ContentRewardsSubmissionCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** The content rewards submission that this card is about */
  contentRewardsSubmission?: Maybe<PublicSubmission>;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** A flag on a content rewards submission */
export type ContentRewardsSubmissionFlag = {
  __typename?: "ContentRewardsSubmissionFlag";
  /** When this flag was approved */
  approvedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** When this flag was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** A detailed explanation for the flag */
  explanation?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the submission flag */
  id: Scalars["ID"]["output"];
  /** The reason the content was flagged */
  reason: ContentRewardsSubmissionFlagReasons;
  /** When this flag was last updated */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for ContentRewardsSubmissionFlag. */
export type ContentRewardsSubmissionFlagConnection = {
  __typename?: "ContentRewardsSubmissionFlagConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContentRewardsSubmissionFlagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContentRewardsSubmissionFlag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ContentRewardsSubmissionFlagEdge = {
  __typename?: "ContentRewardsSubmissionFlagEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ContentRewardsSubmissionFlag>;
};

/** The reasons a content rewards submission can be flagged for. */
export enum ContentRewardsSubmissionFlagReasons {
  /** Engagement Ratio */
  EngagementRatio = "engagement_ratio",
  /** Text Analysis */
  TextAnalysis = "text_analysis",
  /** Video Analysis */
  VideoAnalysis = "video_analysis",
  /** View Acceleration */
  ViewAcceleration = "view_acceleration",
  /** View Spike */
  ViewSpike = "view_spike",
}

/** The different statuses content reward submissions can be assigned to */
export enum ContentRewardsSubmissionStatus {
  /** Approved */
  Approved = "approved",
  /** Flagged */
  Flagged = "flagged",
  /** Pending */
  Pending = "pending",
  /** Rejected */
  Rejected = "rejected",
}

/** A content rewards submission */
export type ContentRewardsSubmissionUniversalPost =
  UniversalPostResourceInterface & {
    __typename?: "ContentRewardsSubmissionUniversalPost";
    /** The content rewards submission */
    contentRewardsSubmission?: Maybe<PublicSubmission>;
    /** The type of the resource */
    resourceType: Scalars["String"]["output"];
  };

/** The configuration for a chart. */
export type ContentRewardsSubmissionViewsChartConfigInput = {
  /** The interval to group the data by. */
  interval?: InputMaybe<ChartIntervals>;
  /** The time zone used for start of day calculations. */
  timeZone?: InputMaybe<Scalars["String"]["input"]>;
  /** The week mode to group the data by. For details, look at https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#toweek */
  weekMode?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Values to filter content rewards submissions on */
export type ContentRewardsSubmissionsFilters = {
  /**
   * The type of attachment required on the submission
   * @deprecated No longer available
   */
  attachmentType?: InputMaybe<FileAttachmentTypes>;
  /** The campaign ID to filter by */
  campaignId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The direction to order by */
  direction?: InputMaybe<Direction>;
  /** Whether to exclude banned users from the results */
  excludeBannedUsers?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The experience ID to filter by */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The order to sort the results by */
  order?: InputMaybe<ContentRewardsSubmissionsOrder>;
  /** Whether the submission has reached the minimum payout */
  reachedMinimumPayout?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The status of the submissions */
  status?: InputMaybe<ContentRewardsSubmissionStatus>;
  /** Filter submissions by partial username match */
  username?: InputMaybe<Scalars["String"]["input"]>;
  /** The result of the video analysis */
  videoAnalysisResult?: InputMaybe<ContentRewardsSubmissionAnalysisResults>;
};

/** The ordering options for content rewards submissions */
export enum ContentRewardsSubmissionsOrder {
  CreatedAt = "created_at",
  TotalPaid = "total_paid",
  TotalViewCount = "total_view_count",
}

/** Which columns can be used to sort. */
export enum ContentRewardsSubmissionsSortableColumns {
  CachedTotalPaid = "cached_total_paid",
  CachedTotalViewCount = "cached_total_view_count",
  CreatedAt = "created_at",
  Id = "id",
  Status = "status",
}

/** Total views broken down by platform */
export type ContentRewardsTotalViewsByPlatformChart = {
  __typename?: "ContentRewardsTotalViewsByPlatformChart";
  /** Total views over time. */
  instagram: CreatorDashboardChartsDataNumber;
  /** Total views over time. */
  tiktok: CreatorDashboardChartsDataNumber;
  /** Total views over time. */
  x: CreatorDashboardChartsDataNumber;
  /** Total views over time. */
  youtube: CreatorDashboardChartsDataNumber;
};

/** Charts for the content rewards app */
export type ContentRewardsTotalViewsChartType = {
  __typename?: "ContentRewardsTotalViewsChartType";
  /** The total views broken down by platform */
  totalViews: ContentRewardsTotalViewsByPlatformChart;
};

/** The configuration for a chart. */
export type ContentRewardsViewsChartConfigInput = {
  /** The ID of the campaign to filter by */
  campaignId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the experience to filter by */
  experienceId: Scalars["ID"]["input"];
  /** The start date to take into account. */
  from: Scalars["Timestamp"]["input"];
  /** The interval to group the data by. */
  interval?: InputMaybe<ChartIntervals>;
  /** The time zone used for start of day calculations. */
  timeZone?: InputMaybe<Scalars["String"]["input"]>;
  /** The end date to take into account. */
  to: Scalars["Timestamp"]["input"];
  /** The week mode to group the data by. For details, look at https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#toweek */
  weekMode?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A search result for content. */
export type ContentSearch = {
  __typename?: "ContentSearch";
  /** The ID of the app that the content belongs to. */
  app: PublicApp;
  /** The content of the search result. */
  content: Scalars["String"]["output"];
  /** The timestamp of when the content was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the experience that the content belongs to. */
  experience: PublicExperience;
  /** Whether or not the content has media. */
  hasMedia: Scalars["Boolean"]["output"];
  /** The highlights of the content. */
  highlights: Scalars["JSON"]["output"];
  /** The title of the content. */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** Represents a LedgerAccount. */
export type CopyableLedgerAccount = {
  __typename?: "CopyableLedgerAccount";
  /** The company that owns this ledger account, if it is owned by a Bot */
  company?: Maybe<PublicCompany>;
  /** The ID of the LedgerAccount. */
  id: Scalars["ID"]["output"];
  /** The type of resource that owns this ledger account. */
  resourceOwnerType: Scalars["String"]["output"];
  /** The user that owns this ledger account, if it is owned by a User */
  user?: Maybe<PublicProfileUser>;
};

/** The connection type for CopyableLedgerAccount. */
export type CopyableLedgerAccountConnection = {
  __typename?: "CopyableLedgerAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CopyableLedgerAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CopyableLedgerAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CopyableLedgerAccountEdge = {
  __typename?: "CopyableLedgerAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CopyableLedgerAccount>;
};

/** The available countries on the platform */
export enum Countries {
  Ae = "ae",
  Ag = "ag",
  Al = "al",
  Am = "am",
  Ar = "ar",
  At = "at",
  Au = "au",
  Ba = "ba",
  Be = "be",
  Bg = "bg",
  Bh = "bh",
  Bo = "bo",
  Br = "br",
  Bs = "bs",
  Ca = "ca",
  Ch = "ch",
  Ci = "ci",
  Cl = "cl",
  Cn = "cn",
  Co = "co",
  Cr = "cr",
  Cy = "cy",
  Cz = "cz",
  De = "de",
  Dk = "dk",
  Do = "do",
  Dz = "dz",
  Ec = "ec",
  Ee = "ee",
  Eg = "eg",
  Es = "es",
  Et = "et",
  Fi = "fi",
  Fr = "fr",
  Gb = "gb",
  Gh = "gh",
  Gi = "gi",
  Gm = "gm",
  Gr = "gr",
  Gt = "gt",
  Gy = "gy",
  Hk = "hk",
  Hr = "hr",
  Hu = "hu",
  Id = "id",
  Ie = "ie",
  Il = "il",
  In = "in",
  Is = "is",
  It = "it",
  Jm = "jm",
  Jo = "jo",
  Jp = "jp",
  Ke = "ke",
  Kh = "kh",
  Kr = "kr",
  Kw = "kw",
  Lc = "lc",
  Li = "li",
  Lk = "lk",
  Lt = "lt",
  Lu = "lu",
  Lv = "lv",
  Ma = "ma",
  Md = "md",
  Mg = "mg",
  Mk = "mk",
  Mn = "mn",
  Mo = "mo",
  Mt = "mt",
  Mu = "mu",
  Mx = "mx",
  My = "my",
  Na = "na",
  Ne = "ne",
  Ng = "ng",
  Nl = "nl",
  No = "no",
  Nz = "nz",
  Om = "om",
  Pa = "pa",
  Pe = "pe",
  Ph = "ph",
  Pk = "pk",
  Pl = "pl",
  Pt = "pt",
  Py = "py",
  Qa = "qa",
  Ro = "ro",
  Rs = "rs",
  Ru = "ru",
  Rw = "rw",
  Sa = "sa",
  Se = "se",
  Sg = "sg",
  Si = "si",
  Sk = "sk",
  Sn = "sn",
  Sv = "sv",
  Sy = "sy",
  Th = "th",
  Tn = "tn",
  Tr = "tr",
  Tt = "tt",
  Tw = "tw",
  Tz = "tz",
  Ua = "ua",
  Us = "us",
  Uy = "uy",
  Uz = "uz",
  Ve = "ve",
  Vn = "vn",
  Ye = "ye",
  Za = "za",
}

/** Represents the different lists of countries that can be fetched */
export type CountryList = {
  __typename?: "CountryList";
  /** All of the regular countries that can be used on Whop. */
  countries: Array<Countries>;
  /** All of the countries that can be used to sign up for stripe accounts on Whop */
  stripeCountries: Array<StripeCountries>;
  /** All of the european countries that can be used to sign up for stripe accounts on Whop */
  stripeEuCountries: Array<StripeEuCountries>;
};

/** An experience activity card about a course */
export type CourseCard = ExperienceActivityCardInterface & {
  __typename?: "CourseCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** The cover image URL of the course */
  coverImage?: Maybe<Scalars["String"]["output"]>;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the course */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The number of lessons in the course */
  lessonCount?: Maybe<Scalars["Int"]["output"]>;
  /** The tagline of the course */
  tagLine?: Maybe<Scalars["String"]["output"]>;
  /** The title of the course */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** Autogenerated input type of CreateAccessPassAbuseReport */
export type CreateAccessPassAbuseReportInput = {
  /** The ID of the report category */
  abuseReportSubCategoryId: Scalars["ID"]["input"];
  /** The ID of the access pass to report */
  accessPassId: Scalars["ID"]["input"];
  /** The attachments to attach to the report */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the merchant to report on behalf of (If on Whop) */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The description of the abuse report */
  description: Scalars["String"]["input"];
  /**
   * The images to attach to the report
   * @deprecated Use attachments instead
   */
  images?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /** The URL of the merchant to report on behalf of (If not on Whop) */
  merchantUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of CreateAccessPassAffiliate */
export type CreateAccessPassAffiliateInput = {
  /** The ID of the access pass that the affiliate is being created for. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateAccessPassFaq */
export type CreateAccessPassFaqInput = {
  /** The ID of the access pass that the faq is being created on. */
  accessPassId: Scalars["ID"]["input"];
  /** The answer of the FAQ. */
  answer: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The question of the FAQ. */
  question: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateAccessPass */
export type CreateAccessPassInput = {
  /** Whether or not to activate Whop 4.0 for the org. */
  activateWhopFour?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not this should be an App access pass. */
  asApp?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A banner image for the access pass in png, jpeg format */
  bannerImage?: InputMaybe<AttachmentInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The creator pitch for the access pass. */
  creatorPitch?: InputMaybe<Scalars["String"]["input"]>;
  /** The custom call to action for the access pass. */
  customCta?: InputMaybe<CustomCtas>;
  /** The custom call to action URL for the access pass. */
  customCtaUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** A written description of the access pass. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * An array of experience IDs that this pass has
   * @deprecated No longer implemented.
   */
  experienceIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The percentage of the revenue that goes to the global affiliate program. */
  globalAffiliatePercentage?: InputMaybe<Scalars["Float"]["input"]>;
  /** The status of the global affiliate program for this access pass. */
  globalAffiliateStatus?: InputMaybe<GlobalAffiliateStatuses>;
  /** The headline of the access pass. */
  headline?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * An attachment image that is either a png, jpeg, or gif.
   * @deprecated Use logo instead
   */
  image?: InputMaybe<Scalars["File"]["input"]>;
  /** The preceding characters before a randomly generated license key. */
  licenseKeyPrefix?: InputMaybe<Scalars["String"]["input"]>;
  /** The logo for the access pass in png, jpeg, or gif format */
  logo?: InputMaybe<AttachmentInput>;
  /** Metadata to store on the access pass. */
  metadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /**
   * The name of the access pass. It must be max 50 characters.
   * @deprecated Please use 'title' instead.
   */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The onboarding version for this access pass. */
  onboardingVersion?: InputMaybe<AccessPassOnboardingVersionTypes>;
  /**
   * A user can/cannot own multiple of this pass
   * @deprecated No longer used
   */
  onePerUser?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the page that this access pass is associated with. */
  pageId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The details to assign an autogenerated plan. */
  planOptions?: InputMaybe<CompanyOnboardingPlanOptions>;
  /** The URL to redirect the customer to after a purchase. */
  redirectPurchaseUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The route of the access pass. */
  route?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to show the member count on the access pass. */
  showMemberCount?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not to show reviews on the access pass. */
  showReviewsDtc?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A license key can/can't be scrambled. */
  shuffleable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The title of the access pass, for Whop 4.0. */
  title: Scalars["String"]["input"];
  /** This access pass can/cannot be transferred to another user */
  transferable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not customers can upgrade to different plans on this access pass. */
  upgradeable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The description of the upsell for the access pass. */
  upsellDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** The media for the upsell of the access pass, either an image or video. */
  upsellMedia?: InputMaybe<AttachmentInput>;
  /** The title of the upsell for the access pass. */
  upsellTitle?: InputMaybe<Scalars["String"]["input"]>;
  /** This access pass will/will not be displayed publicly. */
  visibility?: InputMaybe<Visibility>;
};

/** Autogenerated input type of CreateAccessPassSocialLink */
export type CreateAccessPassSocialLinkInput = {
  /** The ID of the Access Pass this social link belongs to */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL of the social link */
  url: Scalars["UrlString"]["input"];
  /** The website this link is for */
  website: SocialLinkWebsites;
};

/** Autogenerated input type of CreateAdminMembership */
export type CreateAdminMembershipInput = {
  /** The pass to make a membership for. Please use accessPass.id if you don't know what to use. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateAffiliate */
export type CreateAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The fee that the affiliate will receive for each referral (either a percentage or a flat fee). */
  fee?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** Whether the affiliate will only receive one payout. */
  onlyOnePayout?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether the fee is a percentage or a flat fee. */
  payoutType: PayoutTypes;
  /** The IDs of the plans that the affiliate can refer. */
  planId: Scalars["ID"]["input"];
  /** The username of the user who will become an affiliate */
  username: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateApiKeyV2 */
export type CreateApiKeyV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The permissions this api key should have enabled. If empty, it will be unscoped. */
  permissions?: InputMaybe<Array<ApiKeyPermissions>>;
};

/** Autogenerated input type of CreateAppExperience */
export type CreateAppExperienceInput = {
  /**
   * The access level of the experience to be created
   * @deprecated You can't set this anymore
   */
  accessLevel?: InputMaybe<ExperienceAccessLevels>;
  /**
   * The ID of the access pass to attach the experience to
   * @deprecated Use access_pass_ids instead
   */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The IDs of the access passes to attach the experience to */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The ID of the experience interface */
  appId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the experience to be created */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The expiration date of the experience to be created */
  expiresAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The name of the experience to be created */
  name: Scalars["String"]["input"];
  /** The upsell plan details to create or modify for the experience */
  upsellPlan?: InputMaybe<UpsellPlanInput>;
};

/** Autogenerated input type of CreateAuthorizedUser */
export type CreateAuthorizedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The email, username, or discord account ID of the user to add. */
  email?: InputMaybe<Scalars["String"]["input"]>;
  /** The role to apply to the user */
  role: AuthorizedUserRoles;
};

/** Autogenerated input type of CreateBounty */
export type CreateBountyInput = {
  /** The access passes to create an experience for this bounty to be created in */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Whether or not this bounty accepts Instagram submissions or not */
  allowInstagram?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not this bounty accepts TikTok submissions or not */
  allowTiktok?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not this bounty accepts X submissions or not */
  allowX?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not this bounty accepts YouTube video submissions or not */
  allowYoutube?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** How much the base unit should be (for example, 10 for: N$ reward / 10 views) */
  baseUnitAmount?: InputMaybe<Scalars["Int"]["input"]>;
  /** The maximum total sum of money the creator is willing to pay for all bounty rewards */
  budgetAmount?: InputMaybe<Scalars["Float"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency of the bounty reward */
  currency: Currencies;
  /** The description of the bounty */
  description: Scalars["String"]["input"];
  /** The experience ID where the bounty should be created in */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The file attachments for this message */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** How much to reward a successful submission per unit */
  rewardPerUnitAmount: Scalars["Float"]["input"];
  /** What type of reward structure to use for the bounty */
  rewardUnit: RewardUnits;
  /** The title of the bounty */
  title: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateCampaign */
export type CreateCampaignInput = {
  /** The access passes to create an experience for this bounty to be created in */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Whether to allow Instagram submissions */
  allowInstagram: Scalars["Boolean"]["input"];
  /** Whether to allow TikTok submissions */
  allowTiktok: Scalars["Boolean"]["input"];
  /** Whether to allow X submissions */
  allowX: Scalars["Boolean"]["input"];
  /** Whether to allow YouTube submissions */
  allowYoutube: Scalars["Boolean"]["input"];
  /** The array of included assets for this campaign */
  assets: Array<Scalars["String"]["input"]>;
  /** The attachments for this campaign */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The number of hours after which submissions get auto-approved */
  autoApproveSubmissionsInHours?: InputMaybe<Scalars["Int"]["input"]>;
  /** Which category to assign */
  category: ContentRewardsCategory;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Which content type is accepted */
  contentType: ContentRewardsContentType;
  /** Which currency should be used for payments */
  currency: Currencies;
  /** The ID of the experience to associate this object with */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** When this campaign ends, if not set, the campaign will not expire */
  expiresAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /**
   * The file attachments for this campaign
   * @deprecated Use `attachments` instead
   */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** Whether submissions to this campaign require file uploads */
  fileUploadRequired?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The fixed amount that will be paid out per approved submission */
  fixedRewardPerSubmission?: InputMaybe<Scalars["Float"]["input"]>;
  /** The maximum amount that will be paid out per submission */
  maxPayoutPerSubmission?: InputMaybe<Scalars["Float"]["input"]>;
  /** The minimum amount owed before a submission is eligible for payouts */
  minPayoutPerSubmission?: InputMaybe<Scalars["Float"]["input"]>;
  /** URL that must be present in the submitter's social account bio */
  requiredCreatorBioLink?: InputMaybe<Scalars["String"]["input"]>;
  /** Text patterns that must be present in the submitted post description */
  requiredDescriptionText?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** Instagram audio that must be used in the submissions */
  requiredInstagramAudio?: InputMaybe<Scalars["String"]["input"]>;
  /** TikTok audio that must be used in the submissions */
  requiredTiktokAudio?: InputMaybe<Scalars["String"]["input"]>;
  /** An array of requirements that the user must complete to collect a reward */
  requirements: Array<Scalars["String"]["input"]>;
  /** The amount that a user should be rewarded per thousand views submitted */
  rewardRatePerThousandViews: Scalars["Float"]["input"];
  /** The title of this campaign */
  title: Scalars["String"]["input"];
  /** The total amount that will be paid out for this campaign */
  totalBudget: Scalars["Float"]["input"];
};

/** Autogenerated input type of CreateCheckoutSession */
export type CreateCheckoutSessionInput = {
  /** The affiliate code to use for the checkout session */
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The metadata to use for the checkout session */
  metadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /** The ID of the plan to use for the checkout session */
  planId: Scalars["ID"]["input"];
  /** The URL to redirect the user to after the checkout session is created */
  redirectUrl?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateCoinbaseAccount */
export type CreateCoinbaseAccountInput = {
  /** The Coinbase Commerce API key to use. */
  apiKey: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The Coinbase Commerce shared secret to use. */
  webhookSecret: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateCompanyMutedUser */
export type CreateCompanyMutedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The time the user is muted until, in milliseconds. If not provided, the user will be muted indefinitely */
  mutedUntil?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The ID of the user to mute */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreateCryptoWallet */
export type CreateCryptoWalletInput = {
  /** The address of the wallet */
  address: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The network of the wallet */
  network: CryptoWalletNetworks;
  /** The nonce used to verify the wallet */
  nonce: Scalars["String"]["input"];
  /** The signature signed by the client */
  signature: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateCryptoWalletNonce */
export type CreateCryptoWalletNonceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateDirectMessage */
export type CreateDirectMessageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user to send the message to. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreateDiscoverInteraction */
export type CreateDiscoverInteractionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The rating the user has made for this object. */
  rating: ReportTypes;
  /** The ID of the item that the user is viewing. */
  resourceId: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateDmChannel */
export type CreateDmChannelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The custom name for the DM channel */
  customName?: InputMaybe<Scalars["String"]["input"]>;
  /** The user ids to create a DM with. Can be email, username or user_id (tag) */
  withUserIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated return type of CreateDmChannel. */
export type CreateDmChannelPayload = {
  __typename?: "CreateDmChannelPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The feed data */
  feedData: DmsFeedDataResponse;
};

/** Autogenerated input type of CreateFeedWebhook */
export type CreateFeedWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the feed to create the webhook for */
  feedId: Scalars["ID"]["input"];
  /** The type of feed to create the webhook for */
  feedType: FeedTypes;
  /** The name of the webhook */
  name: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateForumPost */
export type CreateForumPostInput = {
  /**
   * The access pass to create this post in (leave empty if passing in an experience)
   * @deprecated Use access_pass_ids instead
   */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The access passes to create an experience for this post to be created in */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The experience to create this post in (leave empty if creating a new one) */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The forum post to create */
  forumPost: ForumPostInput;
};

/** Autogenerated return type of CreateForumPost. */
export type CreateForumPostPayload = {
  __typename?: "CreateForumPostPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The entities that were processed */
  entities: Array<ProcessEntitiesOutput>;
  /** The experience in which this post was created in */
  experience: AccessibleExperience;
};

/** Autogenerated input type of CreateIngress */
export type CreateIngressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateLead */
export type CreateLeadInput = {
  /** The ID of the access pass to become a lead for. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The url referrer of the lead, if any. */
  referrer?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateLedgerConnectedAccount */
export type CreateLedgerConnectedAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account to copy the connected account from. It must be another LedgerAccount that the owner of the current LedgerAccount has access to. */
  copyFromId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The mode to use when copying the connected account. If 'clone', the existing connected account will be attached to the current ledger account. If 'prefill', a new connected account will be created with existing information prefilled. */
  copyMode?: InputMaybe<LedgerAccountCopyModes>;
  /** The country of the ledger account. */
  country?: InputMaybe<Countries>;
  /** This is the ID of the ledger account to generate an onboarding URL for. */
  id: Scalars["ID"]["input"];
  /** The URL to redirect to after the user has completed the Stripe onboarding process. */
  redirectUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of CreateLineItem */
export type CreateLineItemInput = {
  /** The amount of the plan. */
  amount: Scalars["Float"]["input"];
  /** The ID of the app to create the plan for. */
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The base currency of the plan. */
  baseCurrency: Currencies;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the experience to create the plan for. */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the ledger account to associate with the plan. */
  ledgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The name of the plan. */
  name: Scalars["String"]["input"];
  /** The URL to redirect to after the plan is purchased. */
  redirectUrl?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateLivekitToken */
export type CreateLivekitTokenInput = {
  /** The access pass id of the livestream to issue a token for */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The bot id of the livestream to issue a token for */
  botId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The experience id of the livestream to issue a token for */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The feed id of the livestream to issue a token for */
  feedId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreateMember */
export type CreateMemberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company to join. */
  companyId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreateMemberNote */
export type CreateMemberNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The notes to be added to the member. */
  notes: Scalars["String"]["input"];
  /** The ID of the user to add the note to. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreatePaymentMethod */
export type CreatePaymentMethodInput = {
  /** The Apple Pay ID of the payment method to create. */
  applePayId?: InputMaybe<Scalars["String"]["input"]>;
  /** The card token of the payment method to create. */
  cardToken?: InputMaybe<Scalars["String"]["input"]>;
  /** The credit card number of the payment method to create. */
  cc?: InputMaybe<Scalars["String"]["input"]>;
  /** The city of the billing address. */
  city?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company buyer to create a payment method for. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the company to create a payment method for. Target's their default stripe account. */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The country code of the billing address. */
  countryCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency of the billing address. */
  currency?: InputMaybe<Currencies>;
  /** The CVC of the payment method to create. */
  cvc?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not this is the default payment method. */
  default?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The expiration month of the payment method to create. */
  expMonth?: InputMaybe<Scalars["Int"]["input"]>;
  /** The expiration year of the payment method to create. */
  expYear?: InputMaybe<Scalars["Int"]["input"]>;
  /** The address line 1 of the billing address. */
  line1?: InputMaybe<Scalars["String"]["input"]>;
  /** The address line 2 of the billing address. */
  line2?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the customer. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The OCC cookie */
  occ?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the payment intent to confirm 3DS for. */
  paymentIntentId?: InputMaybe<Scalars["String"]["input"]>;
  /** The payment processor of the payment method to create. */
  paymentProcessor?: InputMaybe<PaymentProcessor>;
  /** The phone number of the payment method to create. */
  phone?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The ID of the plan to create a payment method for.
   * @deprecated Use company_id instead.
   */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The postal code of the billing address. */
  postalCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The setup token ID of the payment method to create (used for PayPal). */
  setupTokenId?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of the billing address. */
  state?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreatePersonalAccount */
export type CreatePersonalAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Stripe Publishable Key */
  stripePublishableKey: Scalars["String"]["input"];
  /** Stripe Secret Key */
  stripeSecretKey: Scalars["String"]["input"];
};

/** Autogenerated input type of CreatePlan */
export type CreatePlanInput = {
  /** The access pass the plan is related to. */
  accessPassId: Scalars["ID"]["input"];
  /** Whether or not ACH payments are accepted */
  achPayments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The respective currency identifier for the plan. */
  baseCurrency?: InputMaybe<Currencies>;
  /** The interval at which the plan charges (renewal plans). */
  billingPeriod?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether or not to cancel dependant collab passes if a user loses access to this one. */
  cancelCollabPasses?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Either forever (0), first payment (1), or a specified number of months (2, 3, 4...). */
  cancelDiscountIntervals?: InputMaybe<Scalars["Int"]["input"]>;
  /** The percentage discount to offer when canceling a subscription. */
  cancelDiscountPercentage?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether or not card payments are accepted */
  cardPayments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether coinbase commerce payments are/aren't accepted. */
  coinbaseCommerceAccepted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** An array of custom field objects. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** The description of the plan. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The interval at which the plan charges (expiration plans). */
  expirationDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** The time period (in days) after a sub expires where the customer can still top-up. */
  gracePeriodDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** An additional amount charged upon first purchase. */
  initialPrice?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** A personal description or notes section for the business. */
  internalNotes?: InputMaybe<Scalars["String"]["input"]>;
  /** The plan to mimic the Stripe Price ID for. */
  mimicPlanId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether or not to offer a discount to cancel a subscription. */
  offerCancelDiscount?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Marks whether or not a plan can be purchased multiple times by a company. Used most likely for free trial plans  */
  onePerCompany?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Marks whether or not a plan can be purchased multiple times by a user. Used most likely for free trial plans
   * @deprecated No longer used
   */
  onePerUser?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** An override for tax to specify for this specific plan. */
  overrideTaxType?: InputMaybe<TaxTypes>;
  /** The description of the Plan as seen by the customer on the checkout page. */
  paymentLinkDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether paypal payments are/aren't accepted. */
  paypalAccepted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Indicates if the plan is a one time payment or recurring. */
  planType?: InputMaybe<PlanTypes>;
  /** The URL to redirect the customer to after purchase. */
  redirectUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether an expiration plan can/can't be topped-up. */
  refillable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** This is the release method the business uses to sell this plan. */
  releaseMethod?: InputMaybe<ReleaseMethod>;
  /** Configurable settings on how this plan is released. */
  releaseMethodSettings?: InputMaybe<ReleaseMethodSettingsInput>;
  /** The amount the customer is charged every billing period. */
  renewalPrice?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** The requirements for the plan. */
  requirements?: InputMaybe<Scalars["Requirements"]["input"]>;
  /** Whether or not to set this plan as the default for the company. */
  setAsDefault?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The short link identifier for the plan. */
  shortLink?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: InputMaybe<Scalars["Int"]["input"]>;
  /** The number of units available for purchase. */
  stock?: InputMaybe<Scalars["Int"]["input"]>;
  /** The number of free trial days added before a renewal plan. */
  trialPeriodDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** Limits/doesn't limit the number of units available for purchase. */
  unlimitedStock?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Shows or hides the plan from public/business view. */
  visibility?: InputMaybe<Visibility>;
};

/** Autogenerated input type of CreateProductHighlight */
export type CreateProductHighlightInput = {
  /** The ID of the product. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Text to display to describe the product highlight (max length 250). */
  content: Scalars["String"]["input"];
  /** The type of this highlight. */
  highlightType: ProductHighlightTypes;
  /** The title of the product highlight, if applicable. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreatePromoCode */
export type CreatePromoCodeInput = {
  /** The access pass to lock the promo code to, if any. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The amount off (% or flat amount) for the promo. */
  amountOff: Scalars["StringFloat"]["input"];
  /** The monetary currency of the promo code. */
  baseCurrency: Currencies;
  /** Restricts promo use to only users who have churned from the company before. */
  churnedUsersOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The specific code used to apply the promo at checkout. */
  code: Scalars["String"]["input"];
  /** Whether this promo code is for existing memberships only (cancelations) */
  existingMembershipsOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The date/time of when the promo expires. */
  expirationDatetime?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** Restricts promo use to only users who have never purchased from the company before. */
  newUsersOnly: Scalars["Boolean"]["input"];
  /** The number of billing cycles the promo is applied for. */
  numberOfIntervals: Scalars["Int"]["input"];
  /** Restricts promo use to only be applied once per customer. */
  onePerCustomer?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The IDs of the plans that the affiliate can refer. */
  planIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The type (% or flat amount) of the promo. */
  promoType: PromoTypes;
  /** The quantity limit on the number of uses. */
  stock?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether or not the promo code should have unlimited stock. */
  unlimitedStock?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated input type of CreateQuickLink */
export type CreateQuickLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A custom password for this quicklink. */
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  /** The plan to mimic the Stripe Price ID for. */
  mimicPlanId: Scalars["ID"]["input"];
  /** The short link identifier for the plan. */
  shortLink?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of units available for purchase. */
  stock?: InputMaybe<Scalars["Int"]["input"]>;
  /** The number of free trial days added before a renewal plan. */
  trialPeriodDays?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of CreateReview */
export type CreateReviewInput = {
  /** The access pass to make the review for. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The attachments to upload */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The company to make the review for. (Either a route or business tag) */
  companyId?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the review. */
  description: Scalars["String"]["input"];
  /**
   * The images to attach to the report
   * @deprecated Use `attachments` instead
   */
  images?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /**
   * The page to make the review for (Either a route or a page tag)
   * @deprecated Use access_pass_id or company_id instead.
   */
  pageId?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of stars to give the review. */
  stars: Scalars["Int"]["input"];
  /** The title of the review. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateReviewReport */
export type CreateReviewReportInput = {
  /** The files to attach to the report */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The files to attach to the report
   * @deprecated Use `attachments` instead.
   */
  fileAttachments?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /** The reason for reporting the review */
  reason: Scalars["String"]["input"];
  /** The ID of the review to report */
  reviewId: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateSetupToken */
export type CreateSetupTokenInput = {
  /** A url to return the user to after cancelling the approval flow. */
  cancelUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A url to return the user to after completing the approval flow. */
  returnUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of CreateSubmission */
export type CreateSubmissionInput = {
  /** The attachments for this message as IDs */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The ID of the campaign to create this submission for */
  campaignId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The public URL where this content is available */
  contentUrl: Scalars["String"]["input"];
  /** The platform to create this submission for */
  platform: ContentRewardsPlatform;
};

/** Autogenerated input type of CreateTrackingLink */
export type CreateTrackingLinkInput = {
  /** The access pass id of the tracking link */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The channel of the tracking link */
  channel: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The destination of the tracking link */
  destination?: InputMaybe<TrackingLinkDestination>;
  /** The name of the tracking link */
  name: Scalars["String"]["input"];
  /** The plan id of the tracking link */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The route of the tracking link */
  route?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateUnverifiedUserSocialLink */
export type CreateUnverifiedUserSocialLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL of the social link */
  url: Scalars["UrlString"]["input"];
  /** The website this link is for */
  website: UserSocialLinkWebsites;
};

/** Autogenerated input type of CreateUserLedgerAccount */
export type CreateUserLedgerAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CreateUserReport */
export type CreateUserReportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The evidence of the abuse report */
  evidence?: InputMaybe<Scalars["String"]["input"]>;
  /** The reason of the abuse report */
  reason?: InputMaybe<Scalars["String"]["input"]>;
  /** The source of the abuse report */
  source: UserReportSources;
  /** The ID of the user to report */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CreateUserSocialLink */
export type CreateUserSocialLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL of the social link */
  url: Scalars["UrlString"]["input"];
  /** The website this link is for */
  website: UserSocialLinkWebsites;
};

/** Autogenerated input type of CreateUserTelegramVerificationCode */
export type CreateUserTelegramVerificationCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

export type CreateVideo = {
  __typename?: "CreateVideo";
  /** The bulk task ID that was created */
  bulkTaskId?: Maybe<Scalars["ID"]["output"]>;
  /** The error message of the video */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** The feed id of the chat to send the video when complete. If passed, the client will not need to poll */
  feedId?: Maybe<Scalars["String"]["output"]>;
  /** The operation id of the video */
  operationId?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of CreateVideo */
export type CreateVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the AI character to use */
  creatorName: Scalars["String"]["input"];
  /** The feed id of the chat to send the video when complete. If passed, the client will not need to poll */
  feedId?: InputMaybe<Scalars["String"]["input"]>;
  /** The text to send to the chat when the video is complete below the video */
  messageText?: InputMaybe<Scalars["String"]["input"]>;
  /** The script for the AI to speak */
  script: Scalars["String"]["input"];
};

/** Autogenerated input type of CreateWebhook */
export type CreateWebhookInput = {
  /** The API version for this webhook */
  apiVersion?: InputMaybe<ApiVersion>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the webhook is enabled. */
  enabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The events to send the webhook for. */
  events?: InputMaybe<Array<WebhookEvent>>;
  /** The resource to create the webhook for. By default this will use current company */
  resourceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The URL to send the webhook to. */
  url: Scalars["UrlString"]["input"];
};

/** Autogenerated input type of CreateWithdrawal */
export type CreateWithdrawalInput = {
  /** The amount to withdraw */
  amount: Scalars["Float"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency that is being withdrawn. */
  currency?: InputMaybe<Currencies>;
  /** The speed of the withdrawal. */
  speed?: InputMaybe<WithdrawalSpeeds>;
};

/** Cancelation discounts for creator dashboard */
export enum CreatorDashboardCancelationDiscounts {
  Canceled = "canceled",
  UsedDiscountAndCanceled = "used_discount_and_canceled",
  UsedDiscountAndDidNotCancel = "used_discount_and_did_not_cancel",
}

/** The configuration for a chart. */
export type CreatorDashboardChartConfigInput = {
  /** The access pass ids (tags) to filter the data by. */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The currency to use for the chart. */
  currency?: InputMaybe<Currencies>;
  /** The start date to take into account. */
  from: Scalars["Timestamp"]["input"];
  /** The interval to group the data by. */
  interval?: InputMaybe<CreatorDashboardChartIntervals>;
  /** The time zone used for start of day calculations. */
  timeZone?: InputMaybe<Scalars["String"]["input"]>;
  /** The end date to take into account. */
  to: Scalars["Timestamp"]["input"];
  /** The week mode to group the data by. For details, look at https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#toweek */
  weekMode?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Chart interval (period). */
export enum CreatorDashboardChartIntervals {
  Daily = "daily",
  Hourly = "hourly",
  Monthly = "monthly",
  Weekly = "weekly",
  Yearly = "yearly",
}

/** The financial and membership stats for a company. */
export type CreatorDashboardCharts = {
  __typename?: "CreatorDashboardCharts";
  /** Affiliate fees. */
  affiliateFees: CreatorDashboardChartsDataNumber;
  /** Annually recurring revenue. */
  arr: CreatorDashboardChartsDataNumberNoSum;
  /** Average Revenue Per Paying User. */
  averageRevenuePerPayingUser: CreatorDashboardChartsDataNumberNoSum;
  /** Average revenue per subscription. */
  averageRevenuePerSubscription: CreatorDashboardChartsDataNumberNoSum;
  /** Cancelation discount breakdown */
  cancelationDiscountBreakdown: Array<CreatorDashboardChartsCancelationDiscountBreakdownRow>;
  /** Cancelation reason breakdown */
  cancelationReasonBreakdown: Array<CreatorDashboardChartsCancelationReasonBreakdownRow>;
  /** Churn rate. */
  churnRate: CreatorDashboardChartsDataNumberAvg;
  /** Churned revenue. */
  churnedRevenue: CreatorDashboardChartsDataNumber;
  /** Dispute alerts count. */
  disputeAlertsCount: CreatorDashboardChartsDataNumber;
  /** Dispute fees. */
  disputeFees: CreatorDashboardChartsDataNumber;
  /** Disputes count. */
  disputesCount: CreatorDashboardChartsDataNumber;
  /** Gross revenue. */
  grossVolume: CreatorDashboardChartsDataNumber;
  /** Marketplace fees. */
  marketplaceFees: CreatorDashboardChartsDataNumber;
  /** Marketplace revenue. */
  marketplaceRevenue: CreatorDashboardChartsDataNumber;
  /** Members most recent action */
  membersMostRecentAction: Array<CreatorDashboardChartsMembersMostRecentAction>;
  /** Monthly recurring revenue. */
  mrr: CreatorDashboardChartsDataNumberNoSum;
  /** Net revenue. */
  netVolume: CreatorDashboardChartsDataNumber;
  /** New subscriptions. */
  newMemberships: CreatorDashboardChartsDataNumber;
  /** New users. */
  newUsers: CreatorDashboardChartsDataNumber;
  /** Page visits. */
  pageVisits: CreatorDashboardChartsDataNumber;
  /** Paid active members. */
  paidActiveMembers: CreatorDashboardChartsDataNumberNoSum;
  /** Payments by status. */
  paymentsByStatus: Array<CreatorDashboardChartsPaymentsByStatusRow>;
  /** Sales tax withheld. */
  salesTaxWithheld: CreatorDashboardChartsDataNumber;
  /** Stripe fees. */
  stripeFees: CreatorDashboardChartsDataNumber;
  /** Number of successful payments. */
  successfulPayments: CreatorDashboardChartsDataNumber;
  /** The time zone used for the charts. */
  timeZone: Scalars["String"]["output"];
  /** Top affiliates. */
  topAffiliates: Array<CreatorDashboardChartsTopCustomersRow>;
  /** Top customers. */
  topCustomers: Array<CreatorDashboardChartsTopCustomersRow>;
  /** Total refunded. */
  totalRefunded: CreatorDashboardChartsDataNumber;
  /** Trial conversion rate. */
  trialConversionRate: CreatorDashboardChartsDataNumberAvg;
  /** User growth */
  usersGrowth: CreatorDashboardChartsDataNumberNoSum;
  /** Whop processing fees. */
  whopProcessingFees: CreatorDashboardChartsDataNumber;
};

/** CreatorDashboardChartsCancelationDiscountBreakdownRowType row. */
export type CreatorDashboardChartsCancelationDiscountBreakdownRow = {
  __typename?: "CreatorDashboardChartsCancelationDiscountBreakdownRow";
  /** Identifier. */
  identifier: CreatorDashboardCancelationDiscounts;
  /** User. */
  value: Scalars["Int"]["output"];
};

/** CreatorDashboardChartsCancelationReasonBreakdownRowType row. */
export type CreatorDashboardChartsCancelationReasonBreakdownRow = {
  __typename?: "CreatorDashboardChartsCancelationReasonBreakdownRow";
  /** Identifier. */
  identifier: CancelOptions;
  /** Value. */
  value: Scalars["Number"]["output"];
};

/** Data points with max and min values for a chart. */
export type CreatorDashboardChartsDataNumber = {
  __typename?: "CreatorDashboardChartsDataNumber";
  /** Data points. */
  data: Array<CreatorDashboardChartsDataPointNumber>;
  /** Max value. */
  max: Scalars["Number"]["output"];
  /** Min value. */
  min: Scalars["Number"]["output"];
  /** Sum of all values. */
  sum: Scalars["Number"]["output"];
};

/** Data points with max and min values for a chart. */
export type CreatorDashboardChartsDataNumberAvg = {
  __typename?: "CreatorDashboardChartsDataNumberAvg";
  /** Avg value. */
  avg: Scalars["Number"]["output"];
  /** Data points. */
  data: Array<CreatorDashboardChartsDataPointNumber>;
  /** Max value. */
  max: Scalars["Number"]["output"];
  /** Min value. */
  min: Scalars["Number"]["output"];
};

/** Data points with max and min values for a chart. */
export type CreatorDashboardChartsDataNumberNoSum = {
  __typename?: "CreatorDashboardChartsDataNumberNoSum";
  /** Data points. */
  data: Array<CreatorDashboardChartsDataPointNumber>;
  /** Last value. */
  last: Scalars["Number"]["output"];
  /** Max value. */
  max: Scalars["Number"]["output"];
  /** Min value. */
  min: Scalars["Number"]["output"];
};

/** The data point for charts. */
export type CreatorDashboardChartsDataPointNumber = {
  __typename?: "CreatorDashboardChartsDataPointNumber";
  /** This is the first second of the data point. */
  t: Scalars["Timestamp"]["output"];
  /** Value. */
  v?: Maybe<Scalars["Number"]["output"]>;
};

/** Members most recent action */
export type CreatorDashboardChartsMembersMostRecentAction = {
  __typename?: "CreatorDashboardChartsMembersMostRecentAction";
  /** Most recent action */
  action: MemberMostRecentActions;
  /** Count */
  count: Scalars["Int"]["output"];
};

/** 'Payments by status' table row. */
export type CreatorDashboardChartsPaymentsByStatusRow = {
  __typename?: "CreatorDashboardChartsPaymentsByStatusRow";
  /** Money amount. */
  amount: Scalars["Float"]["output"];
  /** Status name. */
  status: Scalars["String"]["output"];
};

/** Top Customers table row. */
export type CreatorDashboardChartsTopCustomersRow = {
  __typename?: "CreatorDashboardChartsTopCustomersRow";
  /** Sales amount. */
  sales: Scalars["Float"]["output"];
  /** User. */
  user: PublicUser;
};

/** Table names for creator dashboard */
export enum CreatorDashboardExportableTables {
  CancelationReasons = "cancelation_reasons",
  ContentRewardsSubmissions = "content_rewards_submissions",
  Disputes = "disputes",
  Entries = "entries",
  Leads = "leads",
  Members = "members",
  Memberships = "memberships",
  PromoCodes = "promo_codes",
  Receipts = "receipts",
  Resolutions = "resolutions",
  Reviews = "reviews",
  TrackingLinks = "tracking_links",
  UnclaimedMemberships = "unclaimed_memberships",
}

/** The return value of a search. */
export type CreatorDashboardSearch = {
  __typename?: "CreatorDashboardSearch";
  /** The affiliates that match the search. */
  affiliates: Array<Affiliate>;
  /** The companies that match the search. */
  companies: Array<PublicCompany>;
  /** The members that match the search. */
  members: Array<CompanyMember>;
  /** The memberships that match the search. */
  memberships: Array<Membership>;
  /** The navigation items that match the search. */
  navigationItems: Array<NavigationItem>;
  /** The promo codes that match the search. */
  promoCodes: Array<PromoCode>;
  /** The receipts that match the search. */
  receipts: Array<Receipt>;
  /** The resolutions that match the search. */
  resolutions: Array<PublicResolution>;
  /** The reviews that match the search. */
  reviews: Array<Review>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTable = {
  __typename?: "CreatorDashboardTable";
  /** Access Passes */
  accessPasses: AccessPassConnection;
  /** Access Passes Sortable Columns */
  accessPassesSortableColumns: Array<AccessPassesSortableColumns>;
  /** Affiliate Plans */
  affiliatePlans: PlanConnection;
  /** Affiliate Plans Sortable Columns */
  affiliatePlansSortableColumns: Array<AffiliatePlansSortableColumns>;
  /** Affiliate Referral Logs */
  affiliateReferralLogs: AffiliateReferralLogConnection;
  /** Affiliate Referral Logs Sortable Columns */
  affiliateReferralLogsSortableColumns: Array<AffiliateReferralLogsSortableColumns>;
  /** Affiliates */
  affiliates: AffiliateConnection;
  /** Affiliates Sortable Columns */
  affiliatesSortableColumns: Array<AffiliatesSortableColumns>;
  /**
   * API Keys.
   * Roles: owner
   */
  apiKeys: ApiKeyV2Connection;
  /**
   * Audit Logs.
   * Roles: owner, admin
   */
  auditLogs: VersionConnection;
  /** Audit Logs Sortable Columns */
  auditLogsSortableColumns: Array<AuditLogsSortableColumns>;
  /**
   * Authorized User Invites.
   * Roles: owner, admin
   */
  authorizedUserInvites: AuthorizedUserInviteConnection;
  /**
   * Authorized Users.
   * Roles: owner, admin
   */
  authorizedUsers: AuthorizedUserConnection;
  /** Billing History */
  billingHistory: PublicReceiptConnection;
  /** Cancelation Reasons */
  cancelationReasons: MembershipConnection;
  /** Company Collabs */
  companyCollabs: CompanyCollabConnection;
  /** Company Collabs Sortable Columns */
  companyCollabsSortableColumns: Array<CompanyCollabsSortableColumns>;
  /** Content Rewards Submissions */
  contentRewardsSubmissions: SubmissionConnection;
  /** Content Rewards Submissions Sortable Columns */
  contentRewardsSubmissionsSortableColumns: Array<ContentRewardsSubmissionsSortableColumns>;
  /**
   * Credit Transaction Transfers.
   * Roles: owner
   */
  creditTransactionTransfers: CreditTransactionTransferConnection;
  /** Credit Transaction Transfers Sortable Columns */
  creditTransactionTransfersSortableColumns: Array<CreditTransactionTransfersSortableColumns>;
  /** Disputes */
  disputes: DisputeConnection;
  /** Disputes Sortable Columns */
  disputesSortableColumns: Array<DisputesSortableColumns>;
  /** Entries */
  entries: EntryConnection;
  /** Entries Sortable Columns */
  entriesSortableColumns: Array<EntriesSortableColumns>;
  /** Leads */
  leads: LeadConnection;
  /** Leads Sortable Columns */
  leadsSortableColumns: Array<LeadsSortableColumns>;
  /** Members */
  members: CompanyMemberConnection;
  /** Members Sortable Columns */
  membersSortableColumns: Array<MembersSortableColumns>;
  /** Memberships */
  memberships: MembershipConnection;
  /** Memberships Sortable Columns */
  membershipsSortableColumns: Array<MembershipsSortableColumns>;
  /** Plans */
  plans: PlanConnection;
  /** Plans Sortable Columns */
  plansSortableColumns: Array<PlansSortableColumns>;
  /** Promo Codes */
  promoCodes: PromoCodeConnection;
  /** Promo Codes Sortable Columns */
  promoCodesSortableColumns: Array<PromoCodesSortableColumns>;
  /**
   * Receipts.
   * Roles: owner, admin
   */
  receipts: ReceiptConnection;
  /** Receipts Sortable Columns */
  receiptsSortableColumns: Array<ReceiptsSortableColumns>;
  /** Resolutions */
  resolutions: PublicResolutionConnection;
  /** Resolutions Sortable Columns */
  resolutionsSortableColumns: Array<ResolutionsSortableColumns>;
  /** Reviews */
  reviews: ReviewConnection;
  /** Reviews Sortable Columns */
  reviewsSortableColumns: Array<ReviewsSortableColumns>;
  /** Tracking Links */
  trackingLinks: TrackingLinkConnection;
  /** Tracking Links Sortable Columns */
  trackingLinksSortableColumns: Array<TrackingLinksSortableColumns>;
  /** Unclaimed Memberships */
  unclaimedMemberships: MembershipConnection;
  /**
   * Webhooks.
   * Roles: owner
   */
  webhooks: WebhookConnection;
  /**
   * Withdrawals.
   * Roles: owner
   */
  withdrawals: PublicWithdrawalConnection;
  /** Withdrawals Sortable Columns */
  withdrawalsSortableColumns: Array<WithdrawalsSortableColumns>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAffiliatePlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAffiliateReferralLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAffiliatesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableApiKeysArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAuditLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAuthorizedUserInvitesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableAuthorizedUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableBillingHistoryArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableCancelationReasonsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableCompanyCollabsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableContentRewardsSubmissionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableCreditTransactionTransfersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableDisputesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableLeadsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableMembershipsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTablePlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTablePromoCodesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableReceiptsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableTrackingLinksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableUnclaimedMembershipsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableWithdrawalsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Creator Dashboard Table */
export type CreatorDashboardTableExportColumn = {
  __typename?: "CreatorDashboardTableExportColumn";
  /** Name */
  name: Scalars["String"]["output"];
  /** Value */
  value: Scalars["String"]["output"];
};

/** Creator Milestone */
export type CreatorMilestone = {
  __typename?: "CreatorMilestone";
  /** The tier of the creator milestone */
  creatorMilestoneTier: CreatorMilestoneTier;
  /** The current number of the milestone */
  currentNumber: Scalars["Float"]["output"];
  /** The form data associated with the milestone */
  formData?: Maybe<Scalars["JSON"]["output"]>;
  /** The unique identifier of the milestone */
  id: Scalars["ID"]["output"];
  /** The URL of the invoice */
  invoiceUrl?: Maybe<Scalars["String"]["output"]>;
  /** The status of the milestone */
  status: CreatorMilestoneStatuses;
  /** The timestamp when the timer ended */
  timerEndedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The timestamp when the timer started */
  timerStartedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The timestamp when the milestone was unlocked */
  unlockedAt?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** The connection type for CreatorMilestone. */
export type CreatorMilestoneConnection = {
  __typename?: "CreatorMilestoneConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreatorMilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreatorMilestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreatorMilestoneEdge = {
  __typename?: "CreatorMilestoneEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreatorMilestone>;
};

/** Creator Milestone Product */
export type CreatorMilestoneProduct = {
  __typename?: "CreatorMilestoneProduct";
  /** The ID of the product. */
  id: Scalars["ID"]["output"];
  /** The image URL of the product. */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The title of the product. */
  title: Scalars["String"]["output"];
  /** The title of the product variants. */
  variants: Array<CreatorMilestoneProductVariant>;
};

/** Creator Milestone Product Variant */
export type CreatorMilestoneProductVariant = {
  __typename?: "CreatorMilestoneProductVariant";
  /** The ID of the product variant. */
  id: Scalars["ID"]["output"];
  /** The image URL of the product variant. */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The title of the product variant. */
  title: Scalars["String"]["output"];
};

/** The statuses a creator milestone can have */
export enum CreatorMilestoneStatuses {
  /** Claimed */
  Claimed = "claimed",
  /** Expired */
  Expired = "expired",
  /** Fulfilled */
  Fulfilled = "fulfilled",
  /** Locked */
  Locked = "locked",
  /** Rejected */
  Rejected = "rejected",
  /** Unlocked */
  Unlocked = "unlocked",
}

/** Creator Milestone Tier */
export type CreatorMilestoneTier = {
  __typename?: "CreatorMilestoneTier";
  /** The title of the claim modal. */
  claimModalTitle: Scalars["String"]["output"];
  /** The description of the creator milestone tier. */
  description: Scalars["String"]["output"];
  /** The unique ID of the creator milestone tier. */
  id: Scalars["ID"]["output"];
  /** The Shopify product ID of the creator milestone tier. */
  productId?: Maybe<Scalars["ID"]["output"]>;
  /** The description of the reward for the creator milestone tier. */
  rewardDescription: Scalars["String"]["output"];
  /** The title of the reward for the creator milestone tier. */
  rewardTitle: Scalars["String"]["output"];
  /** The unlocked message of the reward for the creator milestone tier. */
  rewardUnlockedMessage: Scalars["String"]["output"];
  /** The target number for the creator milestone tier. */
  targetNumber: Scalars["Float"]["output"];
  /** The target type for the creator milestone tier. */
  targetType?: Maybe<CreatorMilestoneTierTargetTypes>;
  /** The title of the creator milestone tier. */
  title: Scalars["String"]["output"];
};

/** The target types a creator milestone tier can have */
export enum CreatorMilestoneTierTargetTypes {
  /** Gmv */
  Gmv = "gmv",
}

/** The different types of activity for a credit transaction */
export enum CreditTransactionActivityTypes {
  Deductions = "deductions",
  Deposits = "deposits",
  Withdrawals = "withdrawals",
}

/** Values to filter the credits on. */
export type CreditTransactionFilters = {
  /** Filter by activity type */
  activityType?: InputMaybe<CreditTransactionActivityTypes>;
  /** Filter by currency */
  currency?: InputMaybe<Currencies>;
  /** Filter by status */
  statuses?: InputMaybe<Array<CreditTransactionStatuses>>;
};

/** The statuses a credit transaction can have */
export enum CreditTransactionStatuses {
  /** Finalized */
  Finalized = "finalized",
  /** Pending */
  Pending = "pending",
}

/** Credit Transaction Transfer */
export type CreditTransactionTransfer = {
  __typename?: "CreditTransactionTransfer";
  /** The amount of the credit transaction transfer */
  amount: Scalars["Float"]["output"];
  /** The timestamp when the credit transaction transfer was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the credit transaction transfer */
  currency: Currencies;
  /** The recipient of the credit transaction transfer */
  destination: PublicLedgerAccountOwner;
  /** The fee percentage of the credit transaction transfer */
  feePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The unique identifier of the credit transaction transfer */
  id: Scalars["ID"]["output"];
  /** The notes of the credit transaction transfer */
  notes?: Maybe<Scalars["String"]["output"]>;
  /** The sender of the credit transaction transfer */
  origin: PublicLedgerAccountOwner;
  /** The status of the credit transaction transfer */
  status: CreditTransactionTransferStatuses;
  /** The type of the credit transaction transfer */
  transferType: CreditTransactionTransferTypes;
};

/** The connection type for CreditTransactionTransfer. */
export type CreditTransactionTransferConnection = {
  __typename?: "CreditTransactionTransferConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CreditTransactionTransferEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CreditTransactionTransfer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CreditTransactionTransferEdge = {
  __typename?: "CreditTransactionTransferEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CreditTransactionTransfer>;
};

/** The reasons for a credit transaction transfer */
export enum CreditTransactionTransferReasons {
  BountyPayout = "bounty_payout",
  ContentRewardFixedPayout = "content_reward_fixed_payout",
  ContentRewardPayout = "content_reward_payout",
  ContentRewardReturn = "content_reward_return",
  CreatorToCreator = "creator_to_creator",
  CreatorToUser = "creator_to_user",
  PoolTopUp = "pool_top_up",
  TeamMemberPayout = "team_member_payout",
  UserToCreator = "user_to_creator",
  UserToUser = "user_to_user",
  WadminTransferredFunds = "wadmin_transferred_funds",
}

/** The statuses a credit transaction transfer can have */
export enum CreditTransactionTransferStatuses {
  Completed = "completed",
}

/** The type a credit transaction transfer can have */
export enum CreditTransactionTransferTypes {
  /** Admin */
  Admin = "admin",
  /** User */
  User = "user",
}

/** Which columns can be used to sort. */
export enum CreditTransactionTransfersSortableColumns {
  Amount = "amount",
  CreatedAt = "created_at",
}

/** Crypto Wallet */
export type CryptoWallet = {
  __typename?: "CryptoWallet";
  /** The address of the wallet */
  address: Scalars["String"]["output"];
  /** The unique ID for the wallet */
  id: Scalars["ID"]["output"];
  /** The network of the wallet */
  network: CryptoWalletNetworks;
};

/** The connection type for CryptoWallet. */
export type CryptoWalletConnection = {
  __typename?: "CryptoWalletConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CryptoWalletEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CryptoWallet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CryptoWalletEdge = {
  __typename?: "CryptoWalletEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CryptoWallet>;
};

/** The eligible networks for a CryptoWallet */
export enum CryptoWalletNetworks {
  /** Bitcoin */
  Bitcoin = "bitcoin",
  /** Ethereum */
  Ethereum = "ethereum",
  /** Solana */
  Solana = "solana",
}

/** The available currencies on the platform */
export enum Currencies {
  Aed = "aed",
  All = "all",
  Amd = "amd",
  Ape = "ape",
  Ars = "ars",
  Aud = "aud",
  Bam = "bam",
  Bgn = "bgn",
  Bhd = "bhd",
  Bob = "bob",
  Brl = "brl",
  Bsd = "bsd",
  Cad = "cad",
  Chf = "chf",
  Clp = "clp",
  Cop = "cop",
  Crc = "crc",
  Czk = "czk",
  Dkk = "dkk",
  Dop = "dop",
  Dzd = "dzd",
  Egp = "egp",
  Etb = "etb",
  Eth = "eth",
  Eur = "eur",
  Gbp = "gbp",
  Ghs = "ghs",
  Gmd = "gmd",
  Gtq = "gtq",
  Gyd = "gyd",
  Hkd = "hkd",
  Huf = "huf",
  Idr = "idr",
  Ils = "ils",
  Inr = "inr",
  Jmd = "jmd",
  Jod = "jod",
  Jpy = "jpy",
  Kes = "kes",
  Khr = "khr",
  Krw = "krw",
  Kwd = "kwd",
  Lkr = "lkr",
  Mad = "mad",
  Mdl = "mdl",
  Mga = "mga",
  Mkd = "mkd",
  Mnt = "mnt",
  Mop = "mop",
  Mur = "mur",
  Mxn = "mxn",
  Myr = "myr",
  Nad = "nad",
  Ngn = "ngn",
  Nok = "nok",
  Nzd = "nzd",
  Omr = "omr",
  Pen = "pen",
  Php = "php",
  Pkr = "pkr",
  Pln = "pln",
  Pyg = "pyg",
  Qar = "qar",
  Ron = "ron",
  Rsd = "rsd",
  Rub = "rub",
  Rwf = "rwf",
  Sar = "sar",
  Sek = "sek",
  Sgd = "sgd",
  Thb = "thb",
  Tnd = "tnd",
  Try = "try",
  Ttd = "ttd",
  Twd = "twd",
  Tzs = "tzs",
  Usd = "usd",
  Uyu = "uyu",
  Uzs = "uzs",
  Vnd = "vnd",
  Xcd = "xcd",
  Xof = "xof",
  Zar = "zar",
}

/** Cursor type for pagination */
export type Cursor = {
  __typename?: "Cursor";
  /** Entity ID of the last entity in the collection */
  entityId: Scalars["ID"]["output"];
  /** Updated at of the last entity in the collection */
  updatedAt: Scalars["BigInt"]["output"];
};

/** The different types of custom CTAs that can be selected. */
export enum CustomCtas {
  /** Apply Now */
  ApplyNow = "apply_now",
  /** Call Now */
  CallNow = "call_now",
  /** Contact Us */
  ContactUs = "contact_us",
  /** Donate Now */
  DonateNow = "donate_now",
  /** Get Access */
  GetAccess = "get_access",
  /** Get Offer */
  GetOffer = "get_offer",
  /** Join */
  Join = "join",
  /** Order Now */
  OrderNow = "order_now",
  /** Purchase */
  Purchase = "purchase",
  /** Shop Now */
  ShopNow = "shop_now",
  /** Sign Up */
  SignUp = "sign_up",
  /** Subscribe */
  Subscribe = "subscribe",
}

/** An object representing a custom field for a plan. */
export type CustomField = {
  __typename?: "CustomField";
  /** What type of input field to use. */
  fieldType: CustomFieldTypes;
  /** The internal ID of the given custom field */
  id: Scalars["ID"]["output"];
  /** The title/header of the custom field. */
  name: Scalars["String"]["output"];
  /** How the custom field should be ordered when rendered on the checkout page. */
  order?: Maybe<Scalars["Int"]["output"]>;
  /** An example response displayed in the input field. */
  placeholder?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the custom field is required. */
  required: Scalars["Boolean"]["output"];
};

export type CustomFieldInput = {
  /** The type of the custom field. */
  fieldType: CustomFieldTypes;
  /** The ID of the custom field (if being updated) */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The name of the custom field. */
  name: Scalars["String"]["input"];
  /** The order of the field. */
  order?: InputMaybe<Scalars["Int"]["input"]>;
  /** The placeholder value of the field. */
  placeholder?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the field is required. */
  required?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The response from a custom field on checkout */
export type CustomFieldResponse = {
  __typename?: "CustomFieldResponse";
  /** The response a user gave to the specific question or field. */
  answer: Scalars["String"]["output"];
  /** The ID of the custom field item */
  id: Scalars["ID"]["output"];
  /** The question asked by the custom field */
  question: Scalars["String"]["output"];
};

/** The connection type for CustomFieldResponse. */
export type CustomFieldResponseConnection = {
  __typename?: "CustomFieldResponseConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CustomFieldResponseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CustomFieldResponse>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type CustomFieldResponseEdge = {
  __typename?: "CustomFieldResponseEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<CustomFieldResponse>;
};

/** The response to a custom field for a waitlist plan */
export type CustomFieldResponseInput = {
  /** The value of the user's response to this field */
  answer?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the custom field this response is to */
  customFieldId: Scalars["ID"]["input"];
};

/** The type of the custom field. */
export enum CustomFieldTypes {
  /** Text */
  Text = "text",
}

/** A custom experience with no additional properties */
export type CustomPrivate = ExperienceInterface & {
  __typename?: "CustomPrivate";
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The access passes that offer access to this experience */
  accessPasses: Array<AccessPass>;
  /** The interface of the experience */
  app?: Maybe<App>;
  /** A short description of the experience */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The type of experience */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether to hide the experience if it is not accessible */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The ID of the experience */
  id: Scalars["ID"]["output"];
  /** The image for the experience */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The name of the experience */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed: Scalars["Boolean"]["output"];
  /** Whether or not experience content is shown in the explore page */
  showExploreContent: Scalars["Boolean"]["output"];
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<Plan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
};

/** A custom experience with no additional properties */
export type CustomPrivateImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** A custom experience with no additional properties */
export type CustomPublic = PublicExperienceInterface & {
  __typename?: "CustomPublic";
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The chat feed IDs associated with this experience */
  chatFeedIds: Array<Scalars["ID"]["output"]>;
  /** A written description of what the experience offers */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The type of the experience */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The features enabled for the experience */
  features: Array<Scalars["String"]["output"]>;
  /** Whether to hide the experience if it is not accessible */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The ID of the experience */
  id: Scalars["ID"]["output"];
  /** The iframe link for the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface */
  imageSrcset?: Maybe<ImgSrcset>;
  /** Whether the experience is accessible (attached to at least one product) */
  isAccessible: Scalars["Boolean"]["output"];
  /** Whether or not the experience has been claimed given the membership in the current context. If null, there is no membership in the context. */
  isClaimed?: Maybe<Scalars["Boolean"]["output"]>;
  /** The name of the experience */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The app */
  publicApp?: Maybe<PublicApp>;
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The target link to request */
  targetLink?: Maybe<Scalars["String"]["output"]>;
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<PublicPlan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
};

/** A custom experience with no additional properties */
export type CustomPublicImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** A custom experience with no additional properties */
export type CustomPublicTargetLinkArgs = {
  appViewType: AppViewTypes;
  mode: ExperienceLinkModes;
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of CustomerCreateResolution */
export type CustomerCreateResolutionInput = {
  /** Any attachments for this resolution. */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The input from the customer on why they are claiming. */
  details: Scalars["String"]["input"];
  /**
   * Files you want to add as evidence.
   * @deprecated Use attachments instead
   */
  evidenceFiles?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /** The resource to make the report for. */
  issue: ResolutionIssueTypes;
  /** The ID of the receipt that is being claimed. */
  receiptId: Scalars["ID"]["input"];
};

/** Autogenerated input type of CustomerRespondResolution */
export type CustomerRespondResolutionInput = {
  /** Any attachments for this response. */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The response details from the merchant. */
  details?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Any evidence you wish you upload with the response.
   * @deprecated Use attachments instead
   */
  evidenceFiles?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /** The ID of the resolution to update. */
  resolutionId: Scalars["ID"]["input"];
  /** What action the customer is responding with. */
  responseAction: ResolutionCustomerResponses;
};

/** A default avatar for the Whop platform */
export type DefaultAvatar = {
  __typename?: "DefaultAvatar";
  /** The 2x quality source URL for the image */
  doubleUrl: Scalars["String"]["output"];
  /** The identifier for the avatar */
  identifier: Scalars["String"]["output"];
  /** The source URL for the image */
  url: Scalars["String"]["output"];
};

/** Autogenerated input type of DeleteAccessPassFaq */
export type DeleteAccessPassFaqInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the FAQ that is being deleted. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAccessPassImage */
export type DeleteAccessPassImageInput = {
  /** The internal ID of the access pass to remove the image from. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the image that is being deleted. */
  imageId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAccessPass */
export type DeleteAccessPassInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID (tag) of the access pass to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAccessPassSocialLink */
export type DeleteAccessPassSocialLinkInput = {
  /** The ID of the Access Pass this social link belongs to */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the social link */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAffiliateForPlan */
export type DeleteAffiliateForPlanInput = {
  /** The internal ID of the affiliate to delete. */
  affiliateId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the plan to delete the custom rate for. */
  planId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAffiliate */
export type DeleteAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the affiliate to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAuthorizedUser */
export type DeleteAuthorizedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the authorized user to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteAuthorizedUserInvite */
export type DeleteAuthorizedUserInviteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the authorized user invite to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteCoinbaseAccount */
export type DeleteCoinbaseAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the account to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteCompany */
export type DeleteCompanyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of DeleteCompanyMutedUser */
export type DeleteCompanyMutedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user to unmute */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteCryptoWallet */
export type DeleteCryptoWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the crypto wallet to unlink */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteExperience */
export type DeleteExperienceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the experience to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteFeedWebhook */
export type DeleteFeedWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the webhook to delete */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteLedgerConnectedAccount */
export type DeleteLedgerConnectedAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteMemberNote */
export type DeleteMemberNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID member note to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteMyAccount */
export type DeleteMyAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of DeletePaymentMethod */
export type DeletePaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this payment method belongs to. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the payment method to delete */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeletePaymentToken */
export type DeletePaymentTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this payment token belongs to. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the payment token to delete */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeletePaypalAccount */
export type DeletePaypalAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the account to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeletePlan */
export type DeletePlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal Id of the plan to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteProductHighlight */
export type DeleteProductHighlightInput = {
  /** The ID of the access pass. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The type of this highlight.
   * @deprecated Use productHighlightId instead.
   */
  highlightType?: InputMaybe<ProductHighlightTypes>;
  /** The ID of the product highlight to delete. */
  productHighlightId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of DeletePromoCode */
export type DeletePromoCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the promo code to archive. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteRecording */
export type DeleteRecordingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed id of the livestream to delete the recording */
  feedId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteReview */
export type DeleteReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the review to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteStripeAccountV2 */
export type DeleteStripeAccountV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the stripe account to delete. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteTrackingLink */
export type DeleteTrackingLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the tracking link */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteUserChatMessages */
export type DeleteUserChatMessagesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the chat feed to delete messages from */
  feedId: Scalars["ID"]["input"];
  /** The ID of the user whose messages will be deleted */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteUserSocialLink */
export type DeleteUserSocialLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the social link */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of DeleteWebhook */
export type DeleteWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the webhook to delete. */
  id: Scalars["ID"]["input"];
};

/** The type of device a user can use to access Whop */
export enum Device {
  Android = "android",
  DesktopWeb = "desktop_web",
  Ios = "ios",
  MobileWeb = "mobile_web",
}

/** The state of a user's notifications for a direct message */
export type DirectMessageNotificationBadge = {
  __typename?: "DirectMessageNotificationBadge";
  /** The ID of the direct messages */
  directMessageId: Scalars["ID"]["output"];
  /** Whether the user has unread notifications for this direct message */
  hasUnread: Scalars["Boolean"]["output"];
};

/** The connection type for DirectMessageNotificationBadge. */
export type DirectMessageNotificationBadgeConnection = {
  __typename?: "DirectMessageNotificationBadgeConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DirectMessageNotificationBadgeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DirectMessageNotificationBadge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DirectMessageNotificationBadgeEdge = {
  __typename?: "DirectMessageNotificationBadgeEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DirectMessageNotificationBadge>;
};

/** The status of the direct message. */
export enum DirectMessageStatus {
  /** Accepted */
  Accepted = "accepted",
  /** Hidden */
  Hidden = "hidden",
  /** Requested */
  Requested = "requested",
}

/** The return value of a search. */
export type DirectMessagesUserSearch = {
  __typename?: "DirectMessagesUserSearch";
  /** The users that match the search. */
  users: Array<PublicProfileUser>;
};

/** The direct upload response */
export type DirectUpload = {
  __typename?: "DirectUpload";
  /** The headers for the upload */
  headers: Scalars["JSON"]["output"];
  /** The signed ID of the blob */
  id: Scalars["ID"]["output"];
  /** The size of each part of the multipart upload */
  multipartChunkSize?: Maybe<Scalars["BigInt"]["output"]>;
  /** The multipart upload ID */
  multipartUploadId?: Maybe<Scalars["String"]["output"]>;
  /** The URLs for the parts of the multipart upload */
  multipartUploadUrls?: Maybe<Array<MultipartUrl>>;
  /** The URL to upload the blob */
  uploadUrl?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of DirectUpload */
export type DirectUploadInput = {
  /** The size of the file in bytes */
  byteSize?: InputMaybe<Scalars["Int"]["input"]>;
  /** The size of the file in bytes */
  byteSizeV2?: InputMaybe<Scalars["BigInt"]["input"]>;
  /** The checksum of the file */
  checksum: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The content type of the file */
  contentType?: InputMaybe<Scalars["String"]["input"]>;
  /** The filename of the file */
  filename: Scalars["String"]["input"];
  /** The metadata of the file */
  metadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /** Whether or not to use multipart upload. The file must be larger than 5MB */
  multipart?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The type of record to attach the file to */
  record: AttachableRecords;
};

/** The direction of the sort. */
export enum Direction {
  Asc = "asc",
  Desc = "desc",
}

/** Autogenerated input type of DisableTwoFactor */
export type DisableTwoFactorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of DisconnectWallet */
export type DisconnectWalletInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The wallet address to disconnect */
  walletAddress: Scalars["String"]["input"];
};

/** An object representing a Discord account tied to a user. */
export type DiscordAccount = {
  __typename?: "DiscordAccount";
  /** Whether or not this is the user's default Discord account */
  defaultAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** The Discord Account ID of the Discord User. */
  discordAccountId: Scalars["String"]["output"];
  /** The internal database ID of the Discord account. */
  id: Scalars["ID"]["output"];
  /** Their profile pic URL */
  imageSrcset?: Maybe<ImgSrcset>;
  /**
   * Their profile pic URL
   * @deprecated Use imageSrcset instead.
   */
  imageUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** Whether or not the user needs to reauthorize their Discord account. */
  reauthorizationRequired: Scalars["Boolean"]["output"];
  /** The username of the Discord User. */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** An object representing a Discord account tied to a user. */
export type DiscordAccountImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<DiscordAccountImageStyles>;
};

/** The connection type for DiscordAccount. */
export type DiscordAccountConnection = {
  __typename?: "DiscordAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscordAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscordAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscordAccountEdge = {
  __typename?: "DiscordAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscordAccount>;
};

/** Image styles for discord_account. */
export enum DiscordAccountImageStyles {
  S16 = "s16",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S64 = "s64",
  S80 = "s80",
  S128 = "s128",
  S180 = "s180",
}

/** An object representing a discount. */
export type Discount = {
  __typename?: "Discount";
  /** The timestamp of when the discount was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp of when the discount was deleted. */
  discardedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The timestamp of when the discount was ended. If null, the discount applies forever. */
  endedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the promo. */
  id: Scalars["ID"]["output"];
  /** The promo code associated with the discount. */
  promoCode: PromoCode;
  /** The timestamp of when the discount was started. */
  startedAt: Scalars["Timestamp"]["output"];
  /** The timestamp of when the discount was updated. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** A bounty on the discover page */
export type DiscoverBounty = DiscoverEarningOpportunityInterface & {
  __typename?: "DiscoverBounty";
  /** The access passes associated with this bounty */
  accessPasses: PublicAccessPassConnection;
  /** Whether the bounty supports Instagram platform social posts */
  allowInstagram: Scalars["Boolean"]["output"];
  /** Whether the bounty supports TikTok platform social posts */
  allowTiktok: Scalars["Boolean"]["output"];
  /** Whether the bounty supports X platform social posts */
  allowX: Scalars["Boolean"]["output"];
  /** Whether the bounty supports YouTube platform social posts */
  allowYoutube: Scalars["Boolean"]["output"];
  /** The base unit amount for the bounty */
  baseUnitAmount: Scalars["Int"]["output"];
  /** The number of submissions for the bounty */
  bountySubmissionsCount: Scalars["Int"]["output"];
  /** The budget amount for the bounty */
  budgetAmount?: Maybe<Scalars["Float"]["output"]>;
  /** When the bounty was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the bounty */
  currency: Currencies;
  /** The description of the bounty */
  description: Scalars["String"]["output"];
  /** The status of the bounty */
  discoverStatus: DiscoverStatuses;
  /** The experience for this earning opportunity */
  experience: PublicExperience;
  /** The file attachments for the bounty */
  fileAttachments: FileAttachmentConnection;
  /** The internal ID of the bounty */
  id: Scalars["ID"]["output"];
  /** The amount of the reward for the bounty */
  rewardPerUnitAmount: Scalars["Float"]["output"];
  /** The unit of the reward for the bounty */
  rewardUnit: RewardUnits;
  /** The status of the bounty */
  status: Statuses;
  /** The title of the bounty */
  title: Scalars["String"]["output"];
  /**
   * The total amount available for the bounty
   * @deprecated Use rewardPerUnitAmount instead
   */
  totalAvailable: Scalars["Float"]["output"];
  /** The total amount paid out for this bounty in dollars */
  totalPaid: Scalars["Float"]["output"];
  /** The user of who created the bounty */
  user?: Maybe<PublicProfileUser>;
};

/** A bounty on the discover page */
export type DiscoverBountyAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A bounty on the discover page */
export type DiscoverBountyFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A content reward on the discover page */
export type DiscoverContentRewardsCampaign =
  DiscoverEarningOpportunityInterface & {
    __typename?: "DiscoverContentRewardsCampaign";
    /** Whether to allow Instagram submissions */
    allowInstagram: Scalars["Boolean"]["output"];
    /** Whether to allow TikTok submissions */
    allowTiktok: Scalars["Boolean"]["output"];
    /** Whether to allow X submissions */
    allowX: Scalars["Boolean"]["output"];
    /** Whether to allow YouTube submissions */
    allowYoutube: Scalars["Boolean"]["output"];
    /** The assets associated with the campaign */
    assets: AssetConnection;
    /** The attachments for this campaign */
    attachments: Array<AttachmentInterface>;
    /** The number of hours after which submissions get auto-approved */
    autoApproveSubmissionsInHours?: Maybe<Scalars["Int"]["output"]>;
    /** Which category to assign */
    category: ContentRewardsCategory;
    /** Which content type is accepted */
    contentType: ContentRewardsContentType;
    /** When this campaign was created */
    createdAt: Scalars["Timestamp"]["output"];
    /** Which currency should be used for payments */
    currency: Currencies;
    /** The experience for this earning opportunity */
    experience: PublicExperience;
    /** When this campaign ends */
    expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
    /** The file attachments for the campaign */
    fileAttachments: FileAttachmentConnection;
    /** Whether submissions to this campaign require file uploads */
    fileUploadRequired: Scalars["Boolean"]["output"];
    /** The fixed amount that will be paid out per approved submission */
    fixedRewardPerSubmission?: Maybe<Scalars["Float"]["output"]>;
    /** ID of the campaign */
    id: Scalars["ID"]["output"];
    /** The maximum amount that can be paid out per submission */
    maxPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
    /** The minimum amount owed before a submission is eligible for payouts */
    minPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
    /** URL that must be present in the submitter's social account bio */
    requiredCreatorBioLink?: Maybe<Scalars["String"]["output"]>;
    /** Text patterns that must be present in the submitted post description */
    requiredDescriptionText?: Maybe<Array<Scalars["String"]["output"]>>;
    /** Instagram audio that must be used in the submissions */
    requiredInstagramAudio?: Maybe<Scalars["String"]["output"]>;
    /** TikTok audio that must be used in the submissions */
    requiredTiktokAudio?: Maybe<Scalars["String"]["output"]>;
    /** An array of requirements that the user must complete to collect a reward */
    requirements: Array<Scalars["String"]["output"]>;
    /** The amount that a user should be rewarded per thousand views submitted */
    rewardRatePerThousandViews: Scalars["Float"]["output"];
    /** The status of the campaign */
    status: ContentRewardsCampaignStatus;
    /** The title of this campaign */
    title: Scalars["String"]["output"];
    /** The total amount that will be paid out for this campaign */
    totalBudget: Scalars["Float"]["output"];
    /** The total amount that has been paid out for this campaign in the campaign's currency. */
    totalPaid: Scalars["Float"]["output"];
    /** The total amount that has been paid out for this campaign, normalized to USD. */
    totalPaidInUsd: Scalars["Float"]["output"];
    /** Total number of views approved submissions generated for this campaign */
    totalViewCount: Scalars["Int"]["output"];
  };

/** A content reward on the discover page */
export type DiscoverContentRewardsCampaignAssetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A content reward on the discover page */
export type DiscoverContentRewardsCampaignFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A public content reward submission object */
export type DiscoverContentRewardsSubmissionType = {
  __typename?: "DiscoverContentRewardsSubmissionType";
  /** The attachments for this submission */
  attachments: Array<AttachmentInterface>;
  /** The campaign associated with this submission */
  campaign: PublicCampaign;
  /** Timestamp of when the submission was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the submission */
  id: Scalars["ID"]["output"];
  /** The platform to create this submission for */
  platform: ContentRewardsPlatform;
  /** The text content of the post on the platform */
  platformPostTextContent?: Maybe<Scalars["String"]["output"]>;
  /** The title of the post on the platform */
  platformPostTitle?: Maybe<Scalars["String"]["output"]>;
  /** The total amount that has been paid out for this campaign in the campaign's currency. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign, normalized to USD. */
  totalPaidInUsd: Scalars["Float"]["output"];
  /** The total view count for this submission */
  totalViewCount: Scalars["Int"]["output"];
  /** The user who created the submission */
  user: PublicProfileUser;
};

/** The connection type for DiscoverContentRewardsSubmissionType. */
export type DiscoverContentRewardsSubmissionTypeConnection = {
  __typename?: "DiscoverContentRewardsSubmissionTypeConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscoverContentRewardsSubmissionTypeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscoverContentRewardsSubmissionType>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscoverContentRewardsSubmissionTypeEdge = {
  __typename?: "DiscoverContentRewardsSubmissionTypeEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscoverContentRewardsSubmissionType>;
};

/** Values to filter content rewards submissions on */
export type DiscoverContentRewardsSubmissionsFilters = {
  /** The type of attachment required on the submission */
  attachmentType?: InputMaybe<FileAttachmentTypes>;
  /** The campaign ID to filter by */
  campaignId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The status of the campaign */
  campaignStatus?: InputMaybe<ContentRewardsCampaignStatus>;
  /** The direction to order by */
  direction?: InputMaybe<Direction>;
  /** The order to sort the results by */
  order?: InputMaybe<DiscoverContentRewardsSubmissionsOrder>;
};

/** The ordering options for content rewards submissions */
export enum DiscoverContentRewardsSubmissionsOrder {
  CreatedAt = "created_at",
  TotalPaid = "total_paid",
  TotalViewCount = "total_view_count",
  ViewsChangeCount = "views_change_count",
}

/** A module that appears on Discovery surfaces. */
export type DiscoverEarningOpportunityInterface = {
  /** The experience for this earning opportunity */
  experience: PublicExperience;
};

/** The type of earning opportunities on discover. */
export enum DiscoverEarningOpportunityTypes {
  Bounty = "bounty",
  ContentRewards = "content_rewards",
}

/** The discover rating options */
export enum DiscoverRating {
  Downvote = "downvote",
  Share = "share",
  Upvote = "upvote",
}

/** The available discover statuses to choose from. */
export enum DiscoverStatuses {
  /** Live Discover */
  LiveDiscover = "live_discover",
  /** Not Available */
  NotAvailable = "not_available",
}

/** A category that describes what the whop belongs to. */
export type DiscoveryCategory = {
  __typename?: "DiscoveryCategory";
  /** The tags for the category. */
  discoveryTags: DiscoveryTagConnection;
  /** An ID for the category. */
  id: Scalars["ID"]["output"];
  /** The name of the category. */
  name: Scalars["String"]["output"];
  /** The route of the category. */
  route: Scalars["String"]["output"];
};

/** A category that describes what the whop belongs to. */
export type DiscoveryCategoryDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for DiscoveryCategory. */
export type DiscoveryCategoryConnection = {
  __typename?: "DiscoveryCategoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscoveryCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscoveryCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscoveryCategoryEdge = {
  __typename?: "DiscoveryCategoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscoveryCategory>;
};

/** An object representing a collection of products used in Discovery surfaces. */
export type DiscoveryCollection = {
  __typename?: "DiscoveryCollection";
  /** Slug used to link to the collection. */
  slug: Scalars["String"]["output"];
  /** Title of the collection. */
  title: Scalars["String"]["output"];
};

/** A content card for the discovery app */
export type DiscoveryContentCard = {
  __typename?: "DiscoveryContentCard";
  /** The text of the call to action button */
  ctaText: Scalars["String"]["output"];
  /** The description of the content card */
  description: Scalars["String"]["output"];
  /** The URL of the file with specific size. */
  imageSrcset: ImgSrcset;
  /** The title of the content card */
  title: Scalars["String"]["output"];
  /** The URL of the content card */
  url: Scalars["String"]["output"];
};

/** A content card for the discovery app */
export type DiscoveryContentCardImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** A module that appears on Discovery surfaces. */
export type DiscoveryModuleInterface = {
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** The connection type for DiscoveryModuleInterface. */
export type DiscoveryModuleInterfaceConnection = {
  __typename?: "DiscoveryModuleInterfaceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscoveryModuleInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscoveryModuleInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscoveryModuleInterfaceEdge = {
  __typename?: "DiscoveryModuleInterfaceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscoveryModuleInterface>;
};

/** The different types of discovery screen modules. */
export enum DiscoveryModuleTypes {
  /** Horizontal List */
  HorizontalList = "horizontal_list",
  /** Large Card */
  LargeCard = "large_card",
  /** Live Stack */
  LiveStack = "live_stack",
  /** More Tags */
  MoreTags = "more_tags",
  /** Ranked List */
  RankedList = "ranked_list",
  /** Three Item List */
  ThreeItemList = "three_item_list",
}

/** The return value of a search. */
export type DiscoverySearch = {
  __typename?: "DiscoverySearch";
  /** The access passes that match the search. */
  accessPasses: Array<PublicAccessPass>;
  /** The id of the search */
  id: Scalars["ID"]["output"];
  /** The users that match the search. */
  users: Array<PublicProfileUser>;
};

/** An object representing tag used to aid discovery. */
export type DiscoveryTag = {
  __typename?: "DiscoveryTag";
  /** The number of access passes tagged w/ this */
  accessPassCount: Scalars["Int"]["output"];
  /** The number of discoverable access passes tagged w/ this */
  discoverableAccessPassCount: Scalars["Int"]["output"];
  /** The number of page views for discoverable access passes tagged w/ this */
  discoverablePageViews30Days: Scalars["Int"]["output"];
  /** The USD GMV for discoverable access passes tagged w/ this */
  discoverableUsdGmv30Days: Scalars["Float"]["output"];
  /** The discovery category this tag belongs to. */
  discoveryCategory?: Maybe<DiscoveryCategory>;
  /** The ID for this record. */
  id: Scalars["ID"]["output"];
  /** Label to display to the user. */
  label: Scalars["String"]["output"];
  /** The number of page views for access passes tagged w/ this */
  pageViews30Days: Scalars["Int"]["output"];
  /** When the tag is personalized to the user it will include the relevancy score. */
  relevance?: Maybe<Scalars["Float"]["output"]>;
  /** The slug for the tag. */
  slug: Scalars["String"]["output"];
  /** The USD GMV for access passes tagged w/ this */
  usdGmv30Days: Scalars["Float"]["output"];
  /** The number of users interested in the tag */
  usersInterestedCount: Scalars["Int"]["output"];
};

/** The connection type for DiscoveryTag. */
export type DiscoveryTagConnection = {
  __typename?: "DiscoveryTagConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscoveryTagEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscoveryTag>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DiscoveryTagEdge = {
  __typename?: "DiscoveryTagEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<DiscoveryTag>;
};

/** An object representing a dispute against a company. */
export type Dispute = {
  __typename?: "Dispute";
  /** An IP access log for the user from Whop. */
  accessActivityLog?: Maybe<Scalars["String"]["output"]>;
  /** The amount of the dispute (formatted). */
  amount: Scalars["Float"]["output"];
  /** The billing address of the user from their payment details. */
  billingAddress?: Maybe<Scalars["String"]["output"]>;
  /**
   * A file containing the cancellation policy from the company.
   * @deprecated Use cancellationPolicyAttachment instead
   */
  cancellationPolicy?: Maybe<Scalars["File"]["output"]>;
  /** The cancellation policy for this dispute */
  cancellationPolicyAttachment?: Maybe<AttachmentInterface>;
  /** A cancellation policy disclosure from the company. */
  cancellationPolicyDisclosure?: Maybe<Scalars["String"]["output"]>;
  /**
   * A file name for the cancellation policy from the company.
   * @deprecated Use cancellationPolicyAttachment instead
   */
  cancellationPolicyFileName?: Maybe<Scalars["String"]["output"]>;
  /** When it was made. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The currency of the dispute. */
  currency: Currencies;
  /**
   * A file containing evidence of the customer messaging the company or using the product.
   * @deprecated Use customerCommunicationAttachment instead
   */
  customerCommunication?: Maybe<Scalars["File"]["output"]>;
  /** The customer communication for this dispute */
  customerCommunicationAttachment?: Maybe<AttachmentInterface>;
  /**
   * A file name for the customer communication for this dispute.
   * @deprecated Use customerCommunicationAttachment instead
   */
  customerCommunicationFileName?: Maybe<Scalars["String"]["output"]>;
  /** The email of the customer from their payment details. */
  customerEmailAddress?: Maybe<Scalars["String"]["output"]>;
  /** The name of the customer from their payment details. */
  customerName?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the dispute data can be edited. */
  editable?: Maybe<Scalars["Boolean"]["output"]>;
  /** The internal ID of the dispute. */
  id: Scalars["ID"]["output"];
  /** The whop user (if available) who made the dispute. */
  member?: Maybe<Member>;
  /** The last date the dispute is allow to be submitted by. */
  needsResponseBy?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Additional notes the company chooses to submit regarding the dispute. */
  notes?: Maybe<Scalars["String"]["output"]>;
  /** The description of the product from the company. */
  productDescription?: Maybe<Scalars["String"]["output"]>;
  /** The reason for the dispute */
  reason?: Maybe<Scalars["String"]["output"]>;
  /** The receipt that got disputed */
  receipt?: Maybe<Receipt>;
  /**
   * A file containing the refund policy from the company.
   * @deprecated Use refundPolicyAttachment instead
   */
  refundPolicy?: Maybe<Scalars["File"]["output"]>;
  /** The refund policy for this dispute */
  refundPolicyAttachment?: Maybe<AttachmentInterface>;
  /** A refund policy disclosure from the company. */
  refundPolicyDisclosure?: Maybe<Scalars["String"]["output"]>;
  /**
   * A file name for the refund policy from the company.
   * @deprecated Use refundPolicyAttachment instead
   */
  refundPolicyFileName?: Maybe<Scalars["String"]["output"]>;
  /** A description on why the refund is being refused by the company. */
  refundRefusalExplanation?: Maybe<Scalars["String"]["output"]>;
  /** When the product was delivered by the company. */
  serviceDate?: Maybe<Scalars["String"]["output"]>;
  /** The status of the dispute (mimics stripe's dispute status). */
  status: DisputeStatuses;
  /** An attachment that did not fit into the other categories */
  uncategorizedAttachment?: Maybe<AttachmentInterface>;
  /**
   * A file that was uploaded but not categorized.
   * @deprecated Use uncategorizedAttachment instead
   */
  uncategorizedFile?: Maybe<Scalars["File"]["output"]>;
};

/** The connection type for Dispute. */
export type DisputeConnection = {
  __typename?: "DisputeConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DisputeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Dispute>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type DisputeEdge = {
  __typename?: "DisputeEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Dispute>;
};

/** The dispute risk levels of a ledger account, derived from the ledger account stat */
export enum DisputeRiskLevels {
  /** At Risk */
  AtRisk = "at_risk",
  /** High */
  High = "high",
  /** Low */
  Low = "low",
  /** Medium */
  Medium = "medium",
  /** Removal */
  Removal = "removal",
}

/** The possible statuses of a dispute */
export enum DisputeStatuses {
  /** Closed */
  Closed = "closed",
  /** Lost */
  Lost = "lost",
  /** Needs Response */
  NeedsResponse = "needs_response",
  /** Other */
  Other = "other",
  /** Under Review */
  UnderReview = "under_review",
  /** Warning Closed */
  WarningClosed = "warning_closed",
  /** Warning Needs Response */
  WarningNeedsResponse = "warning_needs_response",
  /** Warning Under Review */
  WarningUnderReview = "warning_under_review",
  /** Won */
  Won = "won",
}

/** Which columns can be used to sort. */
export enum DisputesSortableColumns {
  Amount = "amount",
  CreatedAt = "created_at",
  FinalAmount = "final_amount",
  Id = "id",
  NeedsResponseBy = "needs_response_by",
}

/** Response type for DM channels query */
export type DmsChannelsResponse = {
  __typename?: "DmsChannelsResponse";
  /** List of members for all returned channels */
  feedMembers: Array<DmsFeedMember>;
  /** List of DM channels */
  feeds: Array<DmsFeed>;
  /** List of most recent posts for all returned channels */
  posts: Array<DmsPost>;
  /** List of unique users involved in the returned channels */
  users: Array<PublicProfileUser>;
};

/** Sort options for DM channels */
export enum DmsChannelsSortTypes {
  CreatedAt = "created_at",
  CustomName = "custom_name",
  LastPostSentAt = "last_post_sent_at",
  Query = "query",
}

/** Represents a DM channel */
export type DmsFeed = BaseEntityInterface & {
  __typename?: "DmsFeed";
  /** The type of the channel */
  channelType?: Maybe<Scalars["String"]["output"]>;
  /** The collection identifier for the channel */
  collectionIdentifier?: Maybe<Scalars["String"]["output"]>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The custom name of the DM channel, if any */
  customName?: Maybe<Scalars["String"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The webhooks for the feed */
  webhooks: FeedWebhookConnection;
};

/** Represents a DM channel */
export type DmsFeedWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Response type for DM feed data query */
export type DmsFeedDataResponse = {
  __typename?: "DmsFeedDataResponse";
  /** The DM channel */
  feed: DmsFeed;
  /** List of members for the feed */
  feedMembers: Array<DmsFeedMember>;
  /** List of recent posts */
  posts: Array<DmsPost>;
  /** List of unique users involved in the returned channels */
  users: Array<PublicProfileUser>;
};

/** The input to create a DMs feed */
export type DmsFeedInput = {
  /** The collection ID for the feed */
  collectionIdentifier?: InputMaybe<Scalars["ID"]["input"]>;
  /** The custom name for the feed */
  customName?: InputMaybe<Scalars["String"]["input"]>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Represents a member of a DM channel */
export type DmsFeedMember = BaseEntityInterface & {
  __typename?: "DmsFeedMember";
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The type of the card */
  entityType: EntityTypes;
  /** The ID of the DM channel */
  feedId: Scalars["ID"]["output"];
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** Timestamp when the member last viewed the channel (in milliseconds since Unix epoch) */
  lastViewedAt?: Maybe<Scalars["BigInt"]["output"]>;
  /** The notification preference for this member (all, mentions, none) */
  notificationPreference: DmsFeedMemberNotificationPreferences;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The status of the membership (requested, accepted, rejected) */
  status: DmsFeedMemberStatuses;
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The ID of the user who is a member of the channel */
  userId: Scalars["ID"]["output"];
};

/** Input for a DMs feed member */
export type DmsFeedMemberInput = {
  /** The ID of the DM channel */
  feedId: Scalars["ID"]["input"];
  /** The unique identifier for the post */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Timestamp when the member last viewed the channel (in milliseconds since Unix epoch) */
  lastViewedAt?: InputMaybe<Scalars["Float"]["input"]>;
  /** The notification preference for this member (all, mentions, none) */
  notificationPreference?: InputMaybe<DmsFeedMemberNotificationPreferences>;
  /** The status of the member (active, inactive, banned) */
  status?: InputMaybe<DmsFeedMemberStatuses>;
  /** The ID of the user */
  userId: Scalars["ID"]["input"];
};

/** The notification preferences for a DMs feed member */
export enum DmsFeedMemberNotificationPreferences {
  /** All */
  All = "all",
  /** Mentions */
  Mentions = "mentions",
  /** None */
  None = "none",
}

/**  The statuses of a DMs feed member */
export enum DmsFeedMemberStatuses {
  /** Accepted */
  Accepted = "accepted",
  /** Hidden */
  Hidden = "hidden",
  /** Requested */
  Requested = "requested",
}

/**  The types of DMs feeds */
export enum DmsFeedTypes {
  DirectMessage = "direct_message",
  GroupChat = "group_chat",
}

/** Represents a message in a DM channel */
export type DmsPost = BaseEntityInterface & {
  __typename?: "DmsPost";
  /** The attachments to this message */
  attachments: Array<AttachmentInterface>;
  /** The text content of the message */
  content?: Maybe<Scalars["String"]["output"]>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The embed for this message */
  embed?: Maybe<Scalars["String"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /** The ID of the DM channel this message belongs to */
  feedId: Scalars["ID"]["output"];
  /** The type of the feed this message belongs to */
  feedType: FeedTypes;
  /** The file attachments for this message */
  fileAttachments: Array<FeedFileAttachment>;
  /** The GIFs attached to this message */
  gifs: Array<Gif>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** Whether the message has been edited */
  isEdited: Scalars["Boolean"]["output"];
  /** Whether everyone was mentioned in this message */
  isEveryoneMentioned: Scalars["Boolean"]["output"];
  /** Whether this message is pinned */
  isPinned: Scalars["Boolean"]["output"];
  /** Whether the user that sent the post is an admin of the bot */
  isPosterAdmin: Scalars["Boolean"]["output"];
  /** The link embeds for this message */
  linkEmbeds: Array<LinkEmbed>;
  /** The IDs of the users mentioned in this message */
  mentionedUserIds: Array<Scalars["ID"]["output"]>;
  /** The type of post */
  messageType: DmsPostTypes;
  /** The ID of the parent message, if applicable */
  parentId?: Maybe<Scalars["ID"]["output"]>;
  /** The reaction counts for this message */
  reactionCounts: Array<ReactionCount>;
  /** The reactions to this message */
  reactions: Array<Reaction>;
  /** The ID of the message this is replying to, if applicable */
  replyingToPostId?: Maybe<Scalars["ID"]["output"]>;
  /** The rich content of the message */
  richContent?: Maybe<Scalars["String"]["output"]>;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The user who sent this message */
  user: PublicProfileUser;
  /** The ID of the user who sent this message */
  userId: Scalars["ID"]["output"];
  /** The number of times this message has been viewed */
  viewCount?: Maybe<Scalars["Int"]["output"]>;
};

/** An experience activity card about a chat message */
export type DmsPostCard = ExperienceActivityCardInterface & {
  __typename?: "DmsPostCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /**
   * The chat message that this card is about
   * @deprecated Use lastDmsPosts instead
   */
  dmsPost: DmsPost;
  /** The last 3 chat messages that happened */
  lastDmsPosts?: Maybe<Array<DmsPost>>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The input to create a post in a feed */
export type DmsPostInput = {
  /** The attachments for this message */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The content of the post */
  content?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the DM channel this post belongs to */
  feedId: Scalars["ID"]["input"];
  /** The type of the feed this post belongs to */
  feedType: FeedTypes;
  /**
   * The file attachments for this message
   * @deprecated Use attachments instead
   */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** The GIFs attached to this message */
  gifs?: InputMaybe<Array<GifInput>>;
  /** The unique identifier for the post */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether everyone was mentioned in the post */
  isEveryoneMentioned?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether the post is pinned */
  isPinned?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The link embeds for this message */
  linkEmbeds?: InputMaybe<Array<LinkEmbedInput>>;
  /** The IDs of the users mentioned in the post */
  mentionedUserIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The ID of the parent post, if applicable */
  parentId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the message this is replying to, if applicable */
  replyingToPostId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The rich content of the post */
  richContent?: InputMaybe<Scalars["JSON"]["input"]>;
};

/** Response type for a single post with reactions and users */
export type DmsPostResponse = {
  __typename?: "DmsPostResponse";
  /** The post */
  post: DmsPost;
  /** List of reactions on that post */
  reactions: Array<Reaction>;
  /** List of users that have reacted to that post, and the user who created the post */
  users: Array<PublicProfileUser>;
};

/** The types of post */
export enum DmsPostTypes {
  Automated = "automated",
  Regular = "regular",
  System = "system",
}

/** Earning statistics for a member of an access pass. */
export type EarningsReport = {
  __typename?: "EarningsReport";
  /** The access pass these earnings are associated with. */
  accessPass?: Maybe<PublicAccessPass>;
  /** The sum of the earnings for this earning type. */
  earningsType?: Maybe<EarningsTypes>;
  /** How much the user has earned in the last 7 days from this earning type. */
  last7Days?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned in the last 24 hours from this earning type. */
  last24Hours?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned in the last 30 days from this earning type. */
  last30Days?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned all time from this earning type. */
  lifetime?: Maybe<Scalars["Float"]["output"]>;
};

/** The connection type for EarningsReport. */
export type EarningsReportConnection = {
  __typename?: "EarningsReportConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EarningsReportEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<EarningsReport>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EarningsReportEdge = {
  __typename?: "EarningsReportEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<EarningsReport>;
};

/** The types of earnings on the platform */
export enum EarningsReportPeriods {
  Last_7Days = "last_7_days",
  Last_24Hours = "last_24_hours",
  Last_30Days = "last_30_days",
  Lifetime = "lifetime",
}

/** The output of the sidebar */
export type EarningsSidebarOutput = {
  __typename?: "EarningsSidebarOutput";
  /** The current user's rank, if any */
  currentUserRank?: Maybe<Scalars["Int"]["output"]>;
  /** The current user's value, if any */
  currentUserValue?: Maybe<Scalars["Float"]["output"]>;
  /** The users */
  users: Array<PublicProfileUserWithRanking>;
};

/** The types of earnings on the platform */
export enum EarningsTypes {
  /** Bounty Payout */
  BountyPayout = "bounty_payout",
  /** Company Referral */
  CompanyReferral = "company_referral",
  /** Content Reward Fixed Payout */
  ContentRewardFixedPayout = "content_reward_fixed_payout",
  /** Content Reward Payout */
  ContentRewardPayout = "content_reward_payout",
  /** Creator To Creator */
  CreatorToCreator = "creator_to_creator",
  /** Creator To User */
  CreatorToUser = "creator_to_user",
  /** Membership Referral */
  MembershipReferral = "membership_referral",
  /** Payment Payout */
  PaymentPayout = "payment_payout",
  /** Team Member Payout */
  TeamMemberPayout = "team_member_payout",
  /** User To Creator */
  UserToCreator = "user_to_creator",
  /** User To User */
  UserToUser = "user_to_user",
}

/** Autogenerated input type of EnableCancelationDiscounts */
export type EnableCancelationDiscountsInput = {
  /** Either forever (0), first payment (1), or a specified number of months (2, 3, 4...). */
  cancelDiscountIntervals: Scalars["Int"]["input"];
  /** The percentage discount to offer when canceling a subscription. */
  cancelDiscountPercentage: Scalars["Int"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of EndLivestream */
export type EndLivestreamInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed id of the livestream */
  feedId: Scalars["ID"]["input"];
};

/** The type of entity to fetch */
export enum EntityTypes {
  /** Chat Feed */
  ChatFeed = "chat_feed",
  /** Dms Feed */
  DmsFeed = "dms_feed",
  /** Dms Feed Member */
  DmsFeedMember = "dms_feed_member",
  /** Dms Post */
  DmsPost = "dms_post",
  /** Forum Feed */
  ForumFeed = "forum_feed",
  /** Forum Post */
  ForumPost = "forum_post",
  /** Livestream Feed */
  LivestreamFeed = "livestream_feed",
  /** Muted User */
  MutedUser = "muted_user",
  /** Reaction */
  Reaction = "reaction",
}

/** Which columns can be used to sort. */
export enum EntriesSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** An object representing an entry in a raffle or waitlist. */
export type Entry = {
  __typename?: "Entry";
  /** When the entry was created. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Responses collected from the user when submitting their entry. */
  customFieldResponses?: Maybe<Array<CustomFieldResponse>>;
  /** When the specified raffle ends (if applicable). */
  endTime?: Maybe<Scalars["Int"]["output"]>;
  /** Whether the entry is a waitlist or raffle entry. */
  entryType: Scalars["String"]["output"];
  /** The internal ID of the entry. */
  id: Scalars["ID"]["output"];
  /** The member the entry is connected to. */
  member?: Maybe<Member>;
  /** The name of the raffle/waitlist. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The plan the entry is connected to. */
  plan?: Maybe<Plan>;
  /** Whether or not the entry has been selected. */
  selected?: Maybe<Scalars["Boolean"]["output"]>;
  /** The status of the entry. */
  status?: Maybe<Scalars["String"]["output"]>;
  /** The crypto wallet address associated with the entry. */
  walletAddress?: Maybe<Scalars["String"]["output"]>;
  /** The weight of the entry. */
  weight: Scalars["Int"]["output"];
};

/** Actions that can be performed on an entry for a raffle/waitlist. */
export enum EntryActions {
  ApproveEntry = "approve_entry",
  DenyEntry = "deny_entry",
}

/** The connection type for Entry. */
export type EntryConnection = {
  __typename?: "EntryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Entry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type EntryEdge = {
  __typename?: "EntryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Entry>;
};

/** Values to filter entries on */
export type EntryFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What the results should be ordered by. */
  order?: InputMaybe<EntryOrder>;
  /** A specific status */
  status?: InputMaybe<EntryStatus>;
  /** A list of statuses */
  statuses?: InputMaybe<Array<EntryStatus>>;
};

/** The order to sort the entries by */
export enum EntryOrder {
  CreatedAt = "created_at",
  MemberDiscord = "member_discord",
  MemberUsername = "member_username",
  Selected = "selected",
}

/** The status of an entry to a waitlist or raffle. */
export enum EntryStatus {
  Any = "any",
  Approved = "approved",
  Denied = "denied",
  Pending = "pending",
}

/** An entry can either be a watlist or raffle */
export enum EntryTypes {
  Raffle = "raffle",
  Waitlist = "waitlist",
}

/** Represents an event with its details, timing, and location information */
export type Event = {
  __typename?: "Event";
  /** When this event was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the event */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The end time of the event */
  endsAt: Scalars["Timestamp"]["output"];
  /** The experience associated with the event */
  experience: AccessibleExperience;
  /** The user hosting the event */
  host?: Maybe<PublicProfileUser>;
  /** The unique identifier of the event */
  id: Scalars["ID"]["output"];
  /** The location or URL of the event */
  location?: Maybe<Scalars["String"]["output"]>;
  /** The type of location (offline, online, zoom, google_meet) */
  locationType: Scalars["String"]["output"];
  /** The maximum number of attendees allowed */
  maxCapacity?: Maybe<Scalars["Int"]["output"]>;
  /** The RSVPs for the event */
  rsvps: RsvpConnection;
  /** The number of RSVPs for the event */
  rsvpsCount: Scalars["Int"]["output"];
  /** The start time of the event */
  startsAt: Scalars["Timestamp"]["output"];
  /** URL to the event thumbnail */
  thumbnailUrl?: Maybe<Scalars["String"]["output"]>;
  /** The title of the event */
  title: Scalars["String"]["output"];
};

/** Represents an event with its details, timing, and location information */
export type EventRsvpsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An experience activity card about an event */
export type EventCard = ExperienceActivityCardInterface & {
  __typename?: "EventCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The event that this card is about */
  event?: Maybe<Event>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The type of update an event is. */
export enum EventCategory {
  /** Affiliates */
  Affiliates = "affiliates",
  /** Canceled Membership */
  CanceledMembership = "canceled_membership",
  /** Churned Members */
  ChurnedMembers = "churned_members",
  /** Custom */
  Custom = "custom",
  /** Digest */
  Digest = "digest",
  /** Discord Roles */
  DiscordRoles = "discord_roles",
  /** Expiring Soon */
  ExpiringSoon = "expiring_soon",
  /** License Key */
  LicenseKey = "license_key",
  /** Misc */
  Misc = "misc",
  /** New Case */
  NewCase = "new_case",
  /** New Disputes */
  NewDisputes = "new_disputes",
  /** New Members */
  NewMembers = "new_members",
  /** New Raffle Entries */
  NewRaffleEntries = "new_raffle_entries",
  /** New Waitlist Entries */
  NewWaitlistEntries = "new_waitlist_entries",
  /** Nft Mints Claimed */
  NftMintsClaimed = "nft_mints_claimed",
  /** Page Views */
  PageViews = "page_views",
  /** Payment Updates */
  PaymentUpdates = "payment_updates",
  /** Reapply To Marketplace */
  ReapplyToMarketplace = "reapply_to_marketplace",
  /** Reviews */
  Reviews = "reviews",
  /** Saved Cancelation */
  SavedCancelation = "saved_cancelation",
  /** Uncanceled Membership */
  UncanceledMembership = "uncanceled_membership",
  /** Updated Payment */
  UpdatedPayment = "updated_payment",
  /** Weekly Report */
  WeeklyReport = "weekly_report",
  /** Welcome */
  Welcome = "welcome",
}

/** An object representing an experience belonging to a company. */
export type Experience = {
  __typename?: "Experience";
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The relevant access pass for the experience */
  accessPass?: Maybe<PublicAccessPass>;
  /** The access passes that have access to this experience. */
  accessPasses: AccessPassConnection;
  /** The livestream for the experience */
  activeLivestreamFeed?: Maybe<PublicLivestreamFeed>;
  /** The experience interface for this experience. */
  app: PublicApp;
  /** The chat feed IDs associated with this experience */
  chatFeedIds: Array<Scalars["ID"]["output"]>;
  /** The chat feeds associated with this experience */
  chatFeeds: Array<ChatFeed>;
  /** The company that owns this experience. */
  company: PublicCompany;
  /** Retrieve a specific content rewards campaign */
  contentRewardsCampaign: PublicCampaign;
  /** The content rewards campaigns for this experience */
  contentRewardsCampaigns: PublicCampaignConnection;
  /** The timestamp of when this experience was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when this experience was created. */
  createdAtMs: Scalars["BigInt"]["output"];
  /** A short written description of what is being offered */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp (in milliseconds since epoch) of when the experience was soft deleted. If it's null, the experience is still active. */
  discardedAtMs?: Maybe<Scalars["BigInt"]["output"]>;
  /** The type of product/service being delivered. */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The features enabled for the experience */
  features: Array<Scalars["String"]["output"]>;
  /** The forum feed associated with this experience. */
  forumFeed?: Maybe<ForumFeed>;
  /** Whether the current user has access to this experience */
  hasAccess: Scalars["Boolean"]["output"];
  /** Whether to hide the experience if it is not accessible. */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The unique ID representing this experience */
  id: Scalars["ID"]["output"];
  /** The iframe link for the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface. Deprecated, use logo instead. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The image with fallback for this experience (uses app icon if no image is present). Deprecated, use logo instead. */
  imageWithFallbackSrcset: ImgSrcset;
  /** Whether or not this experience is in dev mode */
  interfaceDevMode: Scalars["Boolean"]["output"];
  /** Whether the current user is an authorized user of the company that owns this experience */
  isAuthorizedUser: Scalars["Boolean"]["output"];
  /** The timestamp of the last activity on this experience */
  lastActivityAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /**
   * The timestamp of the last activity on this experience
   * @deprecated Use last_activity_at instead
   */
  lastFeedContentItemAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The access passes that can be linked to the experience */
  linkableAccessPasses: PublicAccessPassConnection;
  /** The livestream feeds associated with this experience */
  livestreamFeeds: LivestreamFeedConnection;
  /** The logo for the experience. */
  logo?: Maybe<AttachmentInterface>;
  /** The marketplace access pass for the experience */
  marketplaceAccessPass?: Maybe<PublicAccessPass>;
  /** The written name of the description. */
  name: Scalars["String"]["output"];
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed: Scalars["Boolean"]["output"];
  /** Whether or not experience content is shown in the explore page */
  showExploreContent: Scalars["Boolean"]["output"];
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The target link to request */
  targetLink?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the experience was updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<Plan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
  /** The access pass for the experience */
  userDefaultAccessPass?: Maybe<PublicAccessPass>;
  /** The timestamp of when the experience went live */
  wentLiveAt?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceAccessPassArgs = {
  direction: Direction;
  order: AccessPassOrder;
};

/** An object representing an experience belonging to a company. */
export type ExperienceAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceContentRewardsCampaignArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing an experience belonging to a company. */
export type ExperienceContentRewardsCampaignsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ContentRewardsPublicCampaignsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceImageWithFallbackSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceLinkableAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceLivestreamFeedsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type ExperienceTargetLinkArgs = {
  appViewType: AppViewTypes;
  mode: ExperienceLinkModes;
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** The different access levels for experiences (PUBLIC IS NEVER USED ANYMORE). */
export enum ExperienceAccessLevels {
  Private = "private",
  Public = "public",
}

export type ExperienceActivityCardInterface = {
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The type of content that this experience card contains */
export enum ExperienceActivityCardTypes {
  Availability = "availability",
  Booking = "booking",
  Bounty = "bounty",
  BountySubmission = "bounty_submission",
  CalendarBookingsAvailability = "calendar_bookings_availability",
  CalendarBookingsBooking = "calendar_bookings_booking",
  Campaign = "campaign",
  Content = "content",
  ContentRewardsCampaign = "content_rewards_campaign",
  ContentRewardsSubmission = "content_rewards_submission",
  Course = "course",
  DmsPost = "dms_post",
  Event = "event",
  EventsEvent = "events_event",
  EventsRsvp = "events_rsvp",
  FeedDmsPost = "feed_dms_post",
  FeedForumPost = "feed_forum_post",
  FeedLivestreamFeed = "feed_livestream_feed",
  ForumPost = "forum_post",
  LivestreamFeed = "livestream_feed",
  Rsvp = "rsvp",
  Spin = "spin",
  Submission = "submission",
  Wheel = "wheel",
  WheelSpin = "wheel_spin",
  WheelWheel = "wheel_wheel",
}

/** The connection type for Experience. */
export type ExperienceConnection = {
  __typename?: "ExperienceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExperienceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Experience>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ExperienceEdge = {
  __typename?: "ExperienceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Experience>;
};

/** Values to filter plans on */
export type ExperienceFilters = {
  /**
   * The access level to filter on.
   * @deprecated You can't filter by access level anymore
   */
  accessLevel?: InputMaybe<ExperienceAccessLevels>;
  /** The ID of the access pass to filter on. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the experience interface to filter on. */
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The type of experience.. */
  experienceType?: InputMaybe<ExperienceTypes>;
  /** Either includes or excludes experiences on a given access pass. */
  onAccessPass?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The query to search for. */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

export type ExperienceInterface = {
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The access passes that offer access to this experience */
  accessPasses: Array<AccessPass>;
  /** The interface of the experience */
  app?: Maybe<App>;
  /** A short description of the experience */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The type of experience */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether to hide the experience if it is not accessible */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The ID of the experience */
  id: Scalars["ID"]["output"];
  /** The image for the experience */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The name of the experience */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed: Scalars["Boolean"]["output"];
  /** Whether or not experience content is shown in the explore page */
  showExploreContent: Scalars["Boolean"]["output"];
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<Plan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
};

export type ExperienceInterfaceImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** The connection type for ExperienceInterface. */
export type ExperienceInterfaceConnection = {
  __typename?: "ExperienceInterfaceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExperienceInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExperienceInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ExperienceInterfaceEdge = {
  __typename?: "ExperienceInterfaceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ExperienceInterface>;
};

/** The different URLs an experience interface can have */
export type ExperienceInterfacePaths = {
  __typename?: "ExperienceInterfacePaths";
  /** The path for checkout to the experience */
  checkoutPath?: Maybe<Scalars["String"]["output"]>;
  /** The path for the dash experience */
  dashPath?: Maybe<Scalars["String"]["output"]>;
  /** The path for consumers to view the experience */
  hubPath?: Maybe<Scalars["String"]["output"]>;
  /** The path for oauth to the experience */
  oauthPath?: Maybe<Scalars["String"]["output"]>;
  /** The path for the general seller view */
  sellerPath?: Maybe<Scalars["String"]["output"]>;
};

/** The status of an experience interface */
export enum ExperienceInterfaceStatuses {
  Hidden = "hidden",
  Live = "live",
  Unlisted = "unlisted",
}

/** The types of links that can be generated. */
export enum ExperienceLinkModes {
  IframeLink = "iframe_link",
  Link = "link",
}

/** An object representing how an experience should be styled. */
export type ExperienceStyle = {
  __typename?: "ExperienceStyle";
  /** The background of the experience style. */
  background: Scalars["String"]["output"];
  /** The experience type!!! */
  experienceType?: Maybe<ExperienceTypes>;
  /** The icon of the experience style. */
  icon: Scalars["String"]["output"];
};

/** The different types of experiences that can be created. */
export enum ExperienceTypes {
  /** Has Interface */
  HasInterface = "has_interface",
}

/** An experience along with its associated notification information */
export type ExperienceWithNotification = {
  __typename?: "ExperienceWithNotification";
  /** The experience associated with the notification */
  experience: PublicExperience;
  /** The last notification associated with the experience */
  lastNotification?: Maybe<PublicNotification>;
  /** The notification badge associated with the experience */
  notificationBadge?: Maybe<NotificationBadge>;
};

/** An export. */
export type Export = {
  __typename?: "Export";
  /** The CSV data */
  data: Array<Scalars["JSON"]["output"]>;
  /** The filename */
  filename: Scalars["String"]["output"];
  /** The CSV headers */
  headers: Array<Scalars["String"]["output"]>;
  /** Job id */
  jobId?: Maybe<Scalars["String"]["output"]>;
  /** Message sent to user */
  message?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of ExportCreatorDashboardTable */
export type ExportCreatorDashboardTableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The options for the export. */
  options: ExportCreatorDashboardTableOptionsInput;
  /** The filters to apply to the table. */
  tableFilters: Scalars["JSON"]["input"];
  /** The name of the table to export. */
  tableName: CreatorDashboardExportableTables;
};

/** Options for exporting a creator dashboard table. */
export type ExportCreatorDashboardTableOptionsInput = {
  /** The columns to export. */
  columns: Array<Scalars["String"]["input"]>;
  /** The time zone to use for the export. */
  timeZone: Scalars["String"]["input"];
};

/** An object representing a connection between a creator and a user/company_buyer. This type can be made visible to someone who is not the company or the user/company_buyer. */
export type ExtraPublicMember = {
  __typename?: "ExtraPublicMember";
  /** The company that the member is a part of */
  company: PublicCompany;
  /** The ID of the member */
  id: Scalars["ID"]["output"];
  /** The profile of the member */
  profile: PublicProfileUser;
};

/** The connection type for ExtraPublicMember. */
export type ExtraPublicMemberConnection = {
  __typename?: "ExtraPublicMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExtraPublicMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExtraPublicMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ExtraPublicMemberEdge = {
  __typename?: "ExtraPublicMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ExtraPublicMember>;
};

/** An even more sanitized membership type */
export type ExtraPublicMembership = {
  __typename?: "ExtraPublicMembership";
  /** The access pass tied to this membership. */
  accessPass: PublicAccessPass;
  /** The timestamp of when this membership was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** An array of experiences that this pass has. */
  experiences: PublicExperienceConnection;
  /** The membership ID */
  id: Scalars["ID"]["output"];
  /** The plan tied to this membership. */
  plan: PublicPlan;
  /** The quantity of this membership. */
  quantity: Scalars["Int"]["output"];
};

/** An even more sanitized membership type */
export type ExtraPublicMembershipExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a question and answer object to be shown to the user. */
export type FaqObject = {
  __typename?: "FaqObject";
  /** The answer to the question to be displayed to the user. */
  answer: Scalars["String"]["output"];
  /** A filler ID of the faq object */
  id: Scalars["ID"]["output"];
  /** The question to be displayed to the user. */
  question: Scalars["String"]["output"];
};

/** A Firebase Cloud Messaging token for a user's device, allowing notifications. */
export type FcmToken = {
  __typename?: "FcmToken";
  /** The app the token belongs to */
  app?: Maybe<FcmTokenAppTypes>;
  /** The device ID of the device the token belongs to */
  deviceId?: Maybe<Scalars["String"]["output"]>;
  /** The token of the FCM service */
  token?: Maybe<Scalars["String"]["output"]>;
};

/** Whether the FCM token is tied to the marketplace or dashboard. */
export enum FcmTokenAppTypes {
  /** Android */
  Android = "android",
  /** Dash */
  Dash = "dash",
  /** Hub */
  Hub = "hub",
  /** Marketplace */
  Marketplace = "marketplace",
  /** React Native */
  ReactNative = "react_native",
  /** Swift */
  Swift = "swift",
}

/** Represents a fee related to a payment */
export type Fee = {
  __typename?: "Fee";
  /** The currency of the fee. */
  currency: Currencies;
  /** A tooltip / description for the specific fee */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The label to display for the fee. */
  label: Scalars["String"]["output"];
  /** The value or amount to display for the fee. */
  rawAmount: Scalars["Float"]["output"];
  /** The type of fee. */
  typeOfFee: ReceiptFeeTypes;
  /** The value or amount to display for the fee. */
  value: Scalars["String"]["output"];
};

/** The fee cost structure to display to the user. */
export type FeeCostStructure = {
  __typename?: "FeeCostStructure";
  /** The fixed fee for the payment method. ex. $0.25 */
  fixedFee: Scalars["Float"]["output"];
  /** The identifier for the payment method. Ex card,	cashapp, us_bank_account. */
  paymentMethodType: PaymentMethodTypes;
  /** The percentage fee for the payment method. ex. 2.9% */
  percentageFee: Scalars["Float"]["output"];
};

/** Represents a file attachment in a feed */
export type FeedFileAttachment = {
  __typename?: "FeedFileAttachment";
  /** The aspect ratio of the image, if applicable */
  aspectRatio?: Maybe<Scalars["Float"]["output"]>;
  /** The type of the attachment (e.g., image, video) */
  attachmentType?: Maybe<FileAttachmentTypes>;
  /** The blurred data URL for image preview */
  blurUrl?: Maybe<Scalars["String"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The name of the file */
  fileName?: Maybe<Scalars["String"]["output"]>;
  /** The size of the file in bytes */
  fileSize?: Maybe<Scalars["Int"]["output"]>;
  /** The URL of the file with specific size. */
  fileSrcset: ImgSrcset;
  /** The URL to access the file */
  fileUrl: Scalars["String"]["output"];
  /** The height of the image */
  height?: Maybe<Scalars["Int"]["output"]>;
  /** The ID of the file attachment */
  id: Scalars["ID"]["output"];
  /** The URL to access the thumbnail */
  thumbnailUrl?: Maybe<Scalars["String"]["output"]>;
  /** The width of the image */
  width?: Maybe<Scalars["Int"]["output"]>;
};

/** Represents a file attachment in a feed */
export type FeedFileAttachmentFileSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** A forum post */
export type FeedForumPostUniversalPost = UniversalPostResourceInterface & {
  __typename?: "FeedForumPostUniversalPost";
  /** The forum post */
  forumPost?: Maybe<ForumPost>;
  /** The type of the resource */
  resourceType: Scalars["String"]["output"];
};

/** A livestream feed */
export type FeedLivestreamFeedUniversalPost = UniversalPostResourceInterface & {
  __typename?: "FeedLivestreamFeedUniversalPost";
  /** The livestream feed */
  livestreamFeed?: Maybe<LivestreamFeed>;
  /** The type of the resource */
  resourceType: Scalars["String"]["output"];
};

/** Response type for feed posts query */
export type FeedPostsResponse = {
  __typename?: "FeedPostsResponse";
  /** List of posts */
  posts: Array<BaseEntityInterface>;
  /** List of reactions */
  reactions: Array<Reaction>;
  /** List of users */
  users: Array<PublicProfileUser>;
};

/** The type of feed to fetch from */
export enum FeedTypes {
  /** Chat Feed */
  ChatFeed = "chat_feed",
  /** Dms Feed */
  DmsFeed = "dms_feed",
  /** Forum Feed */
  ForumFeed = "forum_feed",
  /** Livestream Feed */
  LivestreamFeed = "livestream_feed",
  /** Universal Post */
  UniversalPost = "universal_post",
  /** User */
  User = "user",
}

/** Represents a webhook for a feed */
export type FeedWebhook = {
  __typename?: "FeedWebhook";
  /** The time the webhook was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The URL to execute the webhook */
  executeUrl: Scalars["String"]["output"];
  /** The ID of the webhook */
  id: Scalars["ID"]["output"];
  /** The name of the webhook */
  name: Scalars["String"]["output"];
};

/** The connection type for FeedWebhook. */
export type FeedWebhookConnection = {
  __typename?: "FeedWebhookConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FeedWebhookEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<FeedWebhook>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type FeedWebhookEdge = {
  __typename?: "FeedWebhookEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<FeedWebhook>;
};

/** Autogenerated input type of FetchJobStatus */
export type FetchJobStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the job to check the status for. */
  id: Scalars["ID"]["input"];
};

export type FetchVideoCharacters = {
  __typename?: "FetchVideoCharacters";
  /** The characters that can be used to create a video */
  characters?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The error message of the characters */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of FetchVideoCharacters */
export type FetchVideoCharactersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Represents a file. */
export type FileAttachment = {
  __typename?: "FileAttachment";
  /** The content type of the file. */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The CDN url to render the image, if it is an image or video. */
  dataSrcset?: Maybe<ImgSrcset>;
  /** The height of the file. */
  height?: Maybe<Scalars["Int"]["output"]>;
  /** The internal ID of the file. */
  id: Scalars["ID"]["output"];
  /** The moderation result of the file, if any. */
  moderationResult?: Maybe<FileAttachmentModerationResultsTypes>;
  /** The position (aka order) of the file. */
  position: Scalars["Int"]["output"];
  /** The url to access the file. */
  url: Scalars["String"]["output"];
  /** The width of the file. */
  width?: Maybe<Scalars["Int"]["output"]>;
};

/** Represents a file. */
export type FileAttachmentDataSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** The connection type for FileAttachment. */
export type FileAttachmentConnection = {
  __typename?: "FileAttachmentConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FileAttachmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<FileAttachment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type FileAttachmentEdge = {
  __typename?: "FileAttachmentEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<FileAttachment>;
};

/** Input for a file attachment */
export type FileAttachmentInput = {
  /** The aspect ratio of the image, if applicable */
  aspectRatio?: InputMaybe<Scalars["Float"]["input"]>;
  /** The type of the attachment (e.g., image, video) */
  attachmentType: FileAttachmentTypes;
  /** The blurred data URL for image preview */
  blurUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the file */
  fileName?: InputMaybe<Scalars["String"]["input"]>;
  /** The size of the file in bytes */
  fileSize?: InputMaybe<Scalars["Int"]["input"]>;
  /** The URL to access the file */
  fileUrl: Scalars["String"]["input"];
  /** The height of the image */
  height?: InputMaybe<Scalars["Int"]["input"]>;
  /** The ID of the file attachment */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** The URL to access the thumbnail */
  thumbnailUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The width of the image */
  width?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The different moderation results for a file attachment. */
export enum FileAttachmentModerationResultsTypes {
  /** Nsfw */
  Nsfw = "nsfw",
}

/** The types of supported file attachments */
export enum FileAttachmentTypes {
  /** Audio */
  Audio = "audio",
  /** File */
  File = "file",
  /** Image */
  Image = "image",
  /** Unknown */
  Unknown = "unknown",
  /** Video */
  Video = "video",
}

/** The duration of a FlashSale */
export enum FlashSaleDurations {
  /** Forever */
  Forever = "forever",
  /** Once */
  Once = "once",
}

/** The status of a FlashSale */
export enum FlashSaleStatuses {
  /** Active */
  Active = "active",
  /** Archived */
  Archived = "archived",
  /** Draft */
  Draft = "draft",
}

/** Email notification preference option for a forum feed */
export enum ForumEmailNotificationPreferences {
  AllAdminPosts = "all_admin_posts",
  None = "none",
  OnlyWeeklySummary = "only_weekly_summary",
}

/** Represents a forum feed */
export type ForumFeed = BaseEntityInterface & {
  __typename?: "ForumFeed";
  /**
   * Admin users in this forum
   * @deprecated Use the 'users' field instead, it also returns admins.
   */
  admins: PublicProfileUserConnection;
  /** The banner image file for this forum */
  bannerImage?: Maybe<FeedFileAttachment>;
  /** The company for this forum */
  company?: Maybe<PublicCompany>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The discord webhook url for this forum */
  discordWebhookUrl?: Maybe<Scalars["String"]["output"]>;
  /** The email notification preference for this forum */
  emailNotificationPreference: ForumEmailNotificationPreferences;
  /** The type of the card */
  entityType: EntityTypes;
  /** The experience for this forum */
  experienceId?: Maybe<Scalars["ID"]["output"]>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The layout display option for this forum */
  layout: ForumLayoutTypes;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The telegram channel id for this forum */
  telegramChannelId?: Maybe<Scalars["String"]["output"]>;
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** Users in this forum */
  users: PublicProfileUserConnection;
  /** The webhooks for the feed */
  webhooks: FeedWebhookConnection;
  /** Who can comment on this forum */
  whoCanComment: ForumWhoCanCommentTypes;
  /** Who can post on this forum */
  whoCanPost: ForumWhoCanPostTypes;
};

/** Represents a forum feed */
export type ForumFeedAdminsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a forum feed */
export type ForumFeedUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** Represents a forum feed */
export type ForumFeedWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The input to create or modify a forum feed */
export type ForumFeedInput = {
  /** The banner image for this forum */
  bannerImage?: InputMaybe<FileAttachmentInput>;
  /** The Discord webhook URL to forward posts to */
  discordWebhookUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The email notification preference for this forum */
  emailNotificationPreference?: InputMaybe<ForumEmailNotificationPreferences>;
  /** The unique identifier for the feed */
  id: Scalars["ID"]["input"];
  /** Whether the feed has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The layout display option for this forum */
  layout?: InputMaybe<ForumLayoutTypes>;
  /** The Telegram channel ID to forward posts to */
  telegramChannelId?: InputMaybe<Scalars["String"]["input"]>;
  /** Who can comment on this forum */
  whoCanComment?: InputMaybe<ForumWhoCanCommentTypes>;
  /** Who can post on this forum */
  whoCanPost?: InputMaybe<ForumWhoCanPostTypes>;
};

/** The layout display option of a forum feed */
export enum ForumLayoutTypes {
  Blog = "blog",
  Feed = "feed",
}

/** Represents a post in forum */
export type ForumPost = BaseEntityInterface & {
  __typename?: "ForumPost";
  /** The attachments to this message */
  attachments: Array<AttachmentInterface>;
  /** The amount of comments on this post */
  commentCount: Scalars["Int"]["output"];
  /** The unique users who commented on this post */
  commentUsers: PublicProfileUserConnection;
  /** The text content of the forum post */
  content?: Maybe<Scalars["String"]["output"]>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The embed for this post */
  embed?: Maybe<Scalars["String"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /** The ID of the forum feed this forum post belongs to */
  feedId: Scalars["ID"]["output"];
  /** The type of feed this forum post belongs to */
  feedType: FeedTypes;
  /**
   * The file attachments for this forum post
   * @deprecated Use the 'attachments' field instead
   */
  fileAttachments: Array<FeedFileAttachment>;
  /** The type of post */
  forumPostType: ForumPostTypes;
  /** The GIFs attached to this forum post */
  gifs: Array<Gif>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** Whether the forum post has been edited */
  isEdited: Scalars["Boolean"]["output"];
  /** Whether the user that sent the post is an admin of the bot */
  isPosterAdmin: Scalars["Boolean"]["output"];
  /** The line item for this forum post */
  lineItem?: Maybe<PublicLineItem>;
  /**
   * The link embeds for this forum post
   * @deprecated Link embeds are no longer a feature and should not be shown to users
   */
  linkEmbeds: Array<LinkEmbed>;
  /** The IDs of the users mentioned in this forum post */
  mentionedUserIds: Array<Scalars["ID"]["output"]>;
  /** The Mux assets for this forum post */
  muxAssets: Array<MuxAsset>;
  /** The negative badge for the bulletin board post */
  negativeBulletinBoardBadge?: Maybe<Scalars["String"]["output"]>;
  /** The reactions from the current user */
  ownReactions: ReactionConnection;
  /** The parent forum post */
  parent?: Maybe<ForumPost>;
  /** The ID of the parent forum post, if applicable */
  parentId?: Maybe<Scalars["ID"]["output"]>;
  /** Whether this forum post is pinned */
  pinned: Scalars["Boolean"]["output"];
  /** The poll for this forum post */
  poll?: Maybe<Poll>;
  /** The positive badge for the bulletin board post */
  positiveBulletinBoardBadge?: Maybe<Scalars["String"]["output"]>;
  /** The reaction counts for this forum post */
  reactionCounts: Array<ReactionCount>;
  /** The reactions to this forum post */
  reactions: Array<Reaction>;
  /** The rich content of the forum post */
  richContent?: Maybe<Scalars["String"]["output"]>;
  /** The root parent post of this forum post */
  rootParent?: Maybe<ForumPost>;
  /** The root post of this forum post */
  rootPost?: Maybe<ForumPost>;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The title of the forum post */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The user who created this forum post */
  user: PublicProfileUser;
  /** The ID of the user who sent this forum post */
  userId: Scalars["ID"]["output"];
  /** The number of times this message has been viewed */
  viewCount?: Maybe<Scalars["Int"]["output"]>;
};

/** Represents a post in forum */
export type ForumPostCommentUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a post in forum */
export type ForumPostOwnReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  reactionType?: InputMaybe<ReactionTypes>;
};

/** An experience activity card about a forum post */
export type ForumPostCard = ExperienceActivityCardInterface & {
  __typename?: "ForumPostCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The forum post that this card is about */
  forumPost?: Maybe<ForumPost>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The input to create a post in a forum */
export type ForumPostInput = {
  /** The attachments for this post */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The badge for the bulletin board post */
  bulletinBoardBadge?: InputMaybe<Scalars["String"]["input"]>;
  /** The content of the post */
  content?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the forum feed this post belongs to */
  feedId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The type of feed this post belongs to */
  feedType?: InputMaybe<FeedTypes>;
  /**
   * The file attachments for this post
   * @deprecated Use attachments instead
   */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** The GIFs attached to this post */
  gifs?: InputMaybe<Array<GifInput>>;
  /** The unique identifier for the post */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the line item for this post */
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The IDs of the users mentioned in the post */
  mentionedUserIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The Mux assets for this post */
  muxAssets?: InputMaybe<Array<MuxAssetInput>>;
  /** The ID of the parent post, if applicable */
  parentId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether the post is pinned */
  pinned?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the plan for this post */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The poll for this post */
  poll?: InputMaybe<PollInput>;
  /** The rich content of the post */
  richContent?: InputMaybe<Scalars["JSON"]["input"]>;
  /** The ID of the feed we should send a system message in, if any. */
  systemMessageFeedId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The type of feed we should send the system message in, if any */
  systemMessageFeedType?: InputMaybe<FeedTypes>;
  /** The title of the post */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Response type for a single post with reactions and users */
export type ForumPostResponse = {
  __typename?: "ForumPostResponse";
  /** The post */
  post: ForumPost;
  /** List of reactions on that post */
  reactions: Array<Reaction>;
  /** List of users that have reacted to that post, and the user who created the post */
  users: Array<PublicProfileUser>;
};

/** The types of post */
export enum ForumPostTypes {
  Automated = "automated",
  Regular = "regular",
  System = "system",
}

/** Who can comment on a forum feed */
export enum ForumWhoCanCommentTypes {
  Admins = "admins",
  Everyone = "everyone",
}

/** Who can post on a forum feed */
export enum ForumWhoCanPostTypes {
  Admins = "admins",
  Everyone = "everyone",
}

/** The friendly status of a receipt */
export enum FriendlyReceiptStatus {
  AutoRefunded = "auto_refunded",
  Canceled = "canceled",
  DisputeWarning = "dispute_warning",
  Drafted = "drafted",
  Failed = "failed",
  Incomplete = "incomplete",
  OpenDispute = "open_dispute",
  OpenResolution = "open_resolution",
  PartiallyRefunded = "partially_refunded",
  PastDue = "past_due",
  Pending = "pending",
  PriceTooLow = "price_too_low",
  Refunded = "refunded",
  Succeeded = "succeeded",
  Uncollectible = "uncollectible",
  Unresolved = "unresolved",
}

/** Autogenerated input type of FulfillTradingViewExperience */
export type FulfillTradingViewExperienceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the experience to fulfill */
  experienceId: Scalars["ID"]["input"];
};

/** A gateway for a payment token. */
export enum GatewayTypes {
  /** Adyen */
  Adyen = "adyen",
  /** Basis Theory */
  BasisTheory = "basis_theory",
  /** Paypal */
  Paypal = "paypal",
}

/** Autogenerated input type of GenerateConnectedAccountSession */
export type GenerateConnectedAccountSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the connected account to generate the session for */
  connectedAccountId: Scalars["ID"]["input"];
};

/** Autogenerated input type of GenerateLedgerAccountManageUrl */
export type GenerateLedgerAccountManageUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** This is the ID of the ledger account to generate the link for. */
  id: Scalars["ID"]["input"];
  /** The URL to redirect to after the user has completed the Stripe onboarding process. */
  redirectUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of GenerateMobileOauthCode */
export type GenerateMobileOauthCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of GenerateMuxUploadUrl */
export type GenerateMuxUploadUrlInput = {
  /** Whether the uploaded file is an audio file. You can also set this to true while uploading a video file to only keep the audio track. */
  audioOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** The output of the mutation to generate a mux asset upload url */
export type GenerateMuxUploadUrlOutput = {
  __typename?: "GenerateMuxUploadUrlOutput";
  /** The passthrough ID of the created MuxAsset */
  passthroughId: Scalars["ID"]["output"];
  /** The URL to upload the file to */
  uploadUrl: Scalars["String"]["output"];
};

/** Autogenerated input type of GeneratePaypalOauthUrl */
export type GeneratePaypalOauthUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL to return to after the user has authorized the app */
  returnUrl: Scalars["String"]["input"];
};

/** Autogenerated input type of GenerateStripeManageUrl */
export type GenerateStripeManageUrlInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** This is the ID of the stripe account to generate the link for. */
  id: Scalars["ID"]["input"];
  /** The URL to redirect to after the user has completed the Stripe onboarding process. */
  redirectUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Autogenerated input type of GenerateTransferLink */
export type GenerateTransferLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** This is the ID of the membership you want to create a transfer link for. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of GenerateValueWithAi */
export type GenerateValueWithAiInput = {
  /** The access pass ID to use for generating the value. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The attribute to generate a value for. Currently supports 'title', 'headline', 'shortened_description', 'who_this_is_for', 'pricing_feature', 'creator_pitch', 'experience_description', and 'faq'. */
  attribute: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The experience ID to use for generating the value. */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The starting value to use for generating the value. */
  startingValue?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of GenerateWebsocketJwt */
export type GenerateWebsocketJwtInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Represents a GIF attachment in a feed post */
export type Gif = {
  __typename?: "Gif";
  /** The height of the GIF in pixels */
  height: Scalars["Int"]["output"];
  /** The URL for the original GIF */
  originalUrl: Scalars["String"]["output"];
  /** The URL for a preview image of the GIF */
  previewUrl: Scalars["String"]["output"];
  /** The provider of the GIF (e.g., GIPHY, Tenor) */
  provider: GifProviders;
  /** The unique identifier of the GIF */
  slug: Scalars["ID"]["output"];
  /** The title of the GIF */
  title: Scalars["String"]["output"];
  /** The URL of the full GIF */
  url: Scalars["String"]["output"];
  /** The width of the GIF in pixels */
  width: Scalars["Int"]["output"];
};

/** Input for a GIF attachment */
export type GifInput = {
  /** The height of the GIF in pixels */
  height: Scalars["Int"]["input"];
  /** The original URL of the GIF */
  originalUrl: Scalars["String"]["input"];
  /** The URL for a preview image of the GIF */
  previewUrl: Scalars["String"]["input"];
  /** The provider of the GIF */
  provider: GifProviders;
  /** The unique identifier of the GIF */
  slug: Scalars["ID"]["input"];
  /** The title of the GIF */
  title: Scalars["String"]["input"];
  /** The URL of the full GIF */
  url: Scalars["String"]["input"];
  /** The width of the GIF in pixels */
  width: Scalars["Int"]["input"];
};

/** The types of supported GIFs providers */
export enum GifProviders {
  /** Giphy */
  Giphy = "giphy",
}

/** The different statuses of the global affiliate program for an access pass. */
export enum GlobalAffiliateStatuses {
  Disabled = "disabled",
  Enabled = "enabled",
}

/** Autogenerated input type of GoLive */
export type GoLiveInput = {
  /** The access pass ids to go live with. Max 25 */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** An experience ID to go live into */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The livestream feed input */
  livestreamFeedInput?: InputMaybe<LivestreamFeedInput>;
};

/** Autogenerated return type of GoLive. */
export type GoLivePayload = {
  __typename?: "GoLivePayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The experiences that you should navigate to */
  experiences: Array<PublicExperience>;
  /** The ID of the livestream feed that you are going live to */
  feedId: Scalars["String"]["output"];
};

/** A horizontally scrollable list of products. */
export type HorizontalList = DiscoveryModuleInterface & {
  __typename?: "HorizontalList";
  /** A product collection. */
  collection: DiscoveryCollection;
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** An object representing a ranking of a product for affiliates. */
export type HotAffiliateOffers = {
  __typename?: "HotAffiliateOffers";
  /** The accessPass */
  accessPass: PublicAccessPass;
  /** The total referrals in the last 24 hours */
  totalReferralsLast24Hours: Scalars["Int"]["output"];
};

/** An object representing a ranking of a product for affiliates. */
export type HotAffiliates = {
  __typename?: "HotAffiliates";
  /** The total earnings in the last 24 hours */
  totalEarningsLast24Hours: Scalars["Float"]["output"];
  /** The user */
  user: PublicProfileUser;
};

/** The scope of the results to return. */
export enum HubMembershipStatus {
  Active = "active",
  Inactive = "inactive",
}

/** The return value of a search. */
export type HubSearch = {
  __typename?: "HubSearch";
  /** The content that matches the search. */
  appContent: Array<ContentSearch>;
  /** The experiences that match the search. */
  experiences: Array<PublicExperience>;
  /** The whops that match the search, which the current user either owns or is an authorized_user of. */
  myWhops: Array<PublicCompany>;
  /** The users that match the search. */
  users: Array<PublicProfileUser>;
};

/** Represents an image. */
export type Image = {
  __typename?: "Image";
  /**
   * Blurred Image hash to render the image.
   * @deprecated Use imageSrcset instead.
   */
  blurhash: Scalars["String"]["output"];
  /**
   * Blurred Image hash to render the image.
   * @deprecated Use blurhash instead.
   */
  blurredHash: Scalars["String"]["output"];
  /** The content type of the image. */
  contentType: Scalars["String"]["output"];
  /**
   * The file extension for the image
   * @deprecated Use contentType instead.
   */
  extension: Scalars["String"]["output"];
  /** The file attachment for the image. */
  fileAttachment?: Maybe<FileAttachment>;
  /** The internal ID of the resource. */
  id: Scalars["ID"]["output"];
  /**
   * If the image is still processing
   * @deprecated Use imageSrcset instead. The image is always processed.
   */
  imageProcessing?: Maybe<Scalars["Boolean"]["output"]>;
  /** The CDN url to render the image. */
  imageSrcset: ImgSrcset;
  /** The position (aka order) of the image. */
  position: Scalars["Int"]["output"];
  /**
   * Thumbnail of the image.
   * @deprecated Use imageSrcset instead.
   */
  thumbnail?: Maybe<Scalars["String"]["output"]>;
  /**
   * The CDN url to render the image.
   * @deprecated Use imageSrcset instead.
   */
  url: Scalars["String"]["output"];
};

/** Represents an image. */
export type ImageImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** Represents an image attachment */
export type ImageAttachment = AttachmentInterface & {
  __typename?: "ImageAttachment";
  /** Whether the attachment has been analyzed */
  analyzed: Scalars["Boolean"]["output"];
  /** The aspect ratio of the image */
  aspectRatio?: Maybe<Scalars["Float"]["output"]>;
  /** The blurhash of the image */
  blurhash?: Maybe<Scalars["String"]["output"]>;
  /**
   * The size of the file in bytes
   * @deprecated Use byteSizeV2 instead
   */
  byteSize?: Maybe<Scalars["Int"]["output"]>;
  /** The size of the file in bytes */
  byteSizeV2?: Maybe<Scalars["BigInt"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The name of the file */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The height of the image */
  height?: Maybe<Scalars["Int"]["output"]>;
  /** The ID of the attachment */
  id: Scalars["ID"]["output"];
  /** The moderation result of the attachment */
  moderationResult?: Maybe<ModerationResults>;
  /** The position of the attachment */
  position?: Maybe<Scalars["Int"]["output"]>;
  /** The preview of the image */
  preview: AttachmentSource;
  /** A signed ID of the attachment to directly query the attachment */
  signedId?: Maybe<Scalars["ID"]["output"]>;
  /** The source of the attachment */
  source: AttachmentSource;
  /** The source URL of the attachment */
  sourceUrl?: Maybe<Scalars["String"]["output"]>;
  /** The width of the image */
  width?: Maybe<Scalars["Int"]["output"]>;
};

/** Represents an image attachment */
export type ImageAttachmentPreviewArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Represents an image attachment */
export type ImageAttachmentSourceArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Predefined attachment variants */
export enum ImageAttachmentVariants {
  Legacy = "legacy",
  Original = "original",
  S16 = "s16",
  S20 = "s20",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S48fit = "s48fit",
  S64 = "s64",
  S64fit = "s64fit",
  S80 = "s80",
  S80fit = "s80fit",
  S128 = "s128",
  S180 = "s180",
  S250x125 = "s250x125",
  S250x125fit = "s250x125fit",
  S440x220 = "s440x220",
  S440x220fit = "s440x220fit",
  S500x250 = "s500x250",
  S500x250fit = "s500x250fit",
  S512x288 = "s512x288",
  S512x288fit = "s512x288fit",
  S600x200 = "s600x200",
  S600x400 = "s600x400",
  S600x400fit = "s600x400fit",
  S720x1280 = "s720x1280",
  S720x1280fit = "s720x1280fit",
  S800x200 = "s800x200",
  S900x300 = "s900x300",
  S1000x500 = "s1000x500",
  S1000x500fit = "s1000x500fit",
  S1080x1920 = "s1080x1920",
  S1080x1920fit = "s1080x1920fit",
  S1080x1920fitH264Vq7 = "s1080x1920fit_h264_vq7",
  S1200x630 = "s1200x630",
  S1280x720 = "s1280x720",
  S1280x720fit = "s1280x720fit",
  S1600x400 = "s1600x400",
  S1920x1080 = "s1920x1080",
  S1920x1080fit = "s1920x1080fit",
  S1920x1080fitH264Vq7 = "s1920x1080fit_h264_vq7",
  X2 = "x2",
  X5 = "x5",
}

/** Allowed image file types for uploading to the platform */
export enum ImageExtensions {
  Gif = "GIF",
  Jpeg = "JPEG",
  Jpg = "JPG",
  Png = "PNG",
  Svg = "SVG",
  Webp = "WEBP",
}

/** Image styles for image. */
export enum ImageImageStyles {
  Original = "original",
  S16 = "s16",
  S20 = "s20",
  S24 = "s24",
  S32 = "s32",
  S40 = "s40",
  S48 = "s48",
  S48fit = "s48fit",
  S64 = "s64",
  S64fit = "s64fit",
  S80 = "s80",
  S80fit = "s80fit",
  S128 = "s128",
  S180 = "s180",
  S250x125 = "s250x125",
  S250x125fit = "s250x125fit",
  S440x220 = "s440x220",
  S440x220fit = "s440x220fit",
  S500x250 = "s500x250",
  S500x250fit = "s500x250fit",
  S512x288 = "s512x288",
  S512x288fit = "s512x288fit",
  S600x200 = "s600x200",
  S600x400 = "s600x400",
  S600x400fit = "s600x400fit",
  S800x200 = "s800x200",
  S900x300 = "s900x300",
  S1000x500 = "s1000x500",
  S1000x500fit = "s1000x500fit",
  S1200x630 = "s1200x630",
  S1280x720 = "s1280x720",
  S1280x720fit = "s1280x720fit",
  S1600x400 = "s1600x400",
  S1920x1080 = "s1920x1080",
  S1920x1080fit = "s1920x1080fit",
}

/** Image urls in two sizes for img[srcset]. */
export type ImgSrcset = {
  __typename?: "ImgSrcset";
  /** Image url with double image resolution. */
  double: Scalars["String"]["output"];
  /** If the attachment should be rendered without sound or controls */
  isAnimated: Scalars["Boolean"]["output"];
  /** If the attachment should be rendered with sound and controls */
  isVideo: Scalars["Boolean"]["output"];
  /** Image url with requested image resolution. */
  original: Scalars["String"]["output"];
};

/** The different error codes for instant payouts */
export enum InstantPayoutErrorCodes {
  /** Account Daily Limit Reached */
  AccountDailyLimitReached = "account_daily_limit_reached",
  /** Amount Too High */
  AmountTooHigh = "amount_too_high",
  /** Feature Disabled */
  FeatureDisabled = "feature_disabled",
  /** Only Us Accounts */
  OnlyUsAccounts = "only_us_accounts",
  /** Only Usd */
  OnlyUsd = "only_usd",
  /** Platform Daily Limit Reached */
  PlatformDailyLimitReached = "platform_daily_limit_reached",
  /** Restricted Account */
  RestrictedAccount = "restricted_account",
  /** Unsupported External Account */
  UnsupportedExternalAccount = "unsupported_external_account",
}

/** An object representing the status of using instant payouts on an account. */
export type InstantPayoutsStatus = {
  __typename?: "InstantPayoutsStatus";
  /** The error code, if any. */
  errorCode?: Maybe<InstantPayoutErrorCodes>;
  /** The error message, if any. */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
};

/** Autogenerated input type of InviteUserToAccessPass */
export type InviteUserToAccessPassInput = {
  /** The ID of the access pass */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user to invite */
  userId: Scalars["ID"]["input"];
};

/** An object representing an ItemOrdering object, used to store the order of a list of items. */
export type ItemOrdering = {
  __typename?: "ItemOrdering";
  /** The ordering array to store. */
  data: Scalars["JSON"]["output"];
  /** The ID of the ItemOrdering object. */
  id: Scalars["ID"]["output"];
  /** The type of ordering to update. */
  orderType: ItemOrderingOrderTypes;
};

/** A type of order that the ItemOrdering represents. */
export enum ItemOrderingOrderTypes {
  /** Experience */
  Experience = "experience",
  /** Hub Creator */
  HubCreator = "hub_creator",
  /** Hub Customer */
  HubCustomer = "hub_customer",
}

/** The status of a job and any pertinent data associated with it. */
export type JobStatus = {
  __typename?: "JobStatus";
  /** The data returned by the job. */
  data?: Maybe<Scalars["JSON"]["output"]>;
  /** The status of the job. */
  status?: Maybe<JobStatuses>;
};

/** See Sidekiq status documentation: https://github.com/utgarda/sidekiq-status */
export enum JobStatuses {
  /** The job has finished. */
  Complete = "complete",
  /** The job has failed. */
  Failed = "failed",
  /** The job was interrupted. Usually caused by a deploy or server restart. */
  Interrupted = "interrupted",
  /** The job is in the queue and waiting to be processed. */
  Queued = "queued",
  /** An iteration of the job failed and is now being retried. */
  Retrying = "retrying",
  /** Don't know what the status is. */
  Unknown = "unknown",
  /** The job is currently being processed. */
  Working = "working",
}

/** Autogenerated input type of JoinFreeAccessPass */
export type JoinFreeAccessPassInput = {
  /** The ID of the access pass to join */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the user is joining from a direct to consumer link */
  directToConsumer?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated input type of KickFromAWhop */
export type KickFromAWhopInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the member object. */
  id: Scalars["ID"]["input"];
};

/** A large card featuring a single product. */
export type LargeCard = DiscoveryModuleInterface & {
  __typename?: "LargeCard";
  /** A product collection. */
  collection: DiscoveryCollection;
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** An object representing a lead (someone who is interested in a whop). */
export type Lead = {
  __typename?: "Lead";
  /** The access pass the lead is interested in, if available. */
  accessPass: AccessPass;
  /** The timestamp of when the lead was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The email of the lead, if available. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the lead. */
  id: Scalars["ID"]["output"];
  /** The converted member, if any. */
  member?: Maybe<CompanyMember>;
  /** The user who is the lead. */
  user: PublicProfileUser;
};

/** The connection type for Lead. */
export type LeadConnection = {
  __typename?: "LeadConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LeadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Lead>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LeadEdge = {
  __typename?: "LeadEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Lead>;
};

/** The return type for a leaderboard. */
export type Leaderboard = {
  __typename?: "Leaderboard";
  /** The type of leaderboard that was returned */
  leaderboardType: LeaderboardTypes;
  /** The results of the leaderboard */
  results: Array<LeaderboardResult>;
  /** The target prefix for the leaderboard that was returned */
  targetPrefix?: Maybe<Scalars["String"]["output"]>;
  /** The total count of the leaderboard */
  totalCount?: Maybe<Scalars["Int"]["output"]>;
};

/** The return type for a leaderboard. */
export type LeaderboardResult = {
  __typename?: "LeaderboardResult";
  /** The access_pass that was fetched (if applicable) */
  accessPass?: Maybe<PublicAccessPass>;
  /** The current pagination rank of the access_pass */
  currentPaginationRank?: Maybe<Scalars["Int"]["output"]>;
  /** The current rank of the access_pass */
  currentRank?: Maybe<Scalars["Int"]["output"]>;
  /** The current score of the access_pass */
  currentScore?: Maybe<Scalars["Float"]["output"]>;
  /** Whether or not the rank is a fake injection */
  isFakeRank: Scalars["Boolean"]["output"];
  /** The previous rank of the access_pass */
  previousRank?: Maybe<Scalars["Int"]["output"]>;
  /** The previous score of the access_pass */
  previousScore?: Maybe<Scalars["Float"]["output"]>;
  /** The user that was fetched (if applicable) */
  user?: Maybe<PublicProfileUser>;
};

/** The return type for a leaderboard with a single result. */
export type LeaderboardSingle = {
  __typename?: "LeaderboardSingle";
  /** The type of leaderboard that was returned */
  leaderboardType: LeaderboardTypes;
  /** The result of the leaderboard fetch, if available. */
  result?: Maybe<LeaderboardResult>;
  /** The target prefix for the leaderboard that was returned */
  targetPrefix?: Maybe<Scalars["String"]["output"]>;
  /** The total count of the leaderboard */
  totalCount?: Maybe<Scalars["Int"]["output"]>;
};

/** The different types of leaderboards that can be fetched */
export enum LeaderboardTypes {
  AffiliateEarnings = "affiliate_earnings",
  AverageTimeSpent = "average_time_spent",
  Competition = "competition",
  MoneyEarnedLast_7Days = "money_earned_last_7_days",
  MoneyEarnedLast_24Hours = "money_earned_last_24_hours",
  MoneyEarnedLast_30Days = "money_earned_last_30_days",
  NewUsers = "new_users",
  TopRated = "top_rated",
  TotalTimeSpent = "total_time_spent",
  UsdGmv = "usd_gmv",
}

/** Which columns can be used to sort. */
export enum LeadsSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
}

/** Autogenerated input type of LeaveAWhop */
export type LeaveAWhopInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the member object. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of LeaveStage */
export type LeaveStageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed ID for the room to update */
  feedId: Scalars["ID"]["input"];
};

/** Represents a LedgerAccount. */
export type LedgerAccount = {
  __typename?: "LedgerAccount";
  /** The balance cache associated with the account by currency. */
  balanceCache?: Maybe<BalanceCache>;
  /** The balances associated with the account. */
  balanceCaches: BalanceCacheConnection;
  /** The ConnectedAccount associated with the LedgerAccount. */
  connectedAccount?: Maybe<ConnectedAccount>;
  /** The ledger accounts that can be copied from. */
  copyableLedgerAccounts: CopyableLedgerAccountConnection;
  /** The timestamp of when the ledger account was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The credit transactions associated with the account. */
  creditTransactions: PublicCreditTransactionConnection;
  /** Exports the credit transactions associated with the account, with the given filters. */
  creditTransactionsExport: Export;
  /** The ID of the LedgerAccount. */
  id: Scalars["ID"]["output"];
  /** The logo for the account. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The fee for instant payouts, if applicable. */
  instantPayoutFee: Scalars["Float"]["output"];
  /** The status of instant payouts on the account. */
  instantPayoutsStatus: InstantPayoutsStatus;
  /** The audit stat associated with the account, updated every 4 hours, if the account has any lifetime payments. */
  ledgerAccountAuditStat?: Maybe<LedgerAccountAuditStat>;
  /** The type of ledger account. */
  ledgerType: LedgerTypes;
  /** The parent ledger account, if any. */
  parent?: Maybe<LedgerAccount>;
  /** The percentage of the balance that is reserved. */
  reservePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The owner of the ledger account. */
  resourceOwner: PublicLedgerAccountOwner;
  /** The type of resource that owns this ledger account. */
  resourceOwnerType: Scalars["String"]["output"];
  /** The StripeAccount associated with the LedgerAccount. */
  stripeAccount?: Maybe<StripeAccount>;
  /** The title of the ledger account (to display on checkout). */
  title: Scalars["String"]["output"];
  /** The fee for transfers, if applicable. */
  transferFee?: Maybe<Scalars["Float"]["output"]>;
  /** The timestamp of when the ledger account was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
  /** The day for automatic withdrawals to withdraw funds on. 1-31 for monthly, 0-6 for weekly. */
  withdrawalDay?: Maybe<Scalars["Int"]["output"]>;
  /** The frequency of withdrawals. */
  withdrawalFrequency: LedgerWithdrawalFrequencies;
  /** The status of withdrawals on the account. */
  withdrawalStatus: LedgerWithdrawalStatuses;
  /** The withdrawals associated with the account. */
  withdrawals: PublicWithdrawalConnection;
  /** Exports the withdrawals associated with the account, with the given filters. */
  withdrawalsExport: Export;
};

/** Represents a LedgerAccount. */
export type LedgerAccountBalanceCacheArgs = {
  currency: Currencies;
};

/** Represents a LedgerAccount. */
export type LedgerAccountBalanceCachesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  currencies?: InputMaybe<Array<Currencies>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountCopyableLedgerAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountCreditTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<CreditTransactionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountCreditTransactionsExportArgs = {
  filter?: InputMaybe<CreditTransactionFilters>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountInstantPayoutsStatusArgs = {
  currency: Currencies;
};

/** Represents a LedgerAccount. */
export type LedgerAccountWithdrawalsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<WithdrawalFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a LedgerAccount. */
export type LedgerAccountWithdrawalsExportArgs = {
  filter?: InputMaybe<WithdrawalFilters>;
};

/** The audit stat associated with a ledger account, updated every 4 hours, if the ledger account has any lifetime payments. */
export type LedgerAccountAuditStat = {
  __typename?: "LedgerAccountAuditStat";
  /** The dispute risk level of the account based on the last 90 days, if any. */
  disputeRiskLevel?: Maybe<DisputeRiskLevels>;
  /** The dispute risk score GMV in the last 90 days, if any. */
  disputeRiskScoreGmv: Scalars["Float"]["output"];
  /** The dispute risk score rate in the last 90 days, if any. */
  disputeRiskScoreRate: Scalars["Float"]["output"];
  /** The ID of the ledger account audit stat */
  id: Scalars["ID"]["output"];
  /** The standing of the ledger account, if any. */
  ledgerAccountStanding: LedgerAccountStandings;
  /** The number of valid payments in the lifetime of the account. */
  lifetimeValidPaymentsCount: Scalars["Int"]["output"];
  /** The average charge risk score in the last 90 days, if any. */
  ninetyDayAverageChargeRiskScore?: Maybe<Scalars["Float"]["output"]>;
  /** The number of dispute alerts in the last 90 days. */
  ninetyDayDisputeAlertCount?: Maybe<Scalars["Int"]["output"]>;
  /** The disputed GMV in the last 90 days, if any. */
  ninetyDayDisputeAlertGmv?: Maybe<Scalars["Float"]["output"]>;
  /** The disputed GMV percentage in the last 90 days, if any. */
  ninetyDayDisputeAlertGmvPercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The dispute alert rate in the last 90 days, if any. */
  ninetyDayDisputeAlertRate?: Maybe<Scalars["Float"]["output"]>;
  /** The number of disputes in the last 90 days. */
  ninetyDayDisputeCount?: Maybe<Scalars["Int"]["output"]>;
  /** The dispute rate in the last 90 days, if any. */
  ninetyDayDisputeRate?: Maybe<Scalars["Float"]["output"]>;
  /** The disputed GMV in the last 90 days, if any. */
  ninetyDayDisputedGmv?: Maybe<Scalars["Float"]["output"]>;
  /** The disputed GMV percentage in the last 90 days, if any. */
  ninetyDayDisputedGmvPercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The number of payments in the last 90 days. */
  ninetyDayPaymentsCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total GMV of payments in the last 90 days. */
  ninetyDayPaymentsGmv?: Maybe<Scalars["Float"]["output"]>;
  /** The number of resolution center cases in the last 90 days. */
  ninetyDayResolutionCenterCasesCount?: Maybe<Scalars["Int"]["output"]>;
  /** The resolution center cases GMV in the last 90 days, if any. */
  ninetyDayResolutionCenterCasesGmv?: Maybe<Scalars["Float"]["output"]>;
  /** The resolution center cases GMV percentage in the last 90 days, if any. */
  ninetyDayResolutionCenterCasesGmvPercentage?: Maybe<
    Scalars["Float"]["output"]
  >;
  /** The resolution center case rate in the last 90 days, if any. */
  ninetyDayResolutionCenterCasesRate?: Maybe<Scalars["Float"]["output"]>;
};

/** The connection type for LedgerAccount. */
export type LedgerAccountConnection = {
  __typename?: "LedgerAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LedgerAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LedgerAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The different copy modes that can be used. */
export enum LedgerAccountCopyModes {
  Clone = "clone",
  Prefill = "prefill",
}

/** An edge in a connection. */
export type LedgerAccountEdge = {
  __typename?: "LedgerAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<LedgerAccount>;
};

/** The standing of a ledger account, based on their dispute risk scores */
export enum LedgerAccountStandings {
  AtRisk = "at_risk",
  Good = "good",
}

/** The types of ledgers that can be created. */
export enum LedgerTypes {
  /** Pool */
  Pool = "pool",
  /** Primary */
  Primary = "primary",
}

/** The different withdrawal frequencies a LedgerAccount can have */
export enum LedgerWithdrawalFrequencies {
  /** Daily */
  Daily = "daily",
  /** Manual */
  Manual = "manual",
  /** Monthly */
  Monthly = "monthly",
  /** Weekly */
  Weekly = "weekly",
}

/** The different statuses a LedgerAccount's withdrawal_status can be */
export enum LedgerWithdrawalStatuses {
  /** Active */
  Active = "active",
  /** Inactive */
  Inactive = "inactive",
}

/** An access pass that has been liked by the current user */
export type LikedAccessPass = {
  __typename?: "LikedAccessPass";
  /** The access pass that has been liked. */
  accessPass: PublicAccessPass;
  /** When the current user upvoted this access pass. */
  upvotedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for LikedAccessPass. */
export type LikedAccessPassConnection = {
  __typename?: "LikedAccessPassConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LikedAccessPassEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LikedAccessPass>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LikedAccessPassEdge = {
  __typename?: "LikedAccessPassEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<LikedAccessPass>;
};

/** The order to sort liked discover access passes by. */
export enum LikedDiscoverAccessPassesOrder {
  /** Sort by promo code presence first, then rated at date */
  PromoCodeAndRatedAt = "promo_code_and_rated_at",
  /** Sort by when the access pass was rated */
  RatedAt = "rated_at",
}

/** An object representing a line item. */
export type LineItem = {
  __typename?: "LineItem";
  /** An array of the accepted payment methods for the line item. */
  acceptedPaymentMethods: Array<AcceptedPaymentMethods>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity: Scalars["Boolean"]["output"];
  /** The amount of the line item. */
  amount: Scalars["Float"]["output"];
  /** The amount of the line item in USD. */
  amountUsd: Scalars["Float"]["output"];
  /** The app that the line item was created by / for. */
  app?: Maybe<PublicApp>;
  /** The respective currency identifier for the plan. */
  baseCurrency: Currencies;
  /** Whether or not the line item requires a billing setup. */
  billingSetupRequired: Scalars["Boolean"]["output"];
  /** The buyer fee percentage to apply to the transaction, if any. */
  buyerFeePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The payment processors that support the buyer fee, if any. */
  buyerFeeSupportedProcessors: Array<PaymentProcessor>;
  /** Whether or not the line item collects tax. */
  collectTax: Scalars["Boolean"]["output"];
  /** The company for the line item. */
  company?: Maybe<PublicCompany>;
  /** The timestamp of when the line item was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the line item. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the line item expires, if applicable. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The internal ID of the line item. */
  id: Scalars["ID"]["output"];
  /** The ledger account for the line item. */
  ledgerAccount?: Maybe<PublicLedgerAccount>;
  /** Whether or not the company is the merchant of record. Uses the line item's current stripe account. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** The name of the line item. */
  name: Scalars["String"]["output"];
  /** Used for the Stripe Payment element. If present, pass this value as the on_behalf_of parameter. */
  onBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Payment Request Button. If present, pass this value as the on_behalf_of parameter. */
  paymentRequestOnBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** The capabilities of the stripe account. */
  paymentsCapabilities: Array<Scalars["String"]["output"]>;
  /** Optional URL to redirect to after successful checkout. */
  redirectUrl?: Maybe<Scalars["String"]["output"]>;
  /** The setup future usage for the line item, if applicable. */
  setupFutureUsage?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the promo code input should be shown on checkout. */
  showPromoCodeInput: Scalars["Boolean"]["output"];
  /** The countries to skip tax quoting for. */
  skipTaxQuotingCountries: Array<Scalars["String"]["output"]>;
  /** The stripe account id to use for setting up this line item's stripe.js */
  stripeAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe payment method configuration id to use for setting up the stripe.js elements */
  stripePaymentMethodConfigurationId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe public key to use for setting up this line item's stripe.js */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the line item. */
  taxType: TaxTypes;
  /** The terms and conditions for the line item. */
  termsAndConditions: Scalars["String"]["output"];
  /** Whether or not to use the Basis Theory element during checkout. */
  useBasisTheory: Scalars["Boolean"]["output"];
};

/** Represents a link embed in a feed */
export type LinkEmbed = {
  __typename?: "LinkEmbed";
  /** The description of the linked content */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the favicon for the linked site */
  favicon?: Maybe<Scalars["String"]["output"]>;
  /** The URL of an image representing the linked content */
  image?: Maybe<Scalars["String"]["output"]>;
  /** Whether the link embed is still being processed */
  processing: Scalars["Boolean"]["output"];
  /** The title of the linked content */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the linked content */
  url: Scalars["String"]["output"];
};

/** Input for a link embed */
export type LinkEmbedInput = {
  /** The URL of the linked content */
  url: Scalars["String"]["input"];
};

/** A stack of products with very recent activity. */
export type LiveStack = DiscoveryModuleInterface & {
  __typename?: "LiveStack";
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** Possible livestream destinations a user can restream to */
export enum LivestreamDestination {
  /** Facebook */
  Facebook = "facebook",
  /** Instagram */
  Instagram = "instagram",
  /** Kick */
  Kick = "kick",
  /** Rumble */
  Rumble = "rumble",
  /** Steam */
  Steam = "steam",
  /** Telegram */
  Telegram = "telegram",
  /** Twitch */
  Twitch = "twitch",
  /** Vimeo */
  Vimeo = "vimeo",
  /** X */
  X = "x",
  /** Youtube */
  Youtube = "youtube",
}

/** Represents a livestream feed */
export type LivestreamFeed = BaseEntityInterface & {
  __typename?: "LivestreamFeed";
  /** The most relevant access pass this livestream is in which the user has access to */
  accessPasses: PublicAccessPassConnection;
  /** The experiences for this livestream which the user has access to */
  accessibleExperiences: AccessibleExperienceConnection;
  /** Whether or not media is banned in this livestream */
  banMedia: Scalars["Boolean"]["output"];
  /** Whether or not URLs are banned in this livestream */
  banUrls: Scalars["Boolean"]["output"];
  /** List of banned words in this livestream */
  bannedWords: Array<Scalars["String"]["output"]>;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The description of the livestream */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The number of seconds the livestream will remain open if no one joins */
  emptyTimeout: Scalars["Int"]["output"];
  /** The time the livestream ended at */
  endedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /**
   * The ID of the livestream experience (used for some old client that is still around)
   * @deprecated Use experiences instead
   */
  experienceId: Scalars["ID"]["output"];
  /** The experiences for this livestream. There can be max 25. */
  experiences: Array<PublicExperience>;
  /** The user who is hosting this livestream */
  host?: Maybe<PublicProfileUser>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The number of participants that can join the livestream (0 is unlimited) */
  maxParticipants: Scalars["Int"]["output"];
  /** The livestream metadata */
  metadata: Scalars["JSON"]["output"];
  /** The name of the livestream room */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not live reactions are enabled in this livestream */
  reactionsEnabled: Scalars["Boolean"]["output"];
  /** The link to the recording */
  recording?: Maybe<AttachmentInterface>;
  /** The link to the recording */
  recordingUrl?: Maybe<Scalars["String"]["output"]>;
  /** The time the livestream is scheduled for */
  scheduledAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the livestream started at */
  startedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The link to the thumbnail */
  thumbnailUrl?: Maybe<Scalars["String"]["output"]>;
  /** The title of the livestream */
  title: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The number of seconds a user needs to wait before posting again, if any */
  userPostsCooldownSeconds?: Maybe<Scalars["Int"]["output"]>;
  /** The webhooks for the feed */
  webhooks: FeedWebhookConnection;
  /** Who can post on this livestream chat */
  whoCanPost: LivestreamWhoCanPostTypes;
  /** Who can react on this livestream chat */
  whoCanReact: LivestreamWhoCanReactTypes;
};

/** Represents a livestream feed */
export type LivestreamFeedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  direction: Direction;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order: AccessPassOrder;
};

/** Represents a livestream feed */
export type LivestreamFeedAccessibleExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a livestream feed */
export type LivestreamFeedWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An experience activity card about a livestream */
export type LivestreamFeedCard = ExperienceActivityCardInterface & {
  __typename?: "LivestreamFeedCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The livestream feed that this card is about */
  livestreamFeed?: Maybe<LivestreamFeed>;
  /**
   * The thumbnail url for the livestream feed
   * @deprecated Use livestreamFeed.thumbnailUrl instead
   */
  thumbnailUrl?: Maybe<Scalars["String"]["output"]>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The connection type for LivestreamFeed. */
export type LivestreamFeedConnection = {
  __typename?: "LivestreamFeedConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LivestreamFeedEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LivestreamFeed>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LivestreamFeedEdge = {
  __typename?: "LivestreamFeedEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<LivestreamFeed>;
};

/** Input for a livestream feed */
export type LivestreamFeedInput = {
  /** Whether or not media is banned in this livestream */
  banMedia?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not URLs are banned in this livestream */
  banUrls?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** List of banned words in this livestream */
  bannedWords?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The description of this livestream */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The empty timeout of this livestream */
  emptyTimeout?: InputMaybe<Scalars["Int"]["input"]>;
  /** The unique identifier for the feed */
  id?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The number of participants that can join the livestream (0 is unlimited) */
  maxParticipants?: InputMaybe<Scalars["Int"]["input"]>;
  /** The metadata of this livestream */
  metadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /** Whether or not live reactions are enabled in this livestream */
  reactionsEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The destinations to restream to */
  restreamDestinations?: InputMaybe<Array<LivestreamDestination>>;
  /** The scheduled time of this livestream */
  scheduledAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The title of this livestream */
  title?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of seconds a user needs to wait before posting again, if any */
  userPostsCooldownSeconds?: InputMaybe<Scalars["Int"]["input"]>;
  /** Who can post on this livestream */
  whoCanPost?: InputMaybe<LivestreamWhoCanPostTypes>;
  /** Who can react on this livestream */
  whoCanReact?: InputMaybe<LivestreamWhoCanReactTypes>;
};

/** A LiveKit ingress for a livestream */
export type LivestreamIngress = {
  __typename?: "LivestreamIngress";
  /** The stream key of the ingress */
  streamKey: Scalars["String"]["output"];
  /** The url of the ingress */
  url: Scalars["String"]["output"];
};

/** Actions an admin can take on a participant */
export enum LivestreamParticipantAction {
  Audience = "audience",
  Speaker = "speaker",
}

/** Represents a livestream stream key */
export type LivestreamStreamKey = {
  __typename?: "LivestreamStreamKey";
  /** The restream destination */
  destination: LivestreamDestination;
  /** The unique identifier for the stream key */
  id: Scalars["ID"]["output"];
  /** The stream key of the destination */
  key: Scalars["String"]["output"];
};

/** Who can post on a livestream feed */
export enum LivestreamWhoCanPostTypes {
  Admins = "admins",
  Everyone = "everyone",
}

/** Who can react on a livestream feed */
export enum LivestreamWhoCanReactTypes {
  Everyone = "everyone",
  NoOne = "no_one",
}

/** A log entry for resources across the site. */
export type Log = {
  __typename?: "Log";
  /** The action/event that was performed. */
  action?: Maybe<Scalars["String"]["output"]>;
  /** When the log was created. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The unique identifier for the log. */
  id: Scalars["ID"]["output"];
  /**
   * The user who is made the action.
   * @deprecated This type has been deprecated. Use userAccount instead.
   */
  user?: Maybe<PublicUser>;
  /** The user account that performed the action. */
  userAccount?: Maybe<PublicProfileUser>;
};

/** The connection type for Log. */
export type LogConnection = {
  __typename?: "LogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Log>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type LogEdge = {
  __typename?: "LogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Log>;
};

/** Autogenerated input type of LogoutAllDevices */
export type LogoutAllDevicesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of Logout */
export type LogoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The FCM token to remove */
  fcmToken?: InputMaybe<Scalars["String"]["input"]>;
};

/** A specific plan that a user has been added to refer. */
export type MadeForYouPlan = {
  __typename?: "MadeForYouPlan";
  /** The link the affiliate can use to refer people */
  directLink: Scalars["String"]["output"];
  /** How much the affiliate earns */
  formattedPayout: Scalars["String"]["output"];
  /** Describes how much the affiliate will earn. */
  payoutDescription: Scalars["String"]["output"];
  /** The plan for this affiliate */
  plan: PublicPlan;
  /** The total number of referrals the affiliate has made */
  totalReferrals: Scalars["Int"]["output"];
  /** The total amount of rewards the affiliate has earned */
  totalRewards: Scalars["Float"]["output"];
};

/** The connection type for MadeForYouPlan. */
export type MadeForYouPlanConnection = {
  __typename?: "MadeForYouPlanConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MadeForYouPlanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MadeForYouPlan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MadeForYouPlanEdge = {
  __typename?: "MadeForYouPlanEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MadeForYouPlan>;
};

/** Values to filter made for you affiliates on */
export type MadeForYouPlanFilters = {
  /** Search by plan name, product name, or company name */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** A physical address, submitted by either a User or Company Buyer, and stored on their account. */
export type MailingAddress = {
  __typename?: "MailingAddress";
  /** The city of the address. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** The country of the address. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** The date and time the address was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the payment token */
  id: Scalars["ID"]["output"];
  /** The IP address of the customer. */
  ipAddress?: Maybe<Scalars["String"]["output"]>;
  /** The line 1 of the address. */
  line1?: Maybe<Scalars["String"]["output"]>;
  /** The line 2 of the address. */
  line2?: Maybe<Scalars["String"]["output"]>;
  /** The name of the customer. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The postal code of the address. */
  postalCode?: Maybe<Scalars["String"]["output"]>;
  /** The state of the address. */
  state?: Maybe<Scalars["String"]["output"]>;
  /** The date and time the address was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for MailingAddress. */
export type MailingAddressConnection = {
  __typename?: "MailingAddressConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MailingAddressEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MailingAddress>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MailingAddressEdge = {
  __typename?: "MailingAddressEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MailingAddress>;
};

/** The sub-items that should be displayed for the stripe account. */
export enum ManagementItems {
  BillingDetails = "billing_details",
  Country = "country",
  MerchantOfRecord = "merchant_of_record",
  PayoutFrequency = "payout_frequency",
}

/** Autogenerated input type of ManualCharge */
export type ManualChargeInput = {
  /** The amount to charge the member (ex. 10.00). */
  amount: Scalars["Float"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency to charge the member in (ex. USD). */
  currency: Currencies;
  /** The ID of the member to charge. */
  memberId: Scalars["ID"]["input"];
  /** The internal ID of the payment method the user wants to use to purchase (if applicable). (pmt_, payt_, pm_, or ctoken_) */
  paymentMethodId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of MarkExperienceRead */
export type MarkExperienceReadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The experience to mark notifications as read for */
  experienceId: Scalars["ID"]["input"];
  /**
   * The external ID to mark notifications as read up until
   * @deprecated Not supported
   */
  externalId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of MarkFeedPostsAsViewed */
export type MarkFeedPostsAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The posts to mark as viewed */
  posts: Array<PostInput>;
};

/** Autogenerated input type of MarkPostsAsViewed */
export type MarkPostsAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed id to mark the posts as viewed in */
  feedId: Scalars["ID"]["input"];
  /** The feed type to mark the posts as viewed in */
  feedType: FeedTypes;
  /** The post ids to mark as viewed */
  postIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of MarkSetSettlementAddress */
export type MarkSetSettlementAddressInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Coinbase account to update. */
  id: Scalars["ID"]["input"];
};

/** An application to the marketplace */
export type MarketplaceApplication = {
  __typename?: "MarketplaceApplication";
  /** Timestamp of when the application was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The decline reason, if any */
  declineReason?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the application. */
  id: Scalars["ID"]["output"];
  /** The status of the application */
  status: MarketplaceStatuses;
};

/** The connection type for MarketplaceApplication. */
export type MarketplaceApplicationConnection = {
  __typename?: "MarketplaceApplicationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MarketplaceApplicationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MarketplaceApplication>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Information about the launch settings of a company */
export type MarketplaceApplicationCriteria = {
  __typename?: "MarketplaceApplicationCriteria";
  /** Whether the criteria was met */
  criteriaMet: Scalars["Boolean"]["output"];
  /** The description of the criteria */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The identifier of the criteria */
  identifier: ApplicationCriteriaIdentifier;
  /** The name of the criteria */
  name: Scalars["String"]["output"];
  /** Whether the criteria is required */
  required: Scalars["Boolean"]["output"];
};

/** An edge in a connection. */
export type MarketplaceApplicationEdge = {
  __typename?: "MarketplaceApplicationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MarketplaceApplication>;
};

/** A category that describes what the object offers. */
export type MarketplaceCategory = {
  __typename?: "MarketplaceCategory";
  /** The ancestor categories of this category. */
  ancestorMarketplaceCategories: Array<MarketplaceCategory>;
  /** The child categories of this category. */
  childrenMarketplaceCategories: MarketplaceCategoryConnection;
  /** A description of the category. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the category should be displayed on the homepage. */
  displayOnHomepage: Scalars["Boolean"]["output"];
  /** A unique identifier for the category. */
  id: Scalars["ID"]["output"];
  /** The level of the category. */
  level: Scalars["Int"]["output"];
  /** The number of live access passes in the category. */
  liveAccessPassCount: Scalars["Int"]["output"];
  /** The number of live pages in the category. */
  livePageCount: Scalars["Int"]["output"];
  /** The type of category. */
  marketplaceCategoryType: MarketplaceCategoryTypes;
  /** The name of the category. */
  name: Scalars["String"]["output"];
  /** The parent category of this category, if any. */
  parentMarketplaceCategory?: Maybe<MarketplaceCategory>;
  /** The route of the category. */
  route: Scalars["String"]["output"];
  /** The tagline of the category. */
  tagline?: Maybe<Scalars["String"]["output"]>;
};

/** A category that describes what the object offers. */
export type MarketplaceCategoryChildrenMarketplaceCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for MarketplaceCategory. */
export type MarketplaceCategoryConnection = {
  __typename?: "MarketplaceCategoryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MarketplaceCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MarketplaceCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MarketplaceCategoryEdge = {
  __typename?: "MarketplaceCategoryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MarketplaceCategory>;
};

/** The columns that can be used to order. */
export enum MarketplaceCategoryOrder {
  CreatedAt = "created_at",
  Id = "id",
  LiveAccessPassCount = "live_access_pass_count",
  LivePageCount = "live_page_count",
  ManualPosition = "manual_position",
  Name = "name",
  Random = "random",
}

/** The marketplace types that are available for categories. */
export enum MarketplaceCategoryTypes {
  /** App */
  App = "app",
  /** Regular */
  Regular = "regular",
}

/** The stats for the marketplace */
export type MarketplaceStats = {
  __typename?: "MarketplaceStats";
  /** The number of active sellers */
  activeSellers: Scalars["Int"]["output"];
  /** The total number of active users */
  activeUsers: Scalars["Int"]["output"];
  /** The total number of memberships sold */
  membershipsSold: Scalars["Int"]["output"];
  /** The total amount of money processed by the marketplace */
  totalProcessed: Scalars["Int"]["output"];
  /** The total number of products sold */
  totalProducts: Scalars["Int"]["output"];
};

/** The available marketplace statuses to choose from. */
export enum MarketplaceStatuses {
  LiveMarketplace = "live_marketplace",
  NotAvailable = "not_available",
  PendingReview = "pending_review",
}

export enum Media {
  Audio = "audio",
  Image = "image",
  Other = "other",
  Video = "video",
}

/** A user of the site. */
export type Member = {
  __typename?: "Member";
  /** How many memberships the member has. */
  activeMembershipsCount: Scalars["Int"]["output"];
  /** The ID of the member's default Discord account. */
  discordAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The username of the member's default Discord account. */
  discordUsername?: Maybe<Scalars["String"]["output"]>;
  /** The digital mailing address of the member. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The experiences a user has access to for a company. */
  experiences?: Maybe<Array<Experience>>;
  /** The header to show on the customers page */
  header: Scalars["String"]["output"];
  /** The internal ID of the user account for the member. */
  id: Scalars["ID"]["output"];
  /** When the user first purchased a membership for the company. */
  joinedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The logs for all of the user's memberships for a company. */
  logsV2?: Maybe<LogConnection>;
  /** An internal note a business can save regarding the user. */
  memberNotes?: Maybe<Array<MemberNote>>;
  /** Additional statistics about the member. */
  memberStats: MemberStats;
  /**
   * All of the user's memberships for a company.
   * @deprecated Use membershipsV2
   */
  memberships: Array<Membership>;
  /** All of the user's memberships for a company. */
  membershipsV2: MembershipConnection;
  /** An estimated MRR for the member. */
  mrr?: Maybe<Scalars["String"]["output"]>;
  /** The written name of the member. */
  name?: Maybe<Scalars["String"]["output"]>;
  /**
   * The NFT tokens the membership has access to.
   * @deprecated USED BY OLD DASHBOARD MOBILE APP.
   */
  nftTokens: Array<NftToken>;
  /** Their next closest membership cancel date, if applicable. */
  passCancelingAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** An image that represents a member via their profile. */
  profilePhoto?: Maybe<Scalars["String"]["output"]>;
  /**
   * The URL of the user's profile picture
   * @deprecated Use profileImageSrcset instead
   */
  profilePic: Scalars["String"]["output"];
  /** The user's profile image. Deprecated, use profilePicture instead. */
  profilePicSrcset: ImgSrcset;
  /** The user's profile picture */
  profilePicture?: Maybe<AttachmentInterface>;
  /** The payments for all of the user's memberships for a company. */
  receipts?: Maybe<Array<Receipt>>;
  /** A statement describing the renewal/expiration state of the member. */
  subtext?: Maybe<MemberSubtext>;
  /** The user's telegram username */
  telegramUsername?: Maybe<Scalars["String"]["output"]>;
  /** How much they have spent on the company's passes. */
  totalSpend?: Maybe<Scalars["String"]["output"]>;
  /** The username of the member's TradingView account. */
  tradingViewUsername?: Maybe<Scalars["String"]["output"]>;
  /** The account id of the user's X account. */
  twitterAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The username of the user's X account. */
  twitterUsername?: Maybe<Scalars["String"]["output"]>;
  /** The whop username of the member. */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** A user of the site. */
export type MemberLogsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A user of the site. */
export type MemberMembershipsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  experienceType?: InputMaybe<ExperienceTypes>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<MembershipHeaderStatus>;
};

/** A user of the site. */
export type MemberProfilePicSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** The different most recent actions a member can have. */
export enum MemberMostRecentActions {
  /** Canceling */
  Canceling = "canceling",
  /** Churned */
  Churned = "churned",
  /** Drafted */
  Drafted = "drafted",
  /** Expiring */
  Expiring = "expiring",
  /** Finished Split Pay */
  FinishedSplitPay = "finished_split_pay",
  /** Joined */
  Joined = "joined",
  /** Left */
  Left = "left",
  /** Paid Once */
  PaidOnce = "paid_once",
  /** Paid Subscriber */
  PaidSubscriber = "paid_subscriber",
  /** Past Due */
  PastDue = "past_due",
  /** Paused */
  Paused = "paused",
  /** Pending Entry */
  PendingEntry = "pending_entry",
  /** Renewing */
  Renewing = "renewing",
  /** Trialing */
  Trialing = "trialing",
}

/** A note on a member that can be set by a company. */
export type MemberNote = {
  __typename?: "MemberNote";
  /**
   * The user who created the note.
   * @deprecated This type has been deprecated. Use authorUser instead.
   */
  author?: Maybe<PublicUser>;
  /** The user account that performed the action. */
  authorUser?: Maybe<PublicProfileUser>;
  /** The time at which the note was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID */
  id: Scalars["ID"]["output"];
  /** The note to be made for a member */
  notes?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for MemberNote. */
export type MemberNoteConnection = {
  __typename?: "MemberNoteConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MemberNoteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MemberNote>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MemberNoteEdge = {
  __typename?: "MemberNoteEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<MemberNote>;
};

/** Statistics about a member across Whop. */
export type MemberStats = {
  __typename?: "MemberStats";
  /** The average renewal price for a membership in the company's primary category. */
  averageRenewalPriceInCategory?: Maybe<Scalars["String"]["output"]>;
  /** How many disputes the user has opened across all companies on Whop. */
  disputesAcrossWhop: Scalars["Int"]["output"];
  /**
   * How much the user has spent across all companies on Whop.
   * @deprecated This is no longer being maintained
   */
  spendAcrossWhop: Scalars["String"]["output"];
};

/** The different statuses a Member can have. */
export enum MemberStatuses {
  /** Drafted */
  Drafted = "drafted",
  /** Joined */
  Joined = "joined",
  /** Left */
  Left = "left",
}

/** Represents the state of a membership and the time this changed. */
export type MemberSubtext = {
  __typename?: "MemberSubtext";
  /** A description of the state the membership is in. */
  name: MemberSubtextTypes;
  /** The timestamp of the state. */
  timestamp: Scalars["Timestamp"]["output"];
};

/** The type of subtext to display for a member */
export enum MemberSubtextTypes {
  /** Canceled On */
  CanceledOn = "canceled_on",
  /** Canceling On */
  CancelingOn = "canceling_on",
  /** Ending On */
  EndingOn = "ending_on",
  /** Finished Split Pay At */
  FinishedSplitPayAt = "finished_split_pay_at",
  /** Next Payment Attempt */
  NextPaymentAttempt = "next_payment_attempt",
  /** Past Due */
  PastDue = "past_due",
  /** Paused At */
  PausedAt = "paused_at",
  /** Renewing On */
  RenewingOn = "renewing_on",
  /** Trial Canceling On */
  TrialCancelingOn = "trial_canceling_on",
  /** Trial Ends At */
  TrialEndsAt = "trial_ends_at",
  /** Unresolved At */
  UnresolvedAt = "unresolved_at",
}

/** Which columns can be used to sort. */
export enum MembersSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
  JoinedAt = "joined_at",
  MostRecentAction = "most_recent_action",
  UsdTotalSpent = "usd_total_spent",
}

/** An object representing a membership and all pertinent information. */
export type Membership = {
  __typename?: "Membership";
  /** The access pass the membership is connected to. */
  accessPass: AccessPass;
  /** Stores information about what membership management options can be performed on the membership. */
  actions: Scalars["JSON"]["output"];
  /** The currently active discount on the membership, if any. */
  activeDiscount?: Maybe<Discount>;
  /** The affiliate connected to the membership. */
  affiliate?: Maybe<Affiliate>;
  /** Indicates whether the membership is/isn't set to cancel at the end of the current billing period. */
  cancelAtPeriodEnd: Scalars["Boolean"]["output"];
  /** Enum option for cancelation */
  cancelOption?: Maybe<CancelOptions>;
  /** The reason that the member canceled the membership (filled out by the member). */
  cancelationReason?: Maybe<Scalars["String"]["output"]>;
  /** The epoch timestamp of when the customer initiated a cancellation. */
  canceledAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The actual amount received from Coinbase. */
  coinbaseAmountReceived?: Maybe<Scalars["Float"]["output"]>;
  /** The company that the membership is connected to. */
  company: Company;
  /** The company that purchased (only applicable if this is an app membership) */
  companyBuyer?: Maybe<PublicCompany>;
  /** The Member object that owns this membership (if any). */
  companyMember?: Maybe<CompanyMember>;
  /** The epoch timestamp of when the membership was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency the membership is in. */
  currency?: Maybe<Currencies>;
  /** Whether the membership was purchased on the marketplace or directly */
  directToConsumer: Scalars["Boolean"]["output"];
  /** The ID of the member's Discord account. */
  discordAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The username of the member's Discord account. */
  discordUsername?: Maybe<Scalars["String"]["output"]>;
  /** The epoch timestamp of when the membership is set to expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The total amount spent on the membership (from the cached amount), formatted to the currency. */
  formattedNormalizedSpend: Scalars["String"]["output"];
  /** The total amount spent on the membership. */
  formattedTotalSpend?: Maybe<Scalars["String"]["output"]>;
  /** Indicates whether the membership was created from a transfer. */
  fromTransfer: Scalars["Boolean"]["output"];
  /** The header for the membership. */
  header: Scalars["String"]["output"];
  /** The internal ID of the membership. */
  id: Scalars["ID"]["output"];
  /**
   * The image for the membership.
   * @deprecated Use imageSrcset instead.
   */
  image: Scalars["String"]["output"];
  /** The image for the membership. */
  imageSrcset: ImgSrcset;
  /** The Discord account ID (if applicable) that was imported from another platform. */
  importedDiscordAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The email (if applicable) that was imported from another platform. */
  importedEmail?: Maybe<Scalars["String"]["output"]>;
  /** The imported telegram account id, if any. */
  importedTelegramAccountId?: Maybe<Scalars["String"]["output"]>;
  /** A written description or note regarding the specific membership. */
  internalNotes?: Maybe<Scalars["String"]["output"]>;
  /** A combination of capitalized letters and numbers which represents a unique software activation key. */
  licenseKey?: Maybe<Scalars["String"]["output"]>;
  /** The logs for this specific membership. */
  logs: Array<Log>;
  /** The logs for this specific membership. */
  logsV2: LogConnection;
  /** The member of the membership. */
  member?: Maybe<Member>;
  /** A JSON object used to store software licensing information. Ex. HWID */
  metadata: Scalars["JSON"]["output"];
  /** The most recent action on the membership. */
  mostRecentAction?: Maybe<MemberSubtext>;
  /** The epoch timestamp of when the subscription was paused. */
  pausedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Indicates whether the membership has/hasn't paused collection of payments. */
  paymentCollectionPaused: Scalars["Boolean"]["output"];
  /** The company or method for how the membership's payments are processed. */
  paymentProcessor: MembershipPaymentProcessor;
  /** The plan the membership is connected to. */
  plan: Plan;
  /** The type of promo code the membership is connected to. */
  promoCode?: Maybe<PromoCode>;
  /** Indicates whether the membership has/hasn't enabled mobile push notifications via the iOS/Android app. */
  pushNotification: MembershipPushNotification;
  /** The number of items purchased of a single plan. (Ex. transactional products) */
  quantity: Scalars["Int"]["output"];
  /** The total amount spent on the membership. */
  rawNormalizedSpend: Scalars["String"]["output"];
  /** The receipts for the membership. */
  receipts: Array<Receipt>;
  /** The receipts for the membership. */
  receiptsV2: ReceiptConnection;
  /** The epoch timestamp of when the current billing period ends. */
  renewalPeriodEnd?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The epoch timestamp of when the current billing period started. */
  renewalPeriodStart?: Maybe<Scalars["Timestamp"]["output"]>;
  /** A resolution tied to this membership. */
  resolution: PublicResolution;
  /** The resolutions tied to this membership. */
  resolutions: PublicResolutionConnection;
  /** The number of payments made on the split pay subscription. */
  splitPayCurrentPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The state of the membership. */
  status: MembershipStatus;
  /** The Stripe customer ID for the membership. */
  stripeCustomerId?: Maybe<Scalars["String"]["output"]>;
  /** The Stripe subscription ID for the membership. */
  stripeSubscriptionId?: Maybe<Scalars["String"]["output"]>;
  /** The subheader for the membership. */
  subheader: Scalars["String"]["output"];
  /** The total amount spent on the membership. */
  totalSpend: Scalars["Float"]["output"];
  /** The member this membership was transferred from. */
  transferredFrom?: Maybe<CompanyMember>;
  /** The member this membership was transferred to. */
  transferredTo?: Maybe<CompanyMember>;
  /** Stores information about what membership management options can be performed on the membership. */
  typedActions: MembershipCompanyActions;
  /** Indicates whether the membership is valid. */
  validMembership: Scalars["Boolean"]["output"];
  /** The ETH renewal wallet address for the membership. */
  walletAddress?: Maybe<Scalars["String"]["output"]>;
  /** A list of warnings for the membership. */
  warnings: Array<Scalars["String"]["output"]>;
};

/** An object representing a membership and all pertinent information. */
export type MembershipImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<MembershipImageStyles>;
};

/** An object representing a membership and all pertinent information. */
export type MembershipLogsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a membership and all pertinent information. */
export type MembershipReceiptsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a membership and all pertinent information. */
export type MembershipResolutionArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a membership and all pertinent information. */
export type MembershipResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ResolutionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The actions that can be performed on a membership */
export enum MembershipActions {
  AddDiscordRoles = "add_discord_roles",
  AddFreeDays = "add_free_days",
  CancelMembership = "cancel_membership",
  FulfillTradingViewIndicators = "fulfill_trading_view_indicators",
  PauseSubscriptionPayments = "pause_subscription_payments",
  ResetLicense = "reset_license",
  RetryPayment = "retry_payment",
  ShuffleLicense = "shuffle_license",
  TerminateMembership = "terminate_membership",
  UnlinkDiscord = "unlink_discord",
  UnpauseSubscriptionPayments = "unpause_subscription_payments",
}

/** Represents the actions that can and cannot be performed on a Membership. */
export type MembershipCompanyActions = {
  __typename?: "MembershipCompanyActions";
  /** Whether Discord roles can be added. */
  addDiscordRoles: Scalars["Boolean"]["output"];
  /** Whether free days can be added. */
  addFreeDays: Scalars["Boolean"]["output"];
  /** Whether a promo code can be applied. */
  applyPromoCode: Scalars["Boolean"]["output"];
  /** Whether an affiliate can be attached. */
  attachAffiliate: Scalars["Boolean"]["output"];
  /** Whether a membership can be canceled. */
  cancelMembership: Scalars["Boolean"]["output"];
  /** Whether Trading View indicators can be fulfilled. */
  fulfillTradingViewIndicators: Scalars["Boolean"]["output"];
  /** Whether a transfer link can be generated. */
  generateTransferLink: Scalars["Boolean"]["output"];
  /** Whether payments can be paused. */
  pausePayments: Scalars["Boolean"]["output"];
  /** Whether a license can be reset. */
  resetLicense: Scalars["Boolean"]["output"];
  /** Whether a payment can be resolved. */
  resolvePayment: Scalars["Boolean"]["output"];
  /** Whether a payment can be retried. */
  retryPayment: Scalars["Boolean"]["output"];
  /** Whether a license can be shuffled. */
  shuffleLicense: Scalars["Boolean"]["output"];
  /** Whether a membership can be terminated. */
  terminateMembership: Scalars["Boolean"]["output"];
  /** Whether Discord can be unlinked. */
  unlinkDiscord: Scalars["Boolean"]["output"];
  /** Whether payments can be unpaused. */
  unpausePayments: Scalars["Boolean"]["output"];
};

/** The connection type for Membership. */
export type MembershipConnection = {
  __typename?: "MembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Membership>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type MembershipEdge = {
  __typename?: "MembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Membership>;
};

/** The state of a membership, based on a company's accepted sub statuses. */
export enum MembershipHeaderStatus {
  Active = "active",
  Churned = "churned",
}

/** Image styles for membership. */
export enum MembershipImageStyles {
  S40 = "s40",
}

/** The payment processor used for a membership */
export enum MembershipPaymentProcessor {
  /** Apple */
  Apple = "apple",
  /** Coinbase */
  Coinbase = "coinbase",
  /** Crypto */
  Crypto = "crypto",
  /** Free */
  Free = "free",
  /** Multi Psp */
  MultiPsp = "multi_psp",
  /** Paypal */
  Paypal = "paypal",
  /** Sezzle */
  Sezzle = "sezzle",
  /** Splitit */
  Splitit = "splitit",
  /** Stripe */
  Stripe = "stripe",
}

/** Whether or not to send push notifications to the user of a membership */
export enum MembershipPushNotification {
  /** Disabled */
  Disabled = "disabled",
  /** Enabled */
  Enabled = "enabled",
}

/** The status of a membership */
export enum MembershipStatus {
  /** Active */
  Active = "active",
  /** Canceled */
  Canceled = "canceled",
  /** Completed */
  Completed = "completed",
  /** Drafted */
  Drafted = "drafted",
  /** Expired */
  Expired = "expired",
  /** Past Due */
  PastDue = "past_due",
  /** Trialing */
  Trialing = "trialing",
  /** Unresolved */
  Unresolved = "unresolved",
}

/** Which columns can be used to sort. */
export enum MembershipsSortableColumns {
  CanceledAt = "canceled_at",
  CreatedAt = "created_at",
  DateJoined = "date_joined",
  Id = "id",
  Status = "status",
  TotalSpend = "total_spend",
}

/** Autogenerated input type of MerchantRespondResolution */
export type MerchantRespondResolutionInput = {
  /** Any attachments for this response. */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The response details from the merchant. */
  details?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Any evidence you wish you upload with the response.
   * @deprecated Use attachments instead
   */
  evidenceFiles?: InputMaybe<Array<Scalars["File"]["input"]>>;
  /** The ID of the resolution to update. */
  resolutionId: Scalars["ID"]["input"];
  /** Whether or not the merchant is accepting this case. */
  responseAction: ResolutionMerchantResponses;
  /** Whether or not to terminate the customer's membership. */
  terminateMembership?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An Ethereum wallet. */
export type MetamaskWallet = {
  __typename?: "MetamaskWallet";
  /** The address of the wallet. */
  address: Scalars["String"]["output"];
};

export type MobileNotificationStatusesInput = {
  /** Whether or not alerts are enabled for notifications */
  alertEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The global status for all notifications */
  globalStatus?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not lock screen notifications are enabled */
  lockScreenEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not notifications are enabled in the notification center */
  notificationCenterEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not sound is enabled for notifications */
  soundEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The different moderation results for an attachment */
export enum ModerationResults {
  /** Nsfw */
  Nsfw = "nsfw",
}

/** A stack of products with very recent activity. */
export type MoreTags = DiscoveryModuleInterface & {
  __typename?: "MoreTags";
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** Any additional data required for processing a Multi PSP checkout. */
export type MultiPspData = {
  __typename?: "MultiPspData";
  /** The URL to redirect the user to for 3DS authentication. */
  acsChallengeUrl?: Maybe<Scalars["String"]["output"]>;
  /** The transaction ID for the 3DS authentication. */
  acsTransactionId?: Maybe<Scalars["String"]["output"]>;
  /** The status of the 3DS authentication. */
  authenticationStatus?: Maybe<PaymentTokenAuthenticationStatuses>;
  /** The ID of the PaymentTokenAuthentication record. */
  paymentTokenAuthenticationId?: Maybe<Scalars["ID"]["output"]>;
  /** The session ID for the 3DS authentication. */
  sessionId?: Maybe<Scalars["String"]["output"]>;
  /** The 3DS version being used for the authentication. */
  threeDsVersion?: Maybe<Scalars["String"]["output"]>;
};

/** The part of a multipart upload */
export type MultipartUrl = {
  __typename?: "MultipartUrl";
  /** The part number of the part */
  partNumber: Scalars["Int"]["output"];
  /** The url to upload the part */
  url: Scalars["String"]["output"];
};

/** Autogenerated input type of MuteParticipantMicrophone */
export type MuteParticipantMicrophoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed ID for the room */
  feedId: Scalars["ID"]["input"];
  /** The user ID of the participant to mute */
  userId: Scalars["ID"]["input"];
};

/** Input for a feed muted member */
export type MutedUserInput = {
  /** The ID of the feed */
  feedId: Scalars["ID"]["input"];
  /** The feed type */
  feedType?: FeedTypes;
  /** The unique identifier for the muted user */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The time the user is muted till */
  mutedUntil?: InputMaybe<Scalars["Float"]["input"]>;
  /** The ID of the user */
  userId: Scalars["ID"]["input"];
};

/** A Mux asset, which may contain an uploaded video */
export type MuxAsset = {
  __typename?: "MuxAsset";
  /** Whether this asset contains only audio */
  audioOnly: Scalars["Boolean"]["output"];
  /** The time at which the Mux asset was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The duration of the video in seconds */
  durationSeconds?: Maybe<Scalars["Int"]["output"]>;
  /** The time at which the video finished uploading */
  finishedUploadingAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the Mux asset */
  id: Scalars["ID"]["output"];
  /** The Mux-provided ID of the asset */
  muxAssetId?: Maybe<Scalars["String"]["output"]>;
  /** The public playback ID of the Mux asset */
  playbackId?: Maybe<Scalars["String"]["output"]>;
  /** The type of resource associated with the Mux asset */
  resourceType?: Maybe<Scalars["String"]["output"]>;
  /** The signed playback ID of the Mux asset */
  signedPlaybackId?: Maybe<Scalars["String"]["output"]>;
  /** The signed storyboard playback token of the Mux asset */
  signedStoryboardPlaybackToken?: Maybe<Scalars["String"]["output"]>;
  /** The signed thumbnail playback token of the Mux asset */
  signedThumbnailPlaybackToken?: Maybe<Scalars["String"]["output"]>;
  /** The signed video playback token of the Mux asset */
  signedVideoPlaybackToken?: Maybe<Scalars["String"]["output"]>;
  /** The status of the Mux asset */
  status: MuxAssetStatuses;
  /** The time at which the Mux asset was last updated */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The input to create a Mux asset */
export type MuxAssetInput = {
  /** The Mux passthrough ID for the asset */
  passthroughId: Scalars["String"]["input"];
};

/** Mux asset statuses */
export enum MuxAssetStatuses {
  /** Created */
  Created = "created",
  /** Ready */
  Ready = "ready",
  /** Uploading */
  Uploading = "uploading",
}

/** Response type for DM feed data query */
export type MyDmsChannelsCounts = {
  __typename?: "MyDmsChannelsCounts";
  /** Count of accepted channels for the user */
  accepted: Scalars["Int"]["output"];
  /** Count of direct messages for the user */
  directMessages: Scalars["Int"]["output"];
  /** Count of group chats for the user */
  groupChats: Scalars["Int"]["output"];
  /** Count of hidden channels for the user */
  hidden: Scalars["Int"]["output"];
  /** Count of requested channels for the user */
  requested: Scalars["Int"]["output"];
};

/** An object representing a section on the dashboard. */
export type NavigationItem = {
  __typename?: "NavigationItem";
  /** The name of the location. */
  name: Scalars["String"]["output"];
  /** The relative route to the location. */
  relativeRoute: Scalars["String"]["output"];
};

/** An object storing information about an NFT token. USED BY OLD DASHBOARD MOBILE APP. DO NOT DELETE. */
export type NftToken = {
  __typename?: "NftToken";
  /** The name of the smart contract. */
  contractName?: Maybe<Scalars["String"]["output"]>;
  /** The image of the NFT. */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The name of the NFT. */
  tokenName?: Maybe<Scalars["String"]["output"]>;
};

/** The different types of Stripe Accounts. */
export enum NormalizedAccountTypes {
  Custom = "custom",
  Express = "express",
  Personal = "personal",
  Standard = "standard",
  WhopCredit = "whop_credit",
}

/** This receipt can be accessed by a non logged in user. It doesn't expose sensitive data. Don't use this type unless you are dealing w/ just Stripe receipts otherwise you'll get nullable fields */
export type NotLoggedInReceipt = {
  __typename?: "NotLoggedInReceipt";
  /** The company that owns the receipt. */
  company?: Maybe<PublicCompany>;
  /** The datetime the receipt was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The formatted final amount of this receipt in its currency */
  formattedPrice: Scalars["String"]["output"];
  /** The formatted promo amount of this receipt in its currency */
  formattedPromoAmount?: Maybe<Scalars["String"]["output"]>;
  /** The formatted price the user paid before taxes and promo */
  formattedSubtotal?: Maybe<Scalars["String"]["output"]>;
  /** The formatted tax amount of this receipt in its currency */
  formattedTax?: Maybe<Scalars["String"]["output"]>;
  /** The receipt ID */
  id: Scalars["ID"]["output"];
  /** The last 4 of the card used to purchase. Null if free */
  last4?: Maybe<Scalars["String"]["output"]>;
  /** The membership this receipt is for, fully sanitizied */
  membership?: Maybe<ExtraPublicMembership>;
  /** The user's email obfuscated */
  obfuscatedEmail?: Maybe<Scalars["String"]["output"]>;
  /** The product name */
  productName: Scalars["String"]["output"];
};

/** The state of a user's notifications for a notifying entity */
export type NotificationBadge = {
  __typename?: "NotificationBadge";
  /** The ID of the company */
  companyId: Scalars["ID"]["output"];
  /** The ID of the experience */
  experienceId: Scalars["ID"]["output"];
  /** Whether the user has unread notifications for this entity */
  hasUnread: Scalars["Boolean"]["output"];
  /** The total number of important notifications for this entity */
  importantCount: Scalars["Int"]["output"];
  /** The last time the user viewed the experience */
  lastViewedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for NotificationBadge. */
export type NotificationBadgeConnection = {
  __typename?: "NotificationBadgeConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationBadgeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NotificationBadge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type NotificationBadgeEdge = {
  __typename?: "NotificationBadgeEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<NotificationBadge>;
};

/** The channel for a notification preference */
export enum NotificationPreferenceChannel {
  /** In App */
  InApp = "in_app",
  /** Mobile */
  Mobile = "mobile",
}

/** Values to filter preferences on */
export type NotificationPreferencesFilters = {
  /** The channel to retrieve a user's preferences for */
  channel?: InputMaybe<NotificationPreferenceChannel>;
  /** The company to retrieve a user's preferences for */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The company team ID to retrieve a user's preferences for */
  companyTeamId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The experience to retrieve a user's preferences for */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The topic to retrieve a user's preferences for */
  topicId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** A notification topic */
export type NotificationTopic = {
  __typename?: "NotificationTopic";
  /** The app that owns this notification topic */
  app?: Maybe<PublicApp>;
  /** When the notification topic was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether the notification topic is enabled by default. This is usually true. */
  defaultPreferenceValue: Scalars["Boolean"]["output"];
  /** The description of the notification topic */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The ID */
  id: Scalars["ID"]["output"];
  /** The name of the notification topic */
  name: Scalars["String"]["output"];
  /** The status of the notification topic, whether it will send or not */
  status: NotificationTopicStatus;
  /** The unique identifier for the notification topic */
  topicIdentifier: Scalars["String"]["output"];
  /** The type of the notification topic */
  topicType: Topic;
  /** Whether the notification is urgent (should show in modal) or not. */
  urgent: Scalars["Boolean"]["output"];
  /** The visibility of the notification topic. If it's hidden, it won't show on the UI. */
  visibility: NotificationTopicVisibility;
};

/** The connection type for NotificationTopic. */
export type NotificationTopicConnection = {
  __typename?: "NotificationTopicConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<NotificationTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type NotificationTopicEdge = {
  __typename?: "NotificationTopicEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<NotificationTopic>;
};

/** The status of the notification topic. If it's active, they will send. */
export enum NotificationTopicStatus {
  /** Active */
  Active = "active",
  /** Inactive */
  Inactive = "inactive",
}

/** The type for the notification topic. */
export enum NotificationTopicTypes {
  CompanyTeam = "company_team",
}

/** The visibility of the notification topic. If it's hidden, it won't show on the UI. */
export enum NotificationTopicVisibility {
  /** Hidden */
  Hidden = "hidden",
  /** Visible */
  Visible = "visible",
}

/** Values to filter notifications on */
export type NotificationsV4Filters = {
  /** The client's last fetched at timestamp. If passed will only return notifications created after this timestamp. NOT YET IMPLEMENTED */
  clientLastFetchedAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The company ID that you want to filter by. Will return notifications sent to this team. */
  companyTeamId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The experience ID that you want to filter by */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The experience IDs that you want to filter by. Overrides experience_id. */
  experienceIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Whether the notifications are mentions or not */
  isMention?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to only return unread notifications */
  unreadOnly?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Values to paginate notifications on */
export type NotificationsV4Pagination = {
  /** Filter all notifications made after this */
  after?: InputMaybe<Scalars["ID"]["input"]>;
  /** Filter all notifications made before this */
  before?: InputMaybe<Scalars["ID"]["input"]>;
  /** The number of notifications to return. Default is 50 */
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** This has the data for a company's OAuth stuff. */
export type OauthApplication = {
  __typename?: "OauthApplication";
  /** The client ID for the OAuth application. */
  clientId: Scalars["String"]["output"];
  /** The client ID for the OAuth application. */
  clientSecret: Scalars["String"]["output"];
  /** The date and time the OAuth application was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The redirect URIs for the OAuth application. */
  redirectUris?: Maybe<Array<Scalars["String"]["output"]>>;
};

/** The type of the oauth application. */
export enum OauthApplicationTypes {
  /** External */
  External = "external",
  /** Internal */
  Internal = "internal",
}

/** This has the data for a company's OAuth stuff. */
export type OauthApplicationView = {
  __typename?: "OauthApplicationView";
  /** The client ID for the OAuth application. */
  clientId: Scalars["String"]["output"];
  /** The client ID for the OAuth application. */
  clientSecret: Scalars["String"]["output"];
  /** The date and time the OAuth application was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The redirect URIs for the OAuth application. */
  redirectUris?: Maybe<Array<Scalars["String"]["output"]>>;
};

/** A Notion page use for Whop Content experiences. */
export type OauthDetails = {
  __typename?: "OauthDetails";
  /** The type of the oauth app */
  appType: OauthApplicationTypes;
  /** The base path */
  basePath?: Maybe<Scalars["String"]["output"]>;
  /**
   * The image to show for the modal
   * @deprecated Use imageSrcset instead.
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The image to show for the modal */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The name of oauth details */
  name: Scalars["String"]["output"];
  /** The public key for internal apps */
  publicKey?: Maybe<Scalars["String"]["output"]>;
  /** The redirect_uri(s) of oauth details */
  redirectUri?: Maybe<Scalars["String"]["output"]>;
};

/** A Notion page use for Whop Content experiences. */
export type OauthDetailsImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<OauthDetailsImageStyles>;
};

/** Image styles for oauth_details. */
export enum OauthDetailsImageStyles {
  S64 = "s64",
}

/** The name of the oauth provider */
export enum OauthProviders {
  Apple = "apple",
  Discord = "discord",
  Twitter = "twitter",
}

/** Represents a generic attachment */
export type OtherAttachment = AttachmentInterface & {
  __typename?: "OtherAttachment";
  /** Whether the attachment has been analyzed */
  analyzed: Scalars["Boolean"]["output"];
  /**
   * The size of the file in bytes
   * @deprecated Use byteSizeV2 instead
   */
  byteSize?: Maybe<Scalars["Int"]["output"]>;
  /** The size of the file in bytes */
  byteSizeV2?: Maybe<Scalars["BigInt"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The name of the file */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the attachment */
  id: Scalars["ID"]["output"];
  /** The moderation result of the attachment */
  moderationResult?: Maybe<ModerationResults>;
  /** The position of the attachment */
  position?: Maybe<Scalars["Int"]["output"]>;
  /** A signed ID of the attachment to directly query the attachment */
  signedId?: Maybe<Scalars["ID"]["output"]>;
  /** The source of the attachment */
  source: AttachmentSource;
  /** The source URL of the attachment */
  sourceUrl?: Maybe<Scalars["String"]["output"]>;
};

/** Represents a generic attachment */
export type OtherAttachmentSourceArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: "PageInfo";
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars["String"]["output"]>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars["Boolean"]["output"];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars["String"]["output"]>;
};

/** Whether a payment is being refunded or retried. */
export enum PaymentActions {
  RefundPayment = "refund_payment",
  ResolvePayment = "resolve_payment",
  RetryPayment = "retry_payment",
}

/** A payment method for a user. */
export type PaymentMethod = {
  __typename?: "PaymentMethod";
  /** The brand of the card */
  brand?: Maybe<Scalars["String"]["output"]>;
  /** Whether this is the default payment method for the user */
  default: Scalars["Boolean"]["output"];
  /** The ID of the payment method */
  id: Scalars["ID"]["output"];
  /** The last 4 digits of the card */
  last4?: Maybe<Scalars["String"]["output"]>;
  /** The expiry month of the card */
  month?: Maybe<Scalars["String"]["output"]>;
  /** The expiry year of the card */
  year?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for PaymentMethod. */
export type PaymentMethodConnection = {
  __typename?: "PaymentMethodConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PaymentMethodEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PaymentMethod>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PaymentMethodEdge = {
  __typename?: "PaymentMethodEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PaymentMethod>;
};

/** The different types of payment methods that can be used. */
export enum PaymentMethodTypes {
  Card = "card",
  Cashapp = "cashapp",
  UsBankAccount = "us_bank_account",
}

/** The high level payment processor options. */
export enum PaymentMethods {
  /** Apple */
  Apple = "apple",
  /** Coinbase */
  Coinbase = "coinbase",
  /** Crypto */
  Crypto = "crypto",
  /** Free */
  Free = "free",
  /** Multi Psp */
  MultiPsp = "multi_psp",
  /** Nft */
  Nft = "nft",
  /** Paypal */
  Paypal = "paypal",
  /** Sezzle */
  Sezzle = "sezzle",
  /** Splitit */
  Splitit = "splitit",
  /** Stripe */
  Stripe = "stripe",
}

/** The high level payment processor options. */
export enum PaymentProcessor {
  Apple = "apple",
  Coinbase = "coinbase",
  Free = "free",
  MultiPsp = "multi_psp",
  Paypal = "paypal",
  Sezzle = "sezzle",
  Splitit = "splitit",
  Stripe = "stripe",
  Venmo = "venmo",
}

/** The different payment providers. */
export enum PaymentProviders {
  /** Airwallex */
  Airwallex = "airwallex",
  /** Apple */
  Apple = "apple",
  /** Coinbase */
  Coinbase = "coinbase",
  /** Paypal */
  Paypal = "paypal",
  /** Sezzle */
  Sezzle = "sezzle",
  /** Splitit */
  Splitit = "splitit",
  /** Stripe */
  Stripe = "stripe",
}

/** A payment token used to process payments. */
export type PaymentToken = {
  __typename?: "PaymentToken";
  /** Whether or not the payment method is broken */
  broken: Scalars["Boolean"]["output"];
  /** The card brand of the payment token */
  cardBrand?: Maybe<CardBrands>;
  /** The date and time the payment token was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** An email address for the payment token to properly identify it, if available. */
  emailIdentifier?: Maybe<Scalars["String"]["output"]>;
  /** The expiry month of the card */
  expMonth?: Maybe<Scalars["String"]["output"]>;
  /** The expiry year of the card */
  expYear?: Maybe<Scalars["String"]["output"]>;
  /** The gateway type of the payment token */
  gatewayType: GatewayTypes;
  /** The ID of the payment token */
  id: Scalars["ID"]["output"];
  /** The identifier of the payment token (Ex. on PayPal this is the Billing ID) */
  identifier: Scalars["String"]["output"];
  /** The last 4 digits of the card */
  last4?: Maybe<Scalars["String"]["output"]>;
  /** The mailing address associated with the payment token, if any. */
  mailingAddress?: Maybe<MailingAddress>;
  /** The date and time the payment token was last updated */
  updatedAt: Scalars["Timestamp"]["output"];
  /** The vault method of the payment token */
  vaultMethod?: Maybe<VaultMethods>;
};

/** An object representing a 3DS session for a given payment token. */
export type PaymentTokenAuthentication = {
  __typename?: "PaymentTokenAuthentication";
  /** The URL to which the user should be redirected to complete the 3DS challenge. */
  acsChallengeUrl?: Maybe<Scalars["String"]["output"]>;
  /** The acs reference number. */
  acsReferenceNumber?: Maybe<Scalars["String"]["output"]>;
  /** The transaction ID for the 3DS challenge. */
  acsTransactionId?: Maybe<Scalars["String"]["output"]>;
  /** The status of the 3DS authentication. */
  authenticationStatus?: Maybe<PaymentTokenAuthenticationStatuses>;
  /** The ID of the payment token authentication. */
  id: Scalars["ID"]["output"];
  /** The session ID for the 3DS authentication. */
  sessionId: Scalars["String"]["output"];
  /** The 3DS version being used for the authentication. */
  threeDsVersion?: Maybe<Scalars["String"]["output"]>;
};

/** The authentication statuses for a PaymentTokenAuthentication. */
export enum PaymentTokenAuthenticationStatuses {
  /** Attempted */
  Attempted = "attempted",
  /** Challenge */
  Challenge = "challenge",
  /** Decoupled Challenge */
  DecoupledChallenge = "decoupled_challenge",
  /** Failed */
  Failed = "failed",
  /** Informational */
  Informational = "informational",
  /** Rejected */
  Rejected = "rejected",
  /** Successful */
  Successful = "successful",
  /** Unavailable */
  Unavailable = "unavailable",
}

/** The connection type for PaymentToken. */
export type PaymentTokenConnection = {
  __typename?: "PaymentTokenConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PaymentTokenEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PaymentToken>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PaymentTokenEdge = {
  __typename?: "PaymentTokenEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PaymentToken>;
};

/** The different approval statuses a company can have. */
export enum PaymentsApprovalStatuses {
  /** Approved */
  Approved = "approved",
  /** Monitoring */
  Monitoring = "monitoring",
  /** Pending */
  Pending = "pending",
  /** Rejected */
  Rejected = "rejected",
}

/** The interval at which a Connected Account is paid out */
export enum PayoutIntervals {
  Daily = "daily",
  Manual = "manual",
  Monthly = "monthly",
  Weekly = "weekly",
}

/** The payout methods that can be configured for a company. */
export enum PayoutMethods {
  CoinbaseCommerce = "coinbase_commerce",
  Paypal = "paypal",
  Stripe = "stripe",
}

/** Whether a payout is one-time or recurring */
export enum PayoutTypes {
  /** Flat Fee */
  FlatFee = "flat_fee",
  /** Percentage */
  Percentage = "percentage",
}

/** A PayPal payments account for a company. */
export type PaypalAccount = {
  __typename?: "PaypalAccount";
  /** Whether or not the account can be deleted to restart the setup process */
  canDelete: Scalars["Boolean"]["output"];
  /** Whether this is the default account for the company */
  defaultAccount: Scalars["Boolean"]["output"];
  /** The email address of the attached account */
  email: Scalars["String"]["output"];
  /** The ID of the paypal account, internal */
  id: Scalars["ID"]["output"];
  /** The ID of the account in PayPal's systems */
  merchantId: Scalars["ID"]["output"];
  /** The status of the account to display on the card. */
  status: PaypalAccountStatuses;
};

/** The connection type for PaypalAccount. */
export type PaypalAccountConnection = {
  __typename?: "PaypalAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PaypalAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PaypalAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PaypalAccountEdge = {
  __typename?: "PaypalAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PaypalAccount>;
};

/** Statuses for paypal accounts */
export enum PaypalAccountStatuses {
  Broken = "broken",
  Connected = "connected",
  DisabledByWhop = "disabled_by_whop",
  OauthIntegrationNotFound = "oauth_integration_not_found",
  PaymentsNotReceivable = "payments_not_receivable",
  PrimaryEmailNotConfirmed = "primary_email_not_confirmed",
}

/** The status of an entry for a perk. */
export enum PerkStatus {
  Completed = "completed",
  Pending = "pending",
}

/** A plan for an access pass. */
export type Plan = {
  __typename?: "Plan";
  /** An array of the accepted payment methods for a plan. */
  acceptedPaymentMethods: Array<AcceptedPaymentMethods>;
  /** The access pass for the plan. */
  accessPass?: Maybe<AccessPass>;
  /** Whether or not ACH payments are allowed. */
  achPayments: Scalars["Boolean"]["output"];
  /** A cached estimate of the number of active memberships on the plan. */
  activeMemberCount: Scalars["Int"]["output"];
  /** The number of entries that have been accepted for the waitlist or raffle. */
  admittedEntries: Scalars["Int"]["output"];
  /** Fetch a specific affiliate for the plan. */
  affiliate: PlanAffiliate;
  /** All of the affiliates for this plan. */
  affiliates: Array<PlanAffiliate>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity: Scalars["Boolean"]["output"];
  /** Marks whether the customer has already purchased this plan. */
  alreadyEntered: Scalars["Boolean"]["output"];
  /** Returns true if the customer has already purchased this plan and their membership on the plan is currently active. */
  alreadyOwned: Scalars["Boolean"]["output"];
  /**
   * No longer used.
   * @deprecated No longer available.
   */
  amountSaved?: Maybe<Scalars["String"]["output"]>;
  /** Returns the Apple IAP price for the plan, if applicable. */
  appleIapPrice?: Maybe<Scalars["Float"]["output"]>;
  /** The respective currency identifier for the plan. */
  baseCurrency: Currencies;
  /** The interval at which the plan charges (renewal plans). */
  billingPeriod?: Maybe<Scalars["Int"]["output"]>;
  /** Whether or not the user has a billing setup for this plan */
  billingSetupRequired: Scalars["Boolean"]["output"];
  /** Where the user should be re-directed to when clicking the buy box button. */
  buyButtonLocation: BuyButtonLocations;
  /** The text to display on the buy box. */
  buyButtonText: Scalars["String"]["output"];
  /** How the buyer fee should be applied, if any. */
  buyerFeeMode?: Maybe<BuyerFeeMode>;
  /** The buyer fee percentage to apply to the transaction, if any. */
  buyerFeePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The payment processors that support the buyer fee, if any. */
  buyerFeeSupportedProcessors: Array<PaymentProcessor>;
  /** A cached estimate of the initial purchase price for this plan. */
  cachedInitialPriceDue?: Maybe<Scalars["Float"]["output"]>;
  /** A cached estimate of the total earnings (in USD) for this plan. */
  cachedUsdIncome: Scalars["Float"]["output"];
  /** Whether or not any memberships that were obtained as a perk of this plan will be canceled when the user loses their underlying pass */
  cancelCollabPasses: Scalars["Boolean"]["output"];
  /** Either forever (0), first payment (1), or a specified number of months (2, 3, 4...). */
  cancelDiscountIntervals?: Maybe<Scalars["Int"]["output"]>;
  /** The percentage discount offered for cancelling a subscription (if present). */
  cancelDiscountPercentage?: Maybe<Scalars["Int"]["output"]>;
  /** The promo code that is offered to users who attempt to cancel. */
  cancelationPromoCode?: Maybe<PromoCode>;
  /** Whether the plan supports card payments. */
  cardPayments: Scalars["Boolean"]["output"];
  /** The description to display on the checkout page. */
  checkoutDescription?: Maybe<Scalars["String"]["output"]>;
  /** The title to display on the checkout page. */
  checkoutTitle?: Maybe<Scalars["String"]["output"]>;
  /** An array of plans that are upsells for this plan. */
  checkoutUpsellPlans: Array<PublicPlan>;
  /** Marks whether coinbase commerce payments are/aren't accepted. */
  coinbaseCommerceAccepted: Scalars["Boolean"]["output"];
  /** Whether or not the plan collects tax. */
  collectTax: Scalars["Boolean"]["output"];
  /** The company for the plan. */
  company?: Maybe<PublicCompany>;
  /** When the plan was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** Reward settings for custom affiliates. */
  customAffiliateSettings?: Maybe<AffiliateSettings>;
  /** The custom fields for the plan. */
  customFields: Array<CustomField>;
  /** Whether the plan can be deleted. */
  deletable: Scalars["Boolean"]["output"];
  /** The number of entries denied for the waitlist or raffle. */
  deniedEntries: Scalars["Int"]["output"];
  /** The description of the plan. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The direct link to purchase the access pass. */
  directLink: Scalars["String"]["output"];
  /** All entries connected to the plan. */
  entries: EntryConnection;
  /** The interval at which the plan charges (expiration plans). */
  expirationDays?: Maybe<Scalars["Int"]["output"]>;
  /** The price on top of the `renewal` that the user has to pay. (Used for display on the buy box) */
  extraFee?: Maybe<Scalars["String"]["output"]>;
  /** The period the access pass is valid for upon purchase (one-time plans). */
  formattedAccessPeriod?: Maybe<Scalars["String"]["output"]>;
  /** The amount with the currency that this plan costs. */
  formattedAmount: Scalars["String"]["output"];
  /** A human readable format for the billing period cycle. */
  formattedBillingPeriod?: Maybe<Scalars["String"]["output"]>;
  /** A currency formatted price for the initial price. */
  formattedInitialPrice?: Maybe<Scalars["String"]["output"]>;
  /** The interval at which the plan charges (if applicable). */
  formattedPeriod?: Maybe<Scalars["String"]["output"]>;
  /** The period which the plan renews or expires for the customer. */
  formattedPeriodV2: Scalars["String"]["output"];
  /** The formatted price (including currency) for the plan. */
  formattedPrice: Scalars["String"]["output"];
  /** Whether or not the plan is free. */
  free: Scalars["Boolean"]["output"];
  /** The time period (in days) after a sub expires where the customer can still top-up. */
  gracePeriodDays?: Maybe<Scalars["Int"]["output"]>;
  /** The internal ID of the plan. */
  id: Scalars["ID"]["output"];
  /** Whether or not the plan is in stock. */
  inStock: Scalars["Boolean"]["output"];
  /** An additional amount charged upon first purchase (separate from the renewal price). */
  initialPrice: Scalars["Float"]["output"];
  /** How much the user has to pay on the first payment. */
  initialPriceDue: Scalars["Float"]["output"];
  /** The initial price due for purchase (in cents). */
  initialPriceDueInCents: Scalars["Int"]["output"];
  /** A personal description or notes section for the business. */
  internalNotes?: Maybe<Scalars["String"]["output"]>;
  /** The ledger account for the plan, if any. */
  ledgerAccount?: Maybe<PublicLedgerAccount>;
  /** How much stock is left or how many more entries that are allowed before it will close. */
  lowStockWarning?: Maybe<Scalars["Float"]["output"]>;
  /** Whether or not the company is the merchant of record. Uses the plan's current stripe account. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** The name of the plan. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the plan offers a discount for cancelling a subscription. */
  offerCancelDiscount: Scalars["Boolean"]["output"];
  /** Used for the Stripe Payment element. If present, pass this value as the on_behalf_of parameter. */
  onBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** Marks whether the plan is one per company. */
  onePerCompany: Scalars["Boolean"]["output"];
  /**
   * Marks whether the plan is one per user.
   * @deprecated No longer used
   */
  onePerUser: Scalars["Boolean"]["output"];
  /** Whether or not a tax override is present for the plan (if null, default's to the Stripe accounts behavior) */
  overrideTaxType?: Maybe<TaxTypes>;
  /** Reward settings for any passholder affiliates. */
  passholderAffiliateSettings?: Maybe<AffiliateSettings>;
  /** Marks whether the plan is password protected. */
  passwordProtected: Scalars["Boolean"]["output"];
  /** The description of the Plan as seen by the customer on the checkout page. */
  paymentLinkDescription?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Payment Request Button. If present, pass this value as the on_behalf_of parameter. */
  paymentRequestOnBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** The capabilities of the stripe account. */
  paymentsCapabilities: Array<Scalars["String"]["output"]>;
  /** Marks whether paypal payments are/aren't accepted. */
  paypalAccepted: Scalars["Boolean"]["output"];
  /** The number of entries that are waiting to be reviewed for the waitlist or raffle. */
  pendingEntries?: Maybe<Scalars["Int"]["output"]>;
  /** The order of this plan in relation to other plans of the same access pass */
  planOrder: Scalars["Int"]["output"];
  /** Indicates if the plan is a one time payment or recurring. */
  planType: PlanTypes;
  /** The price to display inside of the buy box. */
  priceTag: Scalars["String"]["output"];
  /** Whether or not the raffle has ended, if this plan is a raffle. */
  raffleEnded: Scalars["Boolean"]["output"];
  /** The datetime the raffle expires. */
  raffleExpiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The price a person has to pay for a plan on the initial purchase. */
  rawInitialPrice: Scalars["Float"]["output"];
  /** The price a person has to pay for a plan on the initial purchase in USD. */
  rawInitialPriceUsd: Scalars["Float"]["output"];
  /** The raw final amount of this receipt in its currency */
  rawPrice?: Maybe<Scalars["String"]["output"]>;
  /** The price a person has to pay for a plan on the renewal purchase. */
  rawRenewalPrice: Scalars["Float"]["output"];
  /** The price a person has to pay for a plan on the renewal purchase in USD. */
  rawRenewalPriceUsd: Scalars["Float"]["output"];
  /** The custom URL to redirect the customer to after purchase. */
  redirectUrl?: Maybe<Scalars["String"]["output"]>;
  /** Marks whether an expiration plan can/can't be topped-up. */
  refillable: Scalars["Boolean"]["output"];
  /** This is the release method the business uses to sell this plan. */
  releaseMethod: ReleaseMethod;
  /** Configurable settings on how the plan is released. */
  releaseMethodSettings: ReleaseMethodSettings;
  /** The amount the customer is charged every billing period. */
  renewalPrice: Scalars["Float"]["output"];
  /** The pre-requisites/enforcements (if any) required in order to complete a purchase of this plan. */
  requirements: Scalars["Requirements"]["output"];
  /** The type of purchase being made */
  sessionType: CheckoutSessionTypes;
  /** Whether or not this is the default plan for the pass. */
  setAsDefault: Scalars["Boolean"]["output"];
  /** The setup future usage for the stripe payment intent for the stripe element options, if applicable. */
  setupFutureUsage?: Maybe<Scalars["String"]["output"]>;
  /** A custom string appended to the end of the URL to customize the purchase link. */
  shortLink?: Maybe<Scalars["String"]["output"]>;
  /**
   * Whether or not the payment request button (Apple Pay, Google Pay, etc) should be shown/used.
   * @deprecated This field is no longer implemented.
   */
  showPaymentRequest: Scalars["Boolean"]["output"];
  /** Whether or not the promo code input should be shown on checkout. */
  showPromoCodeInput: Scalars["Boolean"]["output"];
  /** A list of countries that should be skipped when quoting tax for this plan. */
  skipTaxQuotingCountries: Array<Scalars["String"]["output"]>;
  /** Marks whether the customer has already purchased this plan, ever. */
  skippingFreeTrial: Scalars["Boolean"]["output"];
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The number of units available for purchase. */
  stock: Scalars["Int"]["output"];
  /** The stripe public key to use for setting up this plans stripe.js */
  stripeAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe payment method configuration id to use for setting up the stripe.js elements */
  stripePaymentMethodConfigurationId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe public key to use for setting up this plans stripe.js */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the plan. */
  taxType: TaxTypes;
  /** The terms and conditions related to purchasing this plan. */
  termsAndConditions: Scalars["String"]["output"];
  /** The title of the owning object. */
  title: Scalars["String"]["output"];
  /** The total amount of entries currently submitted for this plan (ex. it is a waitlist or raffle). */
  totalEntries: Scalars["Int"]["output"];
  /** The total sales volume for the plan. */
  totalSales: Scalars["Float"]["output"];
  /** The number of free trial days added before a renewal plan. */
  trialPeriodDays?: Maybe<Scalars["Int"]["output"]>;
  /** Limits/doesn't limit the number of units available for purchase. */
  unlimitedStock: Scalars["Boolean"]["output"];
  /** When the plan was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
  /** Whether or not to use the Basis Theory element during checkout. */
  useBasisTheory: Scalars["Boolean"]["output"];
  /** Shows or hides the plan from public/business view. */
  visibility: Visibility;
};

/** A plan for an access pass. */
export type PlanAffiliateArgs = {
  id: Scalars["ID"]["input"];
};

/** A plan for an access pass. */
export type PlanCheckoutUpsellPlansArgs = {
  upsellType: UpsellTypes;
};

/** A plan for an access pass. */
export type PlanEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<EntryFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object storing information about the affiliate for a plan */
export type PlanAffiliate = {
  __typename?: "PlanAffiliate";
  /** The name of the access pass that can be referred. */
  accessPassName?: Maybe<Scalars["String"]["output"]>;
  /** The type of the affiliate has been created as. */
  affiliateType?: Maybe<AffiliateTypes>;
  /** The company of the plan that is being referred. */
  company?: Maybe<PublicCompany>;
  /** The direct link for the plan to refer. */
  directLink?: Maybe<Scalars["String"]["output"]>;
  /** The reward amount (raw) for the affiliate. */
  fee?: Maybe<Scalars["Float"]["output"]>;
  /** The ID of the affiliate (CAN POTENTIALLY BE NULL IF NO AFFILIATE HAS BEEN CREATED YET). */
  id?: Maybe<Scalars["ID"]["output"]>;
  /** Whether or not the affiliate will only receive one payout. */
  onlyOnePayout?: Maybe<Scalars["Boolean"]["output"]>;
  /** The type of payout for the affiliate commission. */
  payoutType?: Maybe<PayoutTypes>;
  /** The price (formatted) of the plan that can be referred. */
  planFormattedPrice?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the plan that can be referred. */
  planId?: Maybe<Scalars["String"]["output"]>;
  /** The name of the plan that can be referred. */
  planName?: Maybe<Scalars["String"]["output"]>;
  /** The reward amount (formatted) for the affiliate. */
  reward?: Maybe<Scalars["String"]["output"]>;
  /** The total amount of money the affiliate has earned from referrals, if available. */
  totalReferralEarnings?: Maybe<Scalars["String"]["output"]>;
  /** The total number of memberships the affiliate has referred so far, if available. */
  totalReferrals?: Maybe<Scalars["Int"]["output"]>;
  /** The whop username of the affiliate (aka their referral code). */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for PlanAffiliate. */
export type PlanAffiliateConnection = {
  __typename?: "PlanAffiliateConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlanAffiliateEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PlanAffiliate>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PlanAffiliateEdge = {
  __typename?: "PlanAffiliateEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PlanAffiliate>;
};

/** The connection type for Plan. */
export type PlanConnection = {
  __typename?: "PlanConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Plan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The type of direct link to generate */
export enum PlanDirectLink {
  Checkout = "checkout",
  ProductPage = "product_page",
}

/** An edge in a connection. */
export type PlanEdge = {
  __typename?: "PlanEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Plan>;
};

/** Values to filter plans on */
export type PlanFilters = {
  /** A specific access pass to filter the scope by. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** If true, it returns plans that have affiliates */
  affiliates?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What to order the results by. */
  order?: InputMaybe<PlanOrder>;
  /** If true, it returns plans that have member/passholder affiliates set to true */
  passholderAffiliate?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** If true, it returns raffles that have ended. */
  raffleEnded?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The release method to filter the scope by. */
  releaseMethod?: InputMaybe<ReleaseMethod>;
  /** The visibility to filter the scope by. */
  visibility?: InputMaybe<VisibilityFilter>;
};

/** The order to sort the results by. */
export enum PlanOrder {
  Affiliates = "affiliates",
  CreatedAt = "created_at",
  ExpiresAt = "expires_at",
  InternalNotes = "internal_notes",
}

/** The type of plan that can be attached to an access pass */
export enum PlanTypes {
  /** One Time */
  OneTime = "one_time",
  /** Renewal */
  Renewal = "renewal",
}

/** The ways a relation of Plans can be ordered */
export enum PlansOrder {
  ActiveMembersCount = "active_members_count",
  CreatedAt = "created_at",
  ExpiresAt = "expires_at",
  Id = "id",
  InternalNotes = "internal_notes",
}

/** Which columns can be used to sort. */
export enum PlansSortableColumns {
  ActiveMembersCount = "active_members_count",
  ActiveMembershipsCount = "active_memberships_count",
  CachedInitialPriceDue = "cached_initial_price_due",
  CachedUsdIncome = "cached_usd_income",
  CreatedAt = "created_at",
  Id = "id",
  Stock = "stock",
}

/** Represents a poll in a feed post */
export type Poll = {
  __typename?: "Poll";
  /** The options for the poll */
  options?: Maybe<Array<PollOption>>;
};

/** Input type for creating a poll in a feed post */
export type PollInput = {
  /** The options for the poll. Must have sequential IDs starting from 1 */
  options: Array<PollOptionInput>;
};

/** Represents a single poll option */
export type PollOption = {
  __typename?: "PollOption";
  /** The ID of the poll option */
  id: Scalars["String"]["output"];
  /** The text of the poll option */
  text: Scalars["String"]["output"];
};

/** Input type for a single poll option */
export type PollOptionInput = {
  /** Sequential ID for the poll option (starting from '1') */
  id: Scalars["String"]["input"];
  /** The text of the poll option */
  text: Scalars["String"]["input"];
};

/** Autogenerated input type of PollVideo */
export type PollVideoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The operation id of the video */
  operationId: Scalars["String"]["input"];
};

export type PollVideoResponse = {
  __typename?: "PollVideoResponse";
  /** The error message of the video */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** The progress of the video. Out of 100 */
  progress?: Maybe<Scalars["Int"]["output"]>;
  /** The state of the video */
  state?: Maybe<Scalars["String"]["output"]>;
  /** The url of the video */
  url?: Maybe<Scalars["String"]["output"]>;
  /** The video data of the video */
  videoData?: Maybe<Scalars["String"]["output"]>;
};

export type PostInput = {
  /** The id of the feed the post belongs to */
  feedId: Scalars["ID"]["input"];
  /** The type of feed the post belongs to */
  feedType: FeedTypes;
  /** The id of the post to mark as viewed */
  postId: Scalars["ID"]["input"];
};

/** The type of feed to fetch from */
export enum PostTypes {
  /** Dms */
  Dms = "dms",
  /** Dms Post */
  DmsPost = "dms_post",
  /** Forum Post */
  ForumPost = "forum_post",
}

/** Autogenerated input type of PresignedUpload */
export type PresignedUploadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Allowed to send ["pdf", "jpeg", "jpg", "png", "gif", "webp", "zip", "mp4", "mp3", "mov", "mpga", "qt", "svg", "docx", "xlsx", "pptx", "doc", "xls", "ppt", "txt", "csv", "avi", "wav", "m4a", "wmv", "rar", "pages", "numbers", "keynote", "odt", "ods", "rtf", "eps", "ai", "psd", "tiff", "m4v", "mkv", "aac", "flac", "vcf", "ics", "heic", "avif"] */
  fileExtV2?: InputMaybe<AllowedFileExtensions>;
  /** Allowed to upload a public file */
  isPublic?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The different pricing options available to select from. */
export enum PricingOptions {
  Free = "free",
  Nft = "nft",
  Paid = "paid",
}

/** An API key connected to an application */
export type PrivateApiKey = {
  __typename?: "PrivateApiKey";
  /** When this API key was created at */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of this API key */
  id: Scalars["ID"]["output"];
  /** A user set name to identify an API key */
  nickname?: Maybe<Scalars["String"]["output"]>;
  /** The permissions this api key has enabled. If its empty, the api key is unscoped. */
  permissions: Array<ApiKeyPermissions>;
  /** This is the API key used to authenticate requests */
  token: Scalars["String"]["output"];
  /** If true, the api key is unscoped and has access to all endpoints. */
  unscoped: Scalars["Boolean"]["output"];
};

/** The connection type for PrivateApiKey. */
export type PrivateApiKeyConnection = {
  __typename?: "PrivateApiKeyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PrivateApiKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PrivateApiKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PrivateApiKeyEdge = {
  __typename?: "PrivateApiKeyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PrivateApiKey>;
};

/** A wheel prize */
export type Prize = {
  __typename?: "Prize";
  /** When the wheel spin was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the wheel spin */
  id: Scalars["ID"]["output"];
  /** The image URL of the prize */
  imageUrl?: Maybe<Scalars["String"]["output"]>;
  /** The name of the prize */
  name: Scalars["String"]["output"];
};

/** The result of a checkout by the ProcessCheckoutWorker. */
export type ProcessCheckoutData = {
  __typename?: "ProcessCheckoutData";
  /** If the payment is using Apple and there is additional data required to complete the payment, it will be present here. */
  appleData?: Maybe<AppleData>;
  /** The authorization code that should be used to authenticate the user after the receipt is created. */
  authorizationCode?: Maybe<Scalars["String"]["output"]>;
  /** The additional data required to process a Coinbase payment. */
  coinbaseData?: Maybe<CoinbaseData>;
  /** The ID of the member this checkout is for. */
  memberId?: Maybe<Scalars["ID"]["output"]>;
  /** The ID of the membership this checkout is for. */
  membershipId?: Maybe<Scalars["ID"]["output"]>;
  /** If the payment is using Multi PSP and there is additional data required to complete the payment, it will be present here. */
  multiPspData?: Maybe<MultiPspData>;
  /** The ID of the payment method used for this checkout. This will be present if the payment method was successfully created or used. */
  paymentMethodId?: Maybe<Scalars["ID"]["output"]>;
  /** The payment processor used for this checkout. This will be one of the supported payment processors like 'stripe', 'paypal', etc. */
  paymentProcessor: PaymentProcessor;
  /** Extra data required to facilitate a PayPal checkout. */
  paypalData?: Maybe<Scalars["JSON"]["output"]>;
  /** The ID of the receipt to poll the status of after the transaction has been submitted */
  receiptId: Scalars["ID"]["output"];
  /** Upon successful checkout, redirect the user here. */
  redirect: Scalars["String"]["output"];
  /** This is true if the checkout requires additional action by the user before it can be completed. */
  requiresAction: Scalars["Boolean"]["output"];
  /** If the payment is using Sezzle and there is additional data required to complete the payment. */
  sezzleData?: Maybe<SezzleData>;
  /** If the payment is using Splitit and there is additional data required to complete the payment, it will be present here. */
  splititData?: Maybe<SplititData>;
  /** If the payment is using Stripe and there is additional data required to complete the payment, it will be present here. */
  stripeData?: Maybe<StripeData>;
};

/** Autogenerated input type of ProcessCheckout */
export type ProcessCheckoutInput = {
  /** The username of the affiliate who is referring this purchase. */
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the checkout session to complete the checkout with (query param from Public API). */
  apiCheckoutSessionId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An object of Basis Theory attributes to use for the checkout. */
  basisTheory?: InputMaybe<BasisTheoryInput>;
  /** The ID of the checkout session that was used to complete the payment with (query param from FE). */
  checkoutId?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company the user is buying a membership for. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An array of custom field responses. */
  customFieldResponses?: InputMaybe<Array<CustomFieldResponseInput>>;
  /** A password that is required to unlock the checkout for the specific plan. */
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account that is being paid for the purchase. */
  destinationLedgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether the checkout is for a direct-to-consumer purchase. */
  directToConsumer?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to force skip the free trial for the plan being purchased. */
  forceSkipFreeTrial?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Google analytics client id */
  gaClientId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the line item to purchase. */
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * The location of the user making the purchase.
   * @deprecated No longer implemented
   */
  location?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to return an authorization code for the user to login on checkout completion. */
  login?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the mailing address object being used in the checkout. */
  mailingAddressId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The amount to charge. */
  manualAmount?: InputMaybe<Scalars["Float"]["input"]>;
  /** The currency to charge. */
  manualCurrency?: InputMaybe<Currencies>;
  /** The internal ID of the payment method the user wants to use to purchase (if applicable). (pmt_, payt_, pm_, or ctoken_) */
  paymentMethodId?: InputMaybe<Scalars["String"]["input"]>;
  /** The payment processor to use for the purchase. */
  paymentProcessor: PaymentProcessor;
  /** An unverified phone number the user is asked to enter at checkout. */
  phoneNumber?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the plan to purchase. */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The buyer fee percentage presented to the user, if any. */
  presentedBuyerFeePercentage?: InputMaybe<Scalars["Float"]["input"]>;
  /** Misc data to attach to the membership that is generated. */
  privateMetadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /** The code of the promo code attempting to be used on this checkout. */
  promoCode?: InputMaybe<Scalars["String"]["input"]>;
  /** How many of the specific plan the user is purchasing. Usually just 1. */
  quantity?: InputMaybe<Scalars["Int"]["input"]>;
  /** A unique code to unlock a checkout (usually for transfers) */
  quickLinkCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The type of service used for the Splitit checkout. */
  serviceType?: InputMaybe<CheckoutServiceTypes>;
  /** The stripe setup future usage value for the checkout . */
  setupFutureUsage?: InputMaybe<Scalars["String"]["input"]>;
  /** The source of the checkout */
  source?: InputMaybe<CheckoutSource>;
  /** The ID of the payment method configuration that was used for the purchase, if any. */
  stripePaymentMethodConfigurationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of an existing membership the user is attempting to renew or attach a one off payment to. */
  topUpMembershipId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the tracking link that was used for the checkout. */
  trackingLinkId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The metadata for a fund transfer. */
  transferFundsMetadata?: InputMaybe<TransferFundsMetadata>;
  /** The ID of the plan the user was upselled from. */
  upsellFromPlanId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A European VAT ID to attach to the user's Stripe customer profile. */
  vatId?: InputMaybe<Scalars["String"]["input"]>;
  /** The origin of the checkout session (ex. https://whop.com). */
  webOrigin?: InputMaybe<Scalars["String"]["input"]>;
};

/** The result of a checkout by the ProcessCheckoutWorker. */
export type ProcessCheckoutStatus = {
  __typename?: "ProcessCheckoutStatus";
  /** The data returned by the job. */
  data?: Maybe<ProcessCheckoutData>;
  /** The error returned by the job. */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** The status of the job. */
  status: JobStatuses;
};

/** Autogenerated input type of ProcessEntities */
export type ProcessEntitiesInput = {
  /** The ID of the app */
  appId: Scalars["ID"]["input"];
  /** The chat feed posts to process */
  chatFeeds?: InputMaybe<Array<ChatFeedInput>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The DMs feed members to process */
  dmsFeedMembers?: InputMaybe<Array<DmsFeedMemberInput>>;
  /** The DMs feeds to process */
  dmsFeeds?: InputMaybe<Array<DmsFeedInput>>;
  /** The DMs posts to process */
  dmsPosts?: InputMaybe<Array<DmsPostInput>>;
  /** The livestream feeds to process */
  livestreamFeeds?: InputMaybe<Array<LivestreamFeedInput>>;
  /** The chat feed muted members to process */
  mutedUsers?: InputMaybe<Array<MutedUserInput>>;
  /** The reactions to process */
  reactions?: InputMaybe<Array<ReactionInput>>;
};

/** The output of the process entities mutation */
export type ProcessEntitiesOutput = {
  __typename?: "ProcessEntitiesOutput";
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt?: Maybe<Scalars["BigInt"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The sort key for the entity */
  sortKey?: Maybe<Scalars["String"]["output"]>;
  /** The error that occurred during sync */
  syncError?: Maybe<SyncError>;
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt?: Maybe<Scalars["BigInt"]["output"]>;
};

/** Autogenerated return type of ProcessEntities. */
export type ProcessEntitiesPayload = {
  __typename?: "ProcessEntitiesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The entities that were processed */
  entities: Array<ProcessEntitiesOutput>;
};

/** The result of an entry creation by the ProcessEntryWorker. */
export type ProcessEntryData = {
  __typename?: "ProcessEntryData";
  /** The authorization code that should be used to authenticate the user after the entry is created. */
  authorizationCode?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the entry that was created. */
  entryId: Scalars["ID"]["output"];
  /** If the entry is using Multi PSP and there is additional data required to complete the entry, it will be present here. */
  multiPspData?: Maybe<MultiPspData>;
  /** The ID of the payment method used for this checkout. This will be present if the payment method was successfully created or used. */
  paymentMethodId?: Maybe<Scalars["ID"]["output"]>;
  /** The payment processor used for this checkout. This will be one of the supported payment processors like 'stripe', 'paypal', etc. */
  paymentProcessor: PaymentProcessor;
  /** The location where the user should be redirected after the entry is created. */
  redirect: Scalars["String"]["output"];
  /** This is true if the entry requires additional action by the user before it can be completed. */
  requiresAction: Scalars["Boolean"]["output"];
};

/** Autogenerated input type of ProcessEntry */
export type ProcessEntryInput = {
  /** The username of the affiliate who is referring this purchase. */
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the checkout session to complete the checkout with (query param from Public API). */
  apiCheckoutSessionId?: InputMaybe<Scalars["ID"]["input"]>;
  /** An object of Basis Theory attributes to use for the checkout. */
  basisTheory?: InputMaybe<BasisTheoryInput>;
  /** The ID of the checkout used to generate the entry. This is from the FE. */
  checkoutId?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** An array of custom field responses. */
  customFieldResponses?: InputMaybe<Array<CustomFieldResponseInput>>;
  /** A password that is required to unlock the checkout for the specific plan. */
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether the checkout is for a direct-to-consumer purchase. */
  directToConsumer?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Google analytics client id */
  gaClientId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to return an authorization code for the user to login on entry completion. */
  login?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the mailing address object being used in the checkout, if any. */
  mailingAddressId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The internal ID of the payment method the user wants to use to purchase (if applicable). (pmt_ or payt_) */
  paymentMethodId?: InputMaybe<Scalars["String"]["input"]>;
  /** The payment processor to use for the purchase. */
  paymentProcessor: PaymentProcessor;
  /** The ID of the plan to purchase. */
  planId: Scalars["ID"]["input"];
  /** The buyer fee percentage presented to the user, if any. */
  presentedBuyerFeePercentage?: InputMaybe<Scalars["Float"]["input"]>;
  /** Misc data to attach to the membership that is generated. */
  privateMetadata?: InputMaybe<Scalars["JSON"]["input"]>;
  /** The type of service used for the Splitit checkout. */
  serviceType?: InputMaybe<CheckoutServiceTypes>;
  /** The stripe setup future usage value for the checkout . */
  setupFutureUsage?: InputMaybe<Scalars["String"]["input"]>;
  /** The source of the checkout */
  source?: InputMaybe<CheckoutSource>;
  /** The ID of the payment method configuration that was used for the purchase, if any. */
  stripePaymentMethodConfigurationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the tracking link that was used for the checkout. */
  trackingLinkId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A European VAT ID to attach to the user's Stripe customer profile. */
  vatId?: InputMaybe<Scalars["String"]["input"]>;
  /** The origin of the checkout session (ex. https://whop.com). */
  webOrigin?: InputMaybe<Scalars["String"]["input"]>;
};

/** The status of a ProcessEntryWorker job as well as its accompanying data. */
export type ProcessEntryStatus = {
  __typename?: "ProcessEntryStatus";
  /** The data returned by the job. */
  data?: Maybe<ProcessEntryData>;
  /** The error returned by the job. */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** The status of the job. */
  status: JobStatuses;
};

/** Autogenerated input type of ProcessForumEntities */
export type ProcessForumEntitiesInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The forum feeds to process */
  forumFeeds?: InputMaybe<Array<ForumFeedInput>>;
  /** The forum posts to process */
  forumPosts?: InputMaybe<Array<ForumPostInput>>;
  /** The reactions to process */
  reactions?: InputMaybe<Array<ReactionInput>>;
};

/** Autogenerated return type of ProcessForumEntities. */
export type ProcessForumEntitiesPayload = {
  __typename?: "ProcessForumEntitiesPayload";
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars["String"]["output"]>;
  /** The entities that were processed */
  entities: Array<ProcessEntitiesOutput>;
};

/** An object representing a product highlight (ex. card on product detail screen) */
export type ProductHighlight = {
  __typename?: "ProductHighlight";
  /** Highlight text provided by the user */
  content: Scalars["String"]["output"];
  /** The type of highlight. Informs the UI rendering */
  highlightType: ProductHighlightTypes;
  /** The ID of the product highlight. */
  id: Scalars["ID"]["output"];
  /** The position of the product highlight in the list of highlights, if applicable. */
  position: Scalars["Int"]["output"];
  /** Title of the product highlight, if applicable */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for ProductHighlight. */
export type ProductHighlightConnection = {
  __typename?: "ProductHighlightConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductHighlightEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProductHighlight>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ProductHighlightEdge = {
  __typename?: "ProductHighlightEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ProductHighlight>;
};

/** Types of product highlight */
export enum ProductHighlightTypes {
  Benefit = "benefit",
  PricingFeature = "pricing_feature",
  Qualification = "qualification",
  WhoThisIsFor = "who_this_is_for",
}

/** Image styles for product. */
export enum ProductImageStyles {
  S48 = "s48",
  S48fit = "s48fit",
  S64 = "s64",
  S64fit = "s64fit",
  S80 = "s80",
  S80fit = "s80fit",
  S128 = "s128",
  S180 = "s180",
  S250x125 = "s250x125",
  S250x125fit = "s250x125fit",
  S440x220 = "s440x220",
  S440x220fit = "s440x220fit",
  S500x250 = "s500x250",
  S500x250fit = "s500x250fit",
  S512x288 = "s512x288",
  S512x288fit = "s512x288fit",
  S600x400 = "s600x400",
  S600x400fit = "s600x400fit",
  S1000x500 = "s1000x500",
  S1000x500fit = "s1000x500fit",
  S1280x720 = "s1280x720",
  S1280x720fit = "s1280x720fit",
  S1920x1080 = "s1920x1080",
  S1920x1080fit = "s1920x1080fit",
}

/** Values to filter users on */
export type ProductUserFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What to order the results by. */
  order?: InputMaybe<ProductUserOrder>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The order to sort the results by. */
export enum ProductUserOrder {
  DateJoined = "date_joined",
  LastSeenAt = "last_seen_at",
  Name = "name",
  PaidOutByCompany = "paid_out_by_company",
  TimeSpentInWhop = "time_spent_in_whop",
}

/** The different levels of visibility for resources */
export enum ProfileVisibilities {
  Hidden = "hidden",
  Visible = "visible",
}

/** An object representing a promo code for a plan. */
export type PromoCode = {
  __typename?: "PromoCode";
  /** The access pass associated with the promo code. */
  accessPass?: Maybe<AccessPass>;
  /** The amount off (% or flat amount) for the promo. */
  amountOff: Scalars["Float"]["output"];
  /** The monetary currency of the promo code. */
  baseCurrency: Currencies;
  /** Restricts promo use to only users who have churned from the company before. */
  churnedUsersOnly: Scalars["Boolean"]["output"];
  /** The specific code used to apply the promo at checkout. */
  code?: Maybe<Scalars["String"]["output"]>;
  /** The company for the promo code. */
  company: Company;
  /** The timestamp of when the promo was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The amount off formatted for display. */
  discountOff: Scalars["String"]["output"];
  /** The duration of the promo. */
  duration?: Maybe<PromoDurations>;
  /** Restricts promo use to only be applied to already purchased memberships. */
  existingMembershipsOnly: Scalars["Boolean"]["output"];
  /** The date/time of when the promo expires. */
  expirationDatetime?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The flash sale associated with the promo code. */
  flashSale?: Maybe<PublicFlashSale>;
  /** The ID of the promo. */
  id: Scalars["ID"]["output"];
  /** Restricts promo use to only users who have never purchased from the company before. */
  newUsersOnly: Scalars["Boolean"]["output"];
  /** The number of billing cycles the promo is applied for. */
  numberOfIntervals?: Maybe<Scalars["Int"]["output"]>;
  /** Restricts promo use to only be applied once per customer. */
  onePerCustomer: Scalars["Boolean"]["output"];
  /** The plans associated with the promo code. */
  plans?: Maybe<PlanConnection>;
  /** The type (% or flat amount) of the promo. */
  promoType: PromoTypes;
  /** Indicates if the promo code is live or disabled. */
  status: PromoCodeStatus;
  /** The quantity limit on the number of uses. */
  stock: Scalars["Int"]["output"];
  /** Whether or not the promo code has unlimited stock. */
  unlimitedStock: Scalars["Boolean"]["output"];
  /** The amount of times the promo codes has been used. */
  uses: Scalars["Int"]["output"];
};

/** An object representing a promo code for a plan. */
export type PromoCodePlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PromoCode. */
export type PromoCodeConnection = {
  __typename?: "PromoCodeConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PromoCodeEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PromoCode>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PromoCodeEdge = {
  __typename?: "PromoCodeEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PromoCode>;
};

/** Values to filter promo codes on */
export type PromoCodeFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** Filter whether to return active or expired (archived and inactive). */
  newStatus?: InputMaybe<PromoCodeNewStatus>;
  /** What to order the results by. */
  order?: InputMaybe<PromoCodeOrder>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of promo code. */
  status?: InputMaybe<PromoCodeStatus>;
};

/** The new statuses to filter the results by. */
export enum PromoCodeNewStatus {
  Active = "active",
  Expired = "expired",
}

/** The order to sort the results by. */
export enum PromoCodeOrder {
  Code = "code",
  CreatedAt = "created_at",
}

/** Statuses for promo codes */
export enum PromoCodeStatus {
  /** Active */
  Active = "active",
  /** Archived */
  Archived = "archived",
  /** Inactive */
  Inactive = "inactive",
}

/** Which columns can be used to sort. */
export enum PromoCodesSortableColumns {
  CreatedAt = "created_at",
  ExpirationDatetime = "expiration_datetime",
  Id = "id",
}

/** The duration setting for the promo code */
export enum PromoDurations {
  /** Forever */
  Forever = "forever",
  /** Once */
  Once = "once",
  /** Repeating */
  Repeating = "repeating",
}

/** The type of promo code used to discount a plan */
export enum PromoTypes {
  /** Flat Amount */
  FlatAmount = "flat_amount",
  /** Percentage */
  Percentage = "percentage",
}

export type PublicAbuseReportInterface = {
  /** The category of the abuse report */
  abuseReportCategory: AbuseReportCategory;
  /** The sub category of the abuse report */
  abuseReportSubCategory: AbuseReportSubCategory;
  /** The attachments for the abuse report */
  attachments: Array<AttachmentInterface>;
  /** When the abuse report was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the abuse report */
  description: Scalars["String"]["output"];
  /** The ID of the abuse report */
  id: Scalars["ID"]["output"];
  /** The images for the abuse report */
  images: Array<Image>;
  /** The status of the abuse report */
  status: AbuseReportStatus;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPass = {
  __typename?: "PublicAccessPass";
  /** The order of this access pass in relation to other access passes of the same company */
  accessPassOrder: Scalars["Int"]["output"];
  /** The type of access pass */
  accessPassType: AccessPassTypes;
  /** The number of active users for this access pass. */
  activeUsersCount: Scalars["Int"]["output"];
  /** Marks whether the customer has already purchased this pass. */
  alreadyOwned: Scalars["Boolean"]["output"];
  /** The app that is connected to this access pass, if any. */
  app?: Maybe<PublicApp>;
  /**
   * App sessions for this access pass.
   * @deprecated Use app_sessions_count instead
   */
  appSessions: AccessPassAppSessions;
  /**
   * The number of app sessions for this access pass.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  appSessionsCount: Scalars["Int"]["output"];
  /** The criteria for the company to be on the marketplace. */
  applicationCriteria: Array<MarketplaceApplicationCriteria>;
  /** The current step of the application criteria. */
  applicationCriteriaCurrentStep?: Maybe<ApplicationCriteriaIdentifier>;
  /** The unique apps of all experiences in this access pass. */
  apps: PublicAppConnection;
  /** The attachments for the access pass. */
  attachments: AttachmentInterfaceConnection;
  /** The banner image for the access pass. */
  bannerImage?: Maybe<AttachmentInterface>;
  /** The bounties for this access pass. */
  bounties: BountyConnection;
  /**
   * The number of times the card has been clicked.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  cardClickCount: Scalars["Int"]["output"];
  /**
   * The number of times the card has been viewed.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  cardImpressionCount: Scalars["Int"]["output"];
  /** A short type of the company that this access pass belongs to. */
  company: PublicCompany;
  /** The competitions for this access pass. */
  competitions: Array<Competition>;
  /** When the public access pass was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was created */
  createdAtMs: Scalars["BigInt"]["output"];
  /** The creator pitch for the access pass. */
  creatorPitch?: Maybe<Scalars["String"]["output"]>;
  /** The custom call to action for the access pass. */
  customCta: CustomCtas;
  /** The custom call to action URL for the access pass, if any. */
  customCtaUrl?: Maybe<Scalars["String"]["output"]>;
  /** The default plan for this access pass */
  defaultPlan?: Maybe<PublicPlan>;
  /** Whether the access pass can be deleted. */
  deletable: Scalars["Boolean"]["output"];
  /**
   * A written description of the access pass.
   * @deprecated No longer used
   */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The direct link to purchase the access pass. */
  directLink: Scalars["String"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was soft deleted. If it's null, the access pass is still active. */
  discardedAtMs?: Maybe<Scalars["BigInt"]["output"]>;
  /** The date and time when the access pass went on Discovery. */
  discoverableAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Discovery Tags applied to this AccessPass. */
  discoveryTags: DiscoveryTagConnection;
  /** Whether or not the company publicly displays discover stats */
  displayDiscoverStats: Scalars["Boolean"]["output"];
  /** An array of experiences that this pass has. */
  experiences: Array<PublicExperience>;
  /** Custom frequently asked questions to display. */
  faq: Array<FaqObject>;
  /** The featured access passes for this access pass. */
  featuredAccessPasses: Array<PublicAccessPass>;
  /** The featured reviews of the access pass. */
  featuredReviews: Array<Review>;
  /** The featured users of the access pass. */
  featuredUsers: Array<PublicProfileUser>;
  /**
   * The file attachments for the access pass.
   * @deprecated use attachments instead
   */
  fileAttachments: FileAttachmentConnection;
  /** The date and time when the access pass was first approved for the marketplace. */
  firstApprovedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** All of the forum experiences connected to the access pass. */
  forumExperiences: PublicExperienceConnection;
  /** The percentage of a transaction a user is eligible to earn from the whop marketplace global affiliate program. */
  globalAffiliatePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The status of the global affiliate program for this access pass. */
  globalAffiliateStatus: GlobalAffiliateStatuses;
  /** Whether the access pass has a free available plan. */
  hasFreeAvailablePlan: Scalars["Boolean"]["output"];
  /** Whether the current user has liked the access pass. */
  hasLiked: Scalars["Boolean"]["output"];
  /** Whether the access pass has a paid available plan. */
  hasPaidAvailablePlan: Scalars["Boolean"]["output"];
  /** The headline of the access pass. */
  headline?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the public access pass. */
  id: Scalars["ID"]["output"];
  /**
   * The image for the public access pass.
   * @deprecated Use imageSrcset instead.
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The image for the public access pass. Deprecated, use logo instead. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The marketplace/branding images for the company. */
  images: Array<Image>;
  /** Whether the current user is an affiliate access pass. */
  isAccessPassAffiliate: Scalars["Boolean"]["output"];
  /** Whether the access pass has a free plan that doesn't have any requirements. */
  isFreeAndJoinableWithoutRequirements: Scalars["Boolean"]["output"];
  /** The access_passes's item ordering. */
  itemOrdering: ItemOrdering;
  /** The total number of published reviews for this access pass. */
  last7DaysPublishedReviews: Scalars["Int"]["output"];
  /** The affiliate earnings in the last 24 hours. */
  last24HoursAffiliateEarnings: Scalars["Float"]["output"];
  /** The average time spent in the last 24 hours, in seconds. */
  last24HoursAverageTimeSpent: Scalars["Int"]["output"];
  /** The GMV in the last 24 hours. */
  last24HoursGmv: Scalars["Float"]["output"];
  /** The number of new users in the last 24 hours. */
  last24HoursNewUsers: Scalars["Int"]["output"];
  /** The number of reviews in L24 hours */
  last24HoursPublishedReviews: Scalars["Int"]["output"];
  /** The total seconds spent on this access pass' experiences on the last day. This is tracked using our time tracking mechanism. It combines iOS, Web, and Android, and only tracks when users with access are looking at experiences. It excludes Discord & Telegram */
  last24HoursTotalSeconds: Scalars["Int"]["output"];
  /** The total number of users last 24 hours that make up the last_24_hours_total_seconds field */
  last24HoursTotalUsers: Scalars["Int"]["output"];
  /** The number of new users in the last 30 days. */
  last30DaysNewUsers: Scalars["Int"]["output"];
  /** A leaderboard result for this access pass */
  leaderboard?: Maybe<Leaderboard>;
  /** The total number of likes for the access pass. */
  likeCount: Scalars["Int"]["output"];
  /** The logo for the access pass. */
  logo?: Maybe<AttachmentInterface>;
  /** The marketplace categories for the page. */
  marketplaceCategories: MarketplaceCategoryConnection;
  /** Fetch a marketplace category in respect to the level. */
  marketplaceCategory?: Maybe<MarketplaceCategory>;
  /** The status of the access pass in the marketplace. */
  marketplaceStatus: MarketplaceStatuses;
  /** The most recent review for the access pass. */
  mostRecentReview?: Maybe<Review>;
  /**
   * The name of the access pass. It must be max 50 characters.
   * @deprecated Use title instead
   */
  name: Scalars["String"]["output"];
  /** The access pass's onboarding version. */
  onboardingVersion?: Maybe<AccessPassOnboardingVersionTypes>;
  /**
   * A user can/cannot own multiple of this pass.
   * @deprecated No longer used
   */
  onePerUser: Scalars["Boolean"]["output"];
  /** The user that owns the access pass (company owner). */
  ownerUser: PublicProfileUser;
  /** The experience that is pinned in this access pass */
  pinnedExperience?: Maybe<PublicExperience>;
  /** The experiences that current user sees as pinned in this access pass */
  pinnedExperiences: PublicExperienceConnection;
  /** The popup promo code for the access pass, if any. */
  popupPromoCode?: Maybe<PublicPromoCode>;
  /** Product highlights displayed on the product detail screen. */
  productHighlights: ProductHighlightConnection;
  /** The public affiliate earnings chart for this access pass */
  publicAffiliateEarningsChart?: Maybe<ChartsDataNumber>;
  /** The public average time spent chart for this access pass */
  publicAverageTimeSpentChart?: Maybe<ChartsDataNumber>;
  /** The public experiences for this access pass. */
  publicExperiences: PublicExperienceConnection;
  /** The public GMV chart for this access pass */
  publicGmvChart?: Maybe<ChartsDataNumber>;
  /** The public new users chart for this access pass */
  publicNewUsersChart?: Maybe<ChartsDataNumber>;
  /** The public reviews chart for this access pass */
  publicReviewsChart?: Maybe<ChartsDataNumber>;
  /** The number of reviews that have been published for the access pass. */
  publishedReviewsCount: Scalars["Int"]["output"];
  /** The URL to redirect the customer to after a purchase, if applicable. */
  redirectPurchaseUrl?: Maybe<Scalars["String"]["output"]>;
  /** Whether all marketplace application criteria have been met */
  requiredCriteriaMet: Scalars["Boolean"]["output"];
  /** Ratings real customers have written for the company. */
  reviews: ReviewConnection;
  /** The average of all reviews for this access pass. */
  reviewsAverage: Scalars["Float"]["output"];
  /** The percentage of reviews that makes up each star rating from 5 to 1. */
  reviewsBreakdown?: Maybe<Array<Scalars["Int"]["output"]>>;
  /** The route of the access pass. */
  route: Scalars["String"]["output"];
  /** The total number of shares for the access pass. */
  shareCount: Scalars["Int"]["output"];
  /** A short description of what the company offers or does. */
  shortenedDescription?: Maybe<Scalars["String"]["output"]>;
  /** Whether to show the custom CTA on discover. */
  showCustomCtaOnDiscover: Scalars["Boolean"]["output"];
  /** Whether to show the member count. */
  showMemberCount: Scalars["Boolean"]["output"];
  /** Whether to show the offers on the access pass. */
  showOffers: Scalars["Boolean"]["output"];
  /** Whether to show the owner user. */
  showOwnerUser: Scalars["Boolean"]["output"];
  /** Whether to show reviews on the access pass. */
  showReviewsDtc: Scalars["Boolean"]["output"];
  /** The social links for the access pass. */
  socialLinks: Array<SocialLink>;
  /**
   * The number of times the store page has been clicked.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  storePageClicksCount: Scalars["Int"]["output"];
  /**
   * The number of times the store page has been viewed.
   * @deprecated This field died with the old Discover, and returns 0 by default
   */
  storePageViewsCount: Scalars["Int"]["output"];
  /** The title of the access pass. Use for Whop 4.0. */
  title: Scalars["String"]["output"];
  /** The total bounty amount for this access pass. */
  totalBountyAmount: Scalars["Float"]["output"];
  /** This access pass can/cannot be transferred to another user. */
  transferable: Scalars["Boolean"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the access pass was updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** The description of the upsell for the access pass. */
  upsellDescription?: Maybe<Scalars["String"]["output"]>;
  /** The media for the upsell of the access pass in png, jpeg, or gif format */
  upsellMedia?: Maybe<AttachmentInterface>;
  /** The title of the upsell for the access pass. */
  upsellTitle?: Maybe<Scalars["String"]["output"]>;
  /** The upsells for this access pass. */
  upsells: PublicAccessPassConnection;
  /** The USD GMV for the last 30 days. */
  usdGmv: Scalars["Int"]["output"];
  /** The users of the access pass. */
  users: PublicProfileUserConnection;
  /** The users that have access passes in common with the current user. */
  usersWithAccessPassesInCommon: PublicProfileUserConnection;
  /** Whether this product is Whop verified. */
  verified: Scalars["Boolean"]["output"];
  /** This access pass will/will not be displayed publicly. */
  visibility: Visibility;
  /** A count of the visible plans on this access pass */
  visiblePlans: PublicPlanConnection;
  /**
   * the welcome message to be shown to users when they buy an access pass
   * @deprecated No longer used.
   */
  welcomeMessage?: Maybe<Scalars["String"]["output"]>;
  /** The date and time when the access pass was ready for the marketplace. */
  whopFourReadyAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ranking of the access pass in the marketplace. */
  whopRanking?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The users of the access pass.
   * @deprecated Use whop_users_sidebar_with_rank instead
   */
  whopUsersSidebar: PublicProfileUserConnection;
  /** The users of the access pass ranked by earnings on the platform. */
  whopUsersSidebarWithEarnings: EarningsSidebarOutput;
  /** The users of the access pass. */
  whopUsersSidebarWithRank: SidebarOutput;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassAppsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  category: AccessPassAttachmentCategories;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassBountiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  category: AccessPassAttachmentCategories;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassForumExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ProductImageStyles>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassItemOrderingArgs = {
  orderType: ItemOrderingOrderTypes;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassLeaderboardArgs = {
  competitionId?: InputMaybe<Scalars["String"]["input"]>;
  latestPaginationRank?: InputMaybe<Scalars["Int"]["input"]>;
  leaderboardType: LeaderboardTypes;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassMarketplaceCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassMarketplaceCategoryArgs = {
  level: Scalars["Int"]["input"];
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassPinnedExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassProductHighlightsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  highlightType?: InputMaybe<ProductHighlightTypes>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassPublicExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  stars?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassUpsellsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassUsersWithAccessPassesInCommonArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassVisiblePlansArgs = {
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassWhopUsersSidebarArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ProductUserFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassWhopUsersSidebarWithEarningsArgs = {
  filter?: InputMaybe<WhopSidebarWithEarningsFilters>;
};

/** An object representing a (sanitized) access pass. */
export type PublicAccessPassWhopUsersSidebarWithRankArgs = {
  filter?: InputMaybe<WhopSidebarFilters>;
};

/** The connection type for PublicAccessPass. */
export type PublicAccessPassConnection = {
  __typename?: "PublicAccessPassConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicAccessPassEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicAccessPass>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicAccessPassEdge = {
  __typename?: "PublicAccessPassEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicAccessPass>;
};

/** The order to sort the results by. */
export enum PublicAccessPassesOrder {
  AverageTimeSpent_24Hours = "average_time_spent_24_hours",
  CreatedAt = "created_at",
  GlobalAffiliatePercentage = "global_affiliate_percentage",
  HighestBounties = "highest_bounties",
  Id = "id",
  Last_24HoursTotalSeconds = "last_24_hours_total_seconds",
  MostAffiliateEarnings_24Hours = "most_affiliate_earnings_24_hours",
  MostMoneyMade_24Hours = "most_money_made_24_hours",
  MostReviews_7Days = "most_reviews_7_days",
  MostReviews_24Hours = "most_reviews_24_hours",
  NewestArrivals = "newest_arrivals",
  Trending = "trending",
}

/** A log of an affiliate having referred someone */
export type PublicAffiliateReferralLog = {
  __typename?: "PublicAffiliateReferralLog";
  /** The product that was referred */
  accessPass: PublicAccessPass;
  /** How much the user earned off of the referral */
  amount: Scalars["Float"]["output"];
  /** When the referral was made */
  createdAt: Scalars["Timestamp"]["output"];
  /** How much the affiliate made with currency */
  formattedAmount: Scalars["String"]["output"];
  /** The ID of the log. */
  id: Scalars["ID"]["output"];
};

/** The connection type for PublicAffiliateReferralLog. */
export type PublicAffiliateReferralLogConnection = {
  __typename?: "PublicAffiliateReferralLogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicAffiliateReferralLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicAffiliateReferralLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicAffiliateReferralLogEdge = {
  __typename?: "PublicAffiliateReferralLogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicAffiliateReferralLog>;
};

/** An object representing an app */
export type PublicApp = {
  __typename?: "PublicApp";
  /** The access pass for the app */
  accessPass?: Maybe<PublicAccessPass>;
  /** The app views for this app */
  appViews: AppViewConnection;
  /** The developer base url of the app */
  baseDevUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The preview base url of the app, used primarily by Whop admins for pre-release versions of apps. */
  basePreviewUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The base url of the app */
  baseUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The capabilities of the app */
  capabilities: Array<Scalars["String"]["output"]>;
  /** The company that owns the app */
  company: PublicCompany;
  /** The number of experiences on a company that use this app */
  count?: Maybe<Scalars["Int"]["output"]>;
  /** The default experience description for this app */
  defaultExperienceDescription?: Maybe<Scalars["String"]["output"]>;
  /** The description of the app */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The unique part of the proxied domain for this app. */
  domainId: Scalars["String"]["output"];
  /** The path for the hub view of the app */
  experiencePath?: Maybe<Scalars["String"]["output"]>;
  /** If the apps experience's should force showing the pre-checkout iframe, and not rely on app connections. */
  forceCheckoutIframe: Scalars["Boolean"]["output"];
  /** The hub call to action text for this app */
  hubCta?: Maybe<Scalars["String"]["output"]>;
  /** The icon for the app */
  icon?: Maybe<AttachmentInterface>;
  /** The ID of the app */
  id: Scalars["ID"]["output"];
  /**
   * The image for the app
   * @deprecated Use imageSrcset instead.
   */
  image: Scalars["String"]["output"];
  /** The image for the experience interface. Deprecated, use icon instead. */
  imageSrcset: ImgSrcset;
  /** The internal identifier for the app */
  internalIdentifier?: Maybe<Scalars["String"]["output"]>;
  /**
   * whether or not this experience is internal to Whop
   * @deprecated No longer implemented. Always returns false.
   */
  isInternalExperience: Scalars["Boolean"]["output"];
  /** The name of the app */
  name: Scalars["String"]["output"];
  /** The notification preferences for this app */
  notificationTopics: NotificationTopicConnection;
  /** If the app can only create experiences with the private access level */
  onlyPrivate: Scalars["Boolean"]["output"];
  /**
   * The paths of the app
   * @deprecated Use app_views instead
   */
  paths: ExperienceInterfacePaths;
  /** The product page text for this app */
  productPageText?: Maybe<Scalars["String"]["output"]>;
  /**
   * The status for the app
   * @deprecated Use status_v2
   */
  status: ExperienceInterfaceStatuses;
  /** The status for the app */
  statusV2: AppStatuses;
  /** Total installs */
  totalInstalls: Scalars["Int"]["output"];
  /** If the experience is verified by Whop or not */
  verified: Scalars["Boolean"]["output"];
};

/** An object representing an app */
export type PublicAppAppViewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an app */
export type PublicAppImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an app */
export type PublicAppNotificationTopicsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  visibility?: InputMaybe<NotificationTopicVisibility>;
};

/** The connection type for PublicApp. */
export type PublicAppConnection = {
  __typename?: "PublicAppConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicAppEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicApp>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicAppEdge = {
  __typename?: "PublicAppEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicApp>;
};

/** The order to sort the results by. */
export enum PublicBountiesOrder {
  CreatedAt = "created_at",
  TotalPaid = "total_paid",
}

/** An object representing a bounty */
export type PublicBounty = {
  __typename?: "PublicBounty";
  /** The access passes associated with this bounty */
  accessPasses: PublicAccessPassConnection;
  /** Whether the bounty supports Instagram platform social posts */
  allowInstagram: Scalars["Boolean"]["output"];
  /** Whether the bounty supports TikTok platform social posts */
  allowTiktok: Scalars["Boolean"]["output"];
  /** Whether the bounty supports X platform social posts */
  allowX: Scalars["Boolean"]["output"];
  /** Whether the bounty supports YouTube platform social posts */
  allowYoutube: Scalars["Boolean"]["output"];
  /** The base unit amount for the bounty */
  baseUnitAmount: Scalars["Int"]["output"];
  /** The number of submissions for the bounty */
  bountySubmissionsCount: Scalars["Int"]["output"];
  /** The budget amount for the bounty */
  budgetAmount?: Maybe<Scalars["Float"]["output"]>;
  /** When the bounty was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the bounty */
  currency: Currencies;
  /** The description of the bounty */
  description: Scalars["String"]["output"];
  /** The status of the bounty */
  discoverStatus: DiscoverStatuses;
  /** The experience associated with this bounty */
  experience: PublicExperience;
  /** The file attachments for the bounty */
  fileAttachments: FileAttachmentConnection;
  /** The internal ID of the bounty */
  id: Scalars["ID"]["output"];
  /** The amount of the reward for the bounty */
  rewardPerUnitAmount: Scalars["Float"]["output"];
  /** The unit of the reward for the bounty */
  rewardUnit: RewardUnits;
  /** The status of the bounty */
  status: Statuses;
  /** The title of the bounty */
  title: Scalars["String"]["output"];
  /**
   * The total amount available for the bounty
   * @deprecated Use rewardPerUnitAmount instead
   */
  totalAvailable: Scalars["Float"]["output"];
  /** The total amount paid out for this bounty in dollars */
  totalPaid: Scalars["Float"]["output"];
  /** The user of who created the bounty */
  user?: Maybe<PublicProfileUser>;
};

/** An object representing a bounty */
export type PublicBountyAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a bounty */
export type PublicBountyFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicBounty. */
export type PublicBountyConnection = {
  __typename?: "PublicBountyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicBountyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicBounty>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicBountyEdge = {
  __typename?: "PublicBountyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicBounty>;
};

/** An object representing a bounty submission */
export type PublicBountySubmission = {
  __typename?: "PublicBountySubmission";
  /** The bounty that this submission belongs to */
  bounty: PublicBounty;
  /** ID of the bounty submission */
  id: Scalars["ID"]["output"];
};

/** A public content reward campaign object */
export type PublicCampaign = {
  __typename?: "PublicCampaign";
  /** Whether to allow Instagram submissions */
  allowInstagram: Scalars["Boolean"]["output"];
  /** Whether to allow TikTok submissions */
  allowTiktok: Scalars["Boolean"]["output"];
  /** Whether to allow X submissions */
  allowX: Scalars["Boolean"]["output"];
  /** Whether to allow YouTube submissions */
  allowYoutube: Scalars["Boolean"]["output"];
  /** The assets associated with the campaign */
  assets: AssetConnection;
  /** The attachments for this campaign */
  attachments: Array<AttachmentInterface>;
  /** The number of hours after which submissions get auto-approved */
  autoApproveSubmissionsInHours?: Maybe<Scalars["Int"]["output"]>;
  /** Which category to assign */
  category: ContentRewardsCategory;
  /** Which content type is accepted */
  contentType: ContentRewardsContentType;
  /** When this campaign was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Which currency should be used for payments */
  currency: Currencies;
  /** The experience this content reward is associated with */
  experience?: Maybe<PublicExperience>;
  /** When this campaign ends */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The file attachments for the campaign */
  fileAttachments: FileAttachmentConnection;
  /** Whether submissions to this campaign require file uploads */
  fileUploadRequired: Scalars["Boolean"]["output"];
  /** The fixed amount that will be paid out per approved submission */
  fixedRewardPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** ID of the campaign */
  id: Scalars["ID"]["output"];
  /** The maximum amount that can be paid out per submission */
  maxPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** The minimum amount owed before a submission is eligible for payouts */
  minPayoutPerSubmission?: Maybe<Scalars["Float"]["output"]>;
  /** URL that must be present in the submitter's social account bio */
  requiredCreatorBioLink?: Maybe<Scalars["String"]["output"]>;
  /** Text patterns that must be present in the submitted post description */
  requiredDescriptionText?: Maybe<Array<Scalars["String"]["output"]>>;
  /** Instagram audio that must be used in the submissions */
  requiredInstagramAudio?: Maybe<Scalars["String"]["output"]>;
  /** TikTok audio that must be used in the submissions */
  requiredTiktokAudio?: Maybe<Scalars["String"]["output"]>;
  /** An array of requirements that the user must complete to collect a reward */
  requirements: Array<Scalars["String"]["output"]>;
  /** The amount that a user should be rewarded per thousand views submitted */
  rewardRatePerThousandViews: Scalars["Float"]["output"];
  /** The status of the campaign */
  status: ContentRewardsCampaignStatus;
  /** The title of this campaign */
  title: Scalars["String"]["output"];
  /** The total amount that will be paid out for this campaign */
  totalBudget: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign in the campaign's currency. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign, normalized to USD. */
  totalPaidInUsd: Scalars["Float"]["output"];
  /** Total number of views approved submissions generated for this campaign */
  totalViewCount: Scalars["Int"]["output"];
};

/** A public content reward campaign object */
export type PublicCampaignAssetsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A public content reward campaign object */
export type PublicCampaignFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicCampaign. */
export type PublicCampaignConnection = {
  __typename?: "PublicCampaignConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicCampaignEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicCampaign>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicCampaignEdge = {
  __typename?: "PublicCampaignEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicCampaign>;
};

/** An object representing a (sanitized) company. */
export type PublicCompany = {
  __typename?: "PublicCompany";
  /** Retrieve a specific (public) access pass for a company. */
  accessPass: PublicAccessPass;
  /** User ids for all of the company's team members. */
  adminUsers: Array<Scalars["String"]["output"]>;
  /** Whether or not the company allows users to remove their Discord account from their profile. */
  allowDiscordRemoval: Scalars["Boolean"]["output"];
  /** The current user's authorized user */
  authorizedUser?: Maybe<AuthorizedUser>;
  /** Whether or not the company auto responds to resolutions. */
  autoRespondToResolutions: Scalars["Boolean"]["output"];
  /** The custom message to send when auto responding to resolution cases */
  autoRespondToResolutionsCustomMessage?: Maybe<Scalars["String"]["output"]>;
  /** The number of days to wait before auto responding to resolution cases */
  autoRespondToResolutionsDays?: Maybe<Scalars["Int"]["output"]>;
  /** The public business address for the company. */
  businessAddress?: Maybe<Scalars["String"]["output"]>;
  /** The URL to the company's business affiliate */
  businessAffiliateUrl: Scalars["UrlString"]["output"];
  /** The lowest price of a product offered by the company, cached daily. */
  cachedPriceToday: Scalars["Float"]["output"];
  /** Whether or not the user can refer this page with a custom affiliate. */
  canUserReferCustomAffiliate: Scalars["Boolean"]["output"];
  /** Given a list of experience IDs, returns the IDs from the list that the user currently has access to (if any). */
  checkExperienceAccess: Array<Scalars["ID"]["output"]>;
  /** When the company was created (signed up) */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the company was created */
  createdAtMs: Scalars["BigInt"]["output"];
  /** The default plan for a company. */
  defaultPlan?: Maybe<PublicPlan>;
  /**
   * A long format description of what the company offers or does.
   * @deprecated No longer supported
   */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not a discord is required in order to purchase a pass from the company. */
  discordRequired: Scalars["Boolean"]["output"];
  /** The company's EULA. */
  eula?: Maybe<AttachmentInterface>;
  /**
   * The EULA PDF for the company.
   * @deprecated Use eula instead
   */
  eulaPdf?: Maybe<Scalars["File"]["output"]>;
  /** An array of features this company has access to */
  features: Array<Scalars["String"]["output"]>;
  /** A Google Analytics ID that the company can use to track page views for their company. */
  googleAnalyticsId?: Maybe<Scalars["String"]["output"]>;
  /** The google tag manager ID. */
  gtmId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /**
   * The header image for the company.
   * @deprecated Use headerImageSrcset instead
   */
  headerImage?: Maybe<Scalars["File"]["output"]>;
  /** The company's banner image (displayed on their product page and cards). */
  headerImageSrcset?: Maybe<ImgSrcset>;
  /** The slug/route of the company on the Whop site. */
  hubRoute?: Maybe<Scalars["String"]["output"]>;
  /** The Hyros pixel ID. */
  hyrosPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The ID (tag) of the company. */
  id: Scalars["ID"]["output"];
  /**
   * The image for the company.
   * @deprecated Use imageSrcset instead
   */
  image?: Maybe<Scalars["File"]["output"]>;
  /** The company's logo. */
  imageSrcset?: Maybe<ImgSrcset>;
  /**
   * The marketplace/branding images for the company.
   * @deprecated not used anymore
   */
  images: Array<Image>;
  /** Given the supplied string, returns whether or not the feature is enabled */
  isFeatureEnabled: Scalars["Boolean"]["output"];
  /** The company's item ordering. */
  itemOrdering: ItemOrdering;
  /** A boolean representing whether or not a company has fully launched. */
  launched: Scalars["Boolean"]["output"];
  /** The number of members in the company. */
  memberCount: Scalars["Int"]["output"];
  /** The members of the company. */
  members: ExtraPublicMemberConnection;
  /** The meta pixel ID. */
  metaPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The integer ID of the company. */
  ogId: Scalars["ID"]["output"];
  /**
   * The URL of an image to use for the company's preview display.
   * @deprecated Use ogImageSrcset instead
   */
  ogImage?: Maybe<Scalars["String"]["output"]>;
  /** The URL of an image to use for the company's preview display. */
  ogImageSrcset?: Maybe<ImgSrcset>;
  /** User id for the company's owner. */
  ownerUserId: Scalars["String"]["output"];
  /** The PayPal merchant ID for the company. */
  paypalMerchantId?: Maybe<Scalars["String"]["output"]>;
  /** The pinterest pixel ID. */
  pinterestPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The company's privacy policy. */
  privacyPolicy?: Maybe<AttachmentInterface>;
  /**
   * The privacy policy PDF for the company.
   * @deprecated Use privacyPolicy instead
   */
  privacyPolicyPdf?: Maybe<Scalars["File"]["output"]>;
  /** Whether or not purchases are disabled for the company. */
  purchasesDisabled?: Maybe<Scalars["Boolean"]["output"]>;
  /** The reddit pixel ID. */
  redditPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** A legal name for the company. */
  registeredCompanyName?: Maybe<Scalars["String"]["output"]>;
  /** A VAT or Tax ID for the company. */
  registeredCompanyNumber?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the company requires the user to agree to the terms of service before checkout */
  requireTermsAgreement: Scalars["Boolean"]["output"];
  /** Whether or not a VAT ID input box is prompted at checkout. */
  requireVatId: Scalars["Boolean"]["output"];
  /** The company's return policy. */
  returnPolicy?: Maybe<AttachmentInterface>;
  /**
   * The return policy PDF for the company.
   * @deprecated Use returnPolicy instead
   */
  returnPolicyPdf?: Maybe<Scalars["File"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewCounts: Array<Scalars["Int"]["output"]>;
  /** Ratings real customers have written for the company. */
  reviews: ReviewConnection;
  /** The average rating across all reviews for the company. */
  reviewsAverage?: Maybe<Scalars["Float"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewsBreakdown?: Maybe<Scalars["JSON"]["output"]>;
  /** The number of reviews for each star rating, 5 to 1. */
  reviewsBreakdownV2?: Maybe<Array<Scalars["Int"]["output"]>>;
  /**
   * The slug/route of the company on the Whop site.
   * @deprecated Use store_route
   */
  route: Scalars["String"]["output"];
  /**
   * A short description of what the company offers or does.
   * @deprecated No longer supported
   */
  shortenedDescription?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the company wants to show reviews via direct to consumer links on their product pages. */
  showReviewsDtc: Scalars["Boolean"]["output"];
  /** Objects representing social media accounts or other external references for the company. */
  socials: Array<Social>;
  /** The default Stripe publishable key for the company. */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /**
   * Whether or not the company has activated team preview
   * @deprecated No longer applies.
   */
  teamPreviewActivated: Scalars["Boolean"]["output"];
  /** The company's terms of service. */
  termsOfService?: Maybe<AttachmentInterface>;
  /** The tiktok pixel ID. */
  tiktokPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The title of the company. */
  title: Scalars["String"]["output"];
  /**
   * The terms of service PDF for the company.
   * @deprecated Use termsOfService instead
   */
  tosPdf?: Maybe<Scalars["File"]["output"]>;
  /** Tracking pixels for this company */
  trackingPixels: TrackingPixelConnection;
  /**
   * The company's Twitter handle.
   * @deprecated Use social links object instead.
   */
  twitter?: Maybe<Scalars["String"]["output"]>;
  /** The Twitter pixel ID. */
  twitterPixelId?: Maybe<Scalars["SanitizedString"]["output"]>;
  /** The time the company was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when the company was last updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** If the company is Whop Verified */
  verified: Scalars["Boolean"]["output"];
  /** All of the access passes that are publicly visible for a company's product page. */
  visibleAccessPasses: PublicAccessPassConnection;
  /** All of the plans that are publicly visible for a company's product page. */
  visiblePlans: PublicPlanConnection;
  /**
   * Whether or not the company has activated Whop 4
   * @deprecated No longer applies.
   */
  whopFourActivated: Scalars["Boolean"]["output"];
};

/** An object representing a (sanitized) company. */
export type PublicCompanyAccessPassArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a (sanitized) company. */
export type PublicCompanyCheckExperienceAccessArgs = {
  experienceIds: Array<Scalars["ID"]["input"]>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyHeaderImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyIsFeatureEnabledArgs = {
  feature: Scalars["String"]["input"];
};

/** An object representing a (sanitized) company. */
export type PublicCompanyItemOrderingArgs = {
  orderType: ItemOrderingOrderTypes;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  afterCursor?: InputMaybe<Scalars["ID"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  beforeCursor?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyOgImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  stars?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyTrackingPixelsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyVisibleAccessPassesArgs = {
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  experienceIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  onlyWhopFourReady?: InputMaybe<Scalars["Boolean"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  quickLinkCode?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a (sanitized) company. */
export type PublicCompanyVisiblePlansArgs = {
  accessPassId: Scalars["String"]["input"];
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** The connection type for PublicCompany. */
export type PublicCompanyConnection = {
  __typename?: "PublicCompanyConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicCompanyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicCompany>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicCompanyEdge = {
  __typename?: "PublicCompanyEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicCompany>;
};

/** Represents a credit made to a user for various activities on the whop platform. */
export type PublicCreditTransaction = {
  __typename?: "PublicCreditTransaction";
  /** The total amount for the credit. */
  amount: Scalars["Float"]["output"];
  /** When the credit was issued. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The type/reason why the credit was issued. */
  creditType?: Maybe<Scalars["String"]["output"]>;
  /** A description of the credit type. */
  creditTypeDescription?: Maybe<Scalars["String"]["output"]>;
  /** The currency of the credit transaction */
  currency: Currencies;
  /** The fee charged on the credit (as a nominal amount). */
  fee: Scalars["Float"]["output"];
  /** The internal ID of the object. */
  id: Scalars["ID"]["output"];
  /** The net amount earned from the credit. */
  netAmount: Scalars["Float"]["output"];
  /** A description of the purpose for the credit. */
  notes?: Maybe<Scalars["String"]["output"]>;
  /** When the credit will be released. */
  releaseAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the resource that this credit is associated with. */
  resourceId?: Maybe<Scalars["ID"]["output"]>;
  /** The type of resource that this credit is associated with. */
  resourceType?: Maybe<Scalars["String"]["output"]>;
  /** The status of the credit. */
  status: CreditTransactionStatuses;
};

/** The connection type for PublicCreditTransaction. */
export type PublicCreditTransactionConnection = {
  __typename?: "PublicCreditTransactionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicCreditTransactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicCreditTransaction>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicCreditTransactionEdge = {
  __typename?: "PublicCreditTransactionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicCreditTransaction>;
};

/** An object representing a discount. */
export type PublicDiscount = {
  __typename?: "PublicDiscount";
  /** The timestamp of when the discount was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp of when the discount was deleted. */
  discardedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The timestamp of when the discount was ended. If null, the discount applies forever. */
  endedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the promo. */
  id: Scalars["ID"]["output"];
  /** The promo code associated with the discount. */
  promoCode: PublicPromoCode;
  /** The timestamp of when the discount was started. */
  startedAt: Scalars["Timestamp"]["output"];
  /** The timestamp of when the discount was updated. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** An object representing an entry in a raffle or waitlist. */
export type PublicEntry = {
  __typename?: "PublicEntry";
  /** When the entry was created. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Responses collected from the user when submitting their entry. */
  customFieldResponses?: Maybe<CustomFieldResponseConnection>;
  /** The internal ID of the entry. */
  id: Scalars["ID"]["output"];
  /** The membership tied to this entry, if there is one. */
  membership?: Maybe<ExtraPublicMembership>;
  /** The plan (waitlist/raffle) the entry if for. */
  plan?: Maybe<PublicPlan>;
  /** Whether or not the entry has been selected. */
  selected?: Maybe<Scalars["Boolean"]["output"]>;
  /** The weight of the entry. */
  weight: Scalars["Int"]["output"];
};

/** An object representing an entry in a raffle or waitlist. */
export type PublicEntryCustomFieldResponsesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicEntry. */
export type PublicEntryConnection = {
  __typename?: "PublicEntryConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicEntryEdge = {
  __typename?: "PublicEntryEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicEntry>;
};

/** An object representing a (sanitized) event. */
export type PublicEvent = {
  __typename?: "PublicEvent";
  /** The access pass that is associated with the membership. */
  accessPass?: Maybe<PublicAccessPass>;
  /** The action that was performed for the event. */
  action: Scalars["String"]["output"];
  /** The category of the event. */
  category: EventCategory;
  /** The datetime the event was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The price of the plan, without the billing period */
  formattedAmount?: Maybe<Scalars["String"]["output"]>;
  /** The price of the plan. */
  formattedPrice?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the plan is free. */
  free: Scalars["Boolean"]["output"];
  /** The ID of the event. */
  id: Scalars["ID"]["output"];
  /** The release method of the plan. */
  releaseMethod?: Maybe<ReleaseMethod>;
  /** The user that is associated with the membership */
  user?: Maybe<PublicProfileUser>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperience = {
  __typename?: "PublicExperience";
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The relevant access pass for the experience */
  accessPass?: Maybe<PublicAccessPass>;
  /** The access passes that are associated with this experience. */
  accessPasses: Array<PublicAccessPass>;
  /** The livestream for the experience */
  activeLivestreamFeed?: Maybe<PublicLivestreamFeed>;
  /** The experience interface for this experience. */
  app: PublicApp;
  /** The chat feed IDs associated with this experience */
  chatFeedIds: Array<Scalars["ID"]["output"]>;
  /** The chat feeds associated with this experience */
  chatFeeds: Array<ChatFeed>;
  /** The company that owns this experience. */
  company: PublicCompany;
  /** Retrieve a specific content rewards campaign */
  contentRewardsCampaign: PublicCampaign;
  /** The content rewards campaigns for this experience */
  contentRewardsCampaigns: PublicCampaignConnection;
  /** The timestamp of when this experience was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The timestamp (in milliseconds since epoch) of when this experience was created. */
  createdAtMs: Scalars["BigInt"]["output"];
  /** A short written description of what is being offered */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp (in milliseconds since epoch) of when the experience was soft deleted. If it's null, the experience is still active. */
  discardedAtMs?: Maybe<Scalars["BigInt"]["output"]>;
  /** The type of product/service being delivered. */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The features enabled for the experience */
  features: Array<Scalars["String"]["output"]>;
  /** The forum feed associated with this experience. */
  forumFeed?: Maybe<ForumFeed>;
  /** Whether the current user has access to this experience */
  hasAccess: Scalars["Boolean"]["output"];
  /** Whether to hide the experience if it is not accessible. */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The unique ID representing this experience */
  id: Scalars["ID"]["output"];
  /** The iframe link for the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface. Deprecated, use logo instead. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The image with fallback for this experience (uses app icon if no image is present). Deprecated, use logo instead. */
  imageWithFallbackSrcset: ImgSrcset;
  /** Whether or not this experience is in dev mode */
  interfaceDevMode: Scalars["Boolean"]["output"];
  /** Whether the current user is an authorized user of the company that owns this experience */
  isAuthorizedUser: Scalars["Boolean"]["output"];
  /** The timestamp of the last activity on this experience */
  lastActivityAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /**
   * The timestamp of the last activity on this experience
   * @deprecated Use last_activity_at instead
   */
  lastFeedContentItemAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The access passes that can be linked to the experience */
  linkableAccessPasses: PublicAccessPassConnection;
  /** The livestream feeds associated with this experience */
  livestreamFeeds: LivestreamFeedConnection;
  /** The logo for the experience. */
  logo?: Maybe<AttachmentInterface>;
  /** The marketplace access pass for the experience */
  marketplaceAccessPass?: Maybe<PublicAccessPass>;
  /** The written name of the description. */
  name: Scalars["String"]["output"];
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed: Scalars["Boolean"]["output"];
  /** Whether or not experience content is shown in the explore page */
  showExploreContent: Scalars["Boolean"]["output"];
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The target link to request */
  targetLink?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the experience was updated */
  updatedAtMs: Scalars["BigInt"]["output"];
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<PublicPlan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
  /** The access pass for the experience */
  userDefaultAccessPass?: Maybe<PublicAccessPass>;
  /** The timestamp of when the experience went live */
  wentLiveAt?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceAccessPassArgs = {
  direction: Direction;
  order: AccessPassOrder;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceContentRewardsCampaignArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceContentRewardsCampaignsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ContentRewardsPublicCampaignsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceImageWithFallbackSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceLinkableAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceLivestreamFeedsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing an experience belonging to a company. */
export type PublicExperienceTargetLinkArgs = {
  appViewType: AppViewTypes;
  mode: ExperienceLinkModes;
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** The connection type for PublicExperience. */
export type PublicExperienceConnection = {
  __typename?: "PublicExperienceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicExperienceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicExperience>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicExperienceEdge = {
  __typename?: "PublicExperienceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicExperience>;
};

export type PublicExperienceInterface = {
  /**
   * The access level of the experience (always private)
   * @deprecated This is always private
   */
  accessLevel: ExperienceAccessLevels;
  /** The chat feed IDs associated with this experience */
  chatFeedIds: Array<Scalars["ID"]["output"]>;
  /** A written description of what the experience offers */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The type of the experience */
  experienceType: ExperienceTypes;
  /** The timestamp of when the experience will expire. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The features enabled for the experience */
  features: Array<Scalars["String"]["output"]>;
  /** Whether to hide the experience if it is not accessible */
  hideIfNotAccessible: Scalars["Boolean"]["output"];
  /** The ID of the experience */
  id: Scalars["ID"]["output"];
  /** The iframe link for the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience */
  image?: Maybe<Scalars["String"]["output"]>;
  /** The image for the experience interface */
  imageSrcset?: Maybe<ImgSrcset>;
  /** Whether the experience is accessible (attached to at least one product) */
  isAccessible: Scalars["Boolean"]["output"];
  /** Whether or not the experience has been claimed given the membership in the current context. If null, there is no membership in the context. */
  isClaimed?: Maybe<Scalars["Boolean"]["output"]>;
  /** The name of the experience */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The app */
  publicApp?: Maybe<PublicApp>;
  /** The style of the experience */
  style: ExperienceStyle;
  /** Tag line describing the experience type */
  tagLine: Scalars["String"]["output"];
  /** The target link to request */
  targetLink?: Maybe<Scalars["String"]["output"]>;
  /** The upsell plan for the experience, if any. */
  upsellPlan?: Maybe<PublicPlan>;
  /** The upsell type for the experience, if any. */
  upsellType?: Maybe<UpsellTypes>;
};

export type PublicExperienceInterfaceImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AppImageStyles>;
};

export type PublicExperienceInterfaceTargetLinkArgs = {
  appViewType: AppViewTypes;
  mode: ExperienceLinkModes;
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** The connection type for PublicExperienceInterface. */
export type PublicExperienceInterfaceConnection = {
  __typename?: "PublicExperienceInterfaceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicExperienceInterfaceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicExperienceInterface>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicExperienceInterfaceEdge = {
  __typename?: "PublicExperienceInterfaceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicExperienceInterface>;
};

/** An object representing a wide scale sale that was made. */
export type PublicFlashSale = {
  __typename?: "PublicFlashSale";
  /** The duration of the flash sale. */
  duration: FlashSaleDurations;
  /** The date and time the flash sale ends. */
  endsAt: Scalars["Timestamp"]["output"];
  /** The unique identifier of the flash sale. */
  id: Scalars["ID"]["output"];
  /** The name of the flash sale. */
  name: Scalars["String"]["output"];
  /** Whether the flash sale is only for new users. */
  newUsersOnly: Scalars["Boolean"]["output"];
  /** Whether the flash sale is limited to one per customer. */
  onePerCustomer: Scalars["Boolean"]["output"];
  /** The percentage off the flash sale offers. */
  percentOff: Scalars["Float"]["output"];
  /** The date and time the flash sale starts. */
  startsAt: Scalars["Timestamp"]["output"];
  /** The status of the flash sale. */
  status: FlashSaleStatuses;
  /** The amount of stock available for the flash sale. */
  stock: Scalars["Int"]["output"];
  /** Whether the flash sale has unlimited stock. */
  unlimitedStock: Scalars["Boolean"]["output"];
};

/** Represents a LedgerAccount, allowed to be viewed by anyone. */
export type PublicLedgerAccount = {
  __typename?: "PublicLedgerAccount";
  /** The timestamp of when the ledger account was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the LedgerAccount. */
  id: Scalars["ID"]["output"];
  /** The logo for the account. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The owner of the ledger account. */
  resourceOwner: PublicLedgerAccountOwner;
  /** The title of the ledger account (to display on checkout). */
  title: Scalars["String"]["output"];
  /** The timestamp of when the ledger account was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** Represents a LedgerAccount, allowed to be viewed by anyone. */
export type PublicLedgerAccountImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** Either a User or a Company */
export type PublicLedgerAccountOwner = PublicCompany | PublicProfileUser;

/** An object representing a (sanitized) line item. */
export type PublicLineItem = {
  __typename?: "PublicLineItem";
  /** An array of the accepted payment methods for the line item. */
  acceptedPaymentMethods: Array<AcceptedPaymentMethods>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity: Scalars["Boolean"]["output"];
  /** The amount of the line item. */
  amount: Scalars["Float"]["output"];
  /** The amount of the line item in USD. */
  amountUsd: Scalars["Float"]["output"];
  /** The app that the line item was created by / for. */
  app?: Maybe<PublicApp>;
  /** The respective currency identifier for the plan. */
  baseCurrency: Currencies;
  /** Whether or not the line item requires a billing setup. */
  billingSetupRequired: Scalars["Boolean"]["output"];
  /** The buyer fee percentage to apply to the transaction, if any. */
  buyerFeePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The payment processors that support the buyer fee, if any. */
  buyerFeeSupportedProcessors: Array<PaymentProcessor>;
  /** Whether or not the line item collects tax. */
  collectTax: Scalars["Boolean"]["output"];
  /** The company for the line item. */
  company?: Maybe<PublicCompany>;
  /** The description of the line item. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the line item expires, if applicable. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The internal ID of the line item. */
  id: Scalars["ID"]["output"];
  /** The ledger account for the line item. */
  ledgerAccount?: Maybe<PublicLedgerAccount>;
  /** Whether or not the company is the merchant of record. Uses the line item's current stripe account. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** The name of the line item. */
  name: Scalars["String"]["output"];
  /** Used for the Stripe Payment element. If present, pass this value as the on_behalf_of parameter. */
  onBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Payment Request Button. If present, pass this value as the on_behalf_of parameter. */
  paymentRequestOnBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** The capabilities of the stripe account. */
  paymentsCapabilities: Array<Scalars["String"]["output"]>;
  /** Optional URL to redirect to after successful checkout. */
  redirectUrl?: Maybe<Scalars["String"]["output"]>;
  /** The setup future usage for the line item, if applicable. */
  setupFutureUsage?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the promo code input should be shown on checkout. */
  showPromoCodeInput: Scalars["Boolean"]["output"];
  /** The countries to skip tax quoting for. */
  skipTaxQuotingCountries: Array<Scalars["String"]["output"]>;
  /** The stripe account id to use for setting up this line item's stripe.js */
  stripeAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe payment method configuration id to use for setting up the stripe.js elements */
  stripePaymentMethodConfigurationId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe public key to use for setting up this line item's stripe.js */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the line item. */
  taxType: TaxTypes;
  /** The terms and conditions for the line item. */
  termsAndConditions: Scalars["String"]["output"];
  /** Whether or not to use the Basis Theory element during checkout. */
  useBasisTheory: Scalars["Boolean"]["output"];
};

/** Represents a public livestream feed */
export type PublicLivestreamFeed = BaseEntityInterface & {
  __typename?: "PublicLivestreamFeed";
  /** The most relevant access pass this livestream is in which the user has access to */
  accessPasses: PublicAccessPassConnection;
  /** The experiences for this livestream which the user has access to */
  accessibleExperiences: AccessibleExperienceConnection;
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The description of the livestream */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The time the livestream ended at */
  endedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The type of the card */
  entityType: EntityTypes;
  /**
   * The ID of the livestream experience (used for some old client that is still around)
   * @deprecated Use experiences instead
   */
  experienceId: Scalars["ID"]["output"];
  /** The experiences for this livestream. There can be max 25. */
  experiences: Array<PublicExperience>;
  /** The user who is hosting this livestream */
  host?: Maybe<PublicProfileUser>;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The name of the livestream room */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the livestream started at */
  startedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The link to the thumbnail */
  thumbnailUrl?: Maybe<Scalars["String"]["output"]>;
  /** The title of the livestream */
  title: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The webhooks for the feed */
  webhooks: FeedWebhookConnection;
};

/** Represents a public livestream feed */
export type PublicLivestreamFeedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  direction: Direction;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order: AccessPassOrder;
};

/** Represents a public livestream feed */
export type PublicLivestreamFeedAccessibleExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Represents a public livestream feed */
export type PublicLivestreamFeedWebhooksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a connection between a creator and a user/company_buyer. This type should only be made visible to the user/company_buyer who is a part of the connection. */
export type PublicMember = {
  __typename?: "PublicMember";
  /** Whether the member can leave the company */
  canLeaveAutomatically: Scalars["Boolean"]["output"];
  /** The company that the member is a part of */
  company: PublicCompany;
  /** The ID of the member */
  id: Scalars["ID"]["output"];
  /** When the member joined the company */
  joinedAt: Scalars["Timestamp"]["output"];
  /** The status of the member */
  status: MemberStatuses;
  /** Whether this whop shows on the profile page */
  visibilityOnProfile: ProfileVisibilities;
};

/** The connection type for PublicMember. */
export type PublicMemberConnection = {
  __typename?: "PublicMemberConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicMemberEdge = {
  __typename?: "PublicMemberEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicMember>;
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembership = {
  __typename?: "PublicMembership";
  /** The access pass tied to this membership. */
  accessPass: PublicAccessPass;
  /** The currently active discount on the membership, if any. */
  activeDiscount?: Maybe<PublicDiscount>;
  /** Whether or not all of the experiences on the membership are considered claimed. */
  allExperiencesClaimed: Scalars["Boolean"]["output"];
  /** Whether or not a promo code can attempt to be applied to the membership. */
  canApplyPromoCode: Scalars["Boolean"]["output"];
  /** Whether or not the membership can retry payment. */
  canRetryPayment: Scalars["Boolean"]["output"];
  /** Marks whether the membership is scheduled to cancel at the renewal period end */
  cancelAtPeriodEnd: Scalars["Boolean"]["output"];
  /** Details about the application of a cancelation discount. */
  cancelationRecovery?: Maybe<CancelationDiscount>;
  /** The company that owns the experience */
  company: PublicCompany;
  /** The datetime the membership was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The Discord tied to this membership. */
  discord?: Maybe<DiscordAccount>;
  /** An experience tied to this membership. */
  experience: PublicExperienceInterface;
  /** The experiences tied to this membership. */
  experiences: PublicExperienceInterfaceConnection;
  /** The datetime the membership expires. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The formatted renewal price. */
  formattedRenewalPrice?: Maybe<Scalars["String"]["output"]>;
  /** The formatted amount of the upcoming renewal payment for this membership, if any. */
  formattedUpcomingRenewalAmount?: Maybe<Scalars["String"]["output"]>;
  /** Marks whether the membership was free. */
  free: Scalars["Boolean"]["output"];
  /** The membership ID */
  id: Scalars["ID"]["output"];
  /** The initial price paid formatted in the respective currency. */
  initialPricePaid: Scalars["String"]["output"];
  /** The license key tied to this membership. Only shown if any software experiences tied */
  licenseKey?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the membership was purchased on the marketplace. */
  marketplace: Scalars["Boolean"]["output"];
  /** The most recent action on the membership. */
  mostRecentAction?: Maybe<MemberSubtext>;
  /** The URL to the past due payment invoice. */
  pastDuePaymentInvoiceUrl?: Maybe<Scalars["UrlString"]["output"]>;
  /** The company or method for how the membership's payments are processed. */
  paymentProcessor: MembershipPaymentProcessor;
  /** The plan tied to this membership. */
  plan: PublicPlan;
  /** Promo code for the membership. */
  promoCode?: Maybe<PublicPromoCode>;
  /** The receipts tied to this membership. */
  receipts: PublicReceiptConnection;
  /** Whether or not the membership is now renewable */
  renewableNow: Scalars["Boolean"]["output"];
  /** The datetime the membership renewal period ends. */
  renewalPeriodEnd?: Maybe<Scalars["Timestamp"]["output"]>;
  /** A resolution tied to this membership. */
  resolution: PublicResolution;
  /** The resolutions tied to this membership. */
  resolutions: PublicResolutionConnection;
  /** The number of payments made on the split pay subscription. */
  splitPayCurrentPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The status of the membership. */
  status: MembershipStatus;
  /** The number of days remaining in the trial period. */
  trialDaysRemaining?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The plans that can be upgraded to from this membership.
   * @deprecated No longer available.
   */
  upgradeablePlans: PublicPlanConnection;
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipExperienceArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  experienceType?: InputMaybe<ExperienceTypes>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipReceiptsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  eligibleForResolution?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipResolutionArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ResolutionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) membership for a plan. */
export type PublicMembershipUpgradeablePlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicMembership. */
export type PublicMembershipConnection = {
  __typename?: "PublicMembershipConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicMembership>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicMembershipEdge = {
  __typename?: "PublicMembershipEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicMembership>;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutation = {
  __typename?: "PublicMutation";
  /** Adds a user to a company as an authorized user with a given role */
  addAuthorizedUser?: Maybe<AddUserActions>;
  /** Add a company's Experience to one of their Access Passes */
  addExperienceToAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Adds a new bank account to a connected account */
  addExternalAccount?: Maybe<StripeExternalAccount>;
  /** Adds a new FCM token for a user */
  addFcmToken?: Maybe<FcmToken>;
  /** Adds a new bank account to a connected account managed by a ledger account */
  addLedgerExternalAccount?: Maybe<Scalars["String"]["output"]>;
  /** Add oauth provider details */
  addOauthEmail: Scalars["String"]["output"];
  /** Whitelists a redirect URI for the OAuth application */
  addRedirectUri?: Maybe<Scalars["Boolean"]["output"]>;
  /** Applies a promo code to an existing membership */
  applyPromoCode?: Maybe<Scalars["String"]["output"]>;
  /** Applies a promo code to a membership owned by a company */
  applyPromoCodeToMembership?: Maybe<Scalars["String"]["output"]>;
  /** Applies a promo code to a membership owned by a user */
  applyPromoCodeToMyMembership?: Maybe<Scalars["String"]["output"]>;
  /** Approves all entries in a raffle or waitlist */
  approveAllEntries?: Maybe<Scalars["Boolean"]["output"]>;
  /** Approves all entries in a raffle or waitlist */
  approveAllWaitlistEntries?: Maybe<Scalars["Boolean"]["output"]>;
  /** Approve a content rewards submission */
  approveContentRewardsSubmission?: Maybe<Scalars["Boolean"]["output"]>;
  /** Approves a specific entry by queuing a background worker */
  approveEntry?: Maybe<Scalars["String"]["output"]>;
  /** Approve a flagged content rewards submission */
  approveFlaggedContentRewardsSubmission?: Maybe<Scalars["Boolean"]["output"]>;
  /** Archives an existing Affiliate */
  archiveAffiliate?: Maybe<Scalars["Boolean"]["output"]>;
  /** Archives a content rewards campaign */
  archiveContentRewardsCampaign?: Maybe<Scalars["Boolean"]["output"]>;
  /** Assigns an account manager to a company */
  assignAccountManager?: Maybe<Scalars["Boolean"]["output"]>;
  /** Attaches an affiliate to a membership */
  attachAffiliate?: Maybe<Scalars["String"]["output"]>;
  /** Generates data for the authenticator */
  authenticatorData?: Maybe<AuthenticatorData>;
  /** Auto joins dormant users to a company */
  autoJoinDormantUsers?: Maybe<Scalars["String"]["output"]>;
  /** Bans a user from a company */
  banUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Blocks another user */
  blockUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Calculates the tax for a given amount */
  calculateTax?: Maybe<Scalars["String"]["output"]>;
  /** Cancels a pending abuse report */
  cancelAbuseReport?: Maybe<Scalars["Boolean"]["output"]>;
  /** Changes an AccessPass' marketplace status */
  changeAccessPassStatus?: Maybe<Scalars["Boolean"]["output"]>;
  /** Generates a Stripe billing portal URL where the user can change their payment info */
  changeCardMyMembership?: Maybe<Scalars["String"]["output"]>;
  /** Sends the user an email which contains a link to change their account email */
  changeEmail?: Maybe<Scalars["Boolean"]["output"]>;
  /** Checks the authenticator code provided by a user */
  checkAuthenticatorCode?: Maybe<Scalars["Boolean"]["output"]>;
  /** Clones an access pass */
  cloneAccessPass?: Maybe<Scalars["String"]["output"]>;
  /** Confirms an Apple transaction */
  confirmAppleTransaction?: Maybe<Scalars["String"]["output"]>;
  /** Confirms a paypal oauth */
  confirmPaypalOauth?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new Access Pass */
  createAccessPass?: Maybe<AccessPass>;
  /** Creates an abuse report for an access pass */
  createAccessPassAbuseReport?: Maybe<AccessPassReport>;
  /** Creates a new Access Pass Affiliate */
  createAccessPassAffiliate?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a access pass's FAQ */
  createAccessPassFaq?: Maybe<FaqObject>;
  /** Creates a social link for an Access Pass */
  createAccessPassSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Create a membership for an access pass */
  createAdminMembership?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a new Affiliate */
  createAffiliate?: Maybe<Affiliate>;
  /** Create an AI video */
  createAiVideo?: Maybe<CreateVideo>;
  /** Creates an API key for a company */
  createApiKeyV2?: Maybe<PrivateApiKey>;
  /** Creates a new app experience */
  createAppExperience?: Maybe<Experience>;
  /**
   * Adds a user to a company as an authorized user with a given role
   * @deprecated Use AddAuthorizedUser instead
   */
  createAuthorizedUser?: Maybe<AuthorizedUser>;
  /** Creates a bounty */
  createBounty?: Maybe<PublicBounty>;
  /** Creates a new checkout session */
  createCheckoutSession?: Maybe<CheckoutSession>;
  /** Creates a new Coinbase account for a company */
  createCoinbaseAccount?: Maybe<CoinbaseAccount>;
  /** Create a company-wide muted user */
  createCompanyMutedUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Create a content rewards campaign */
  createContentRewardsCampaign?: Maybe<Campaign>;
  /** Create a content rewards submission */
  createContentRewardsSubmission?: Maybe<PublicSubmission>;
  /** Creates a crypto  wallet */
  createCryptoWallet?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a nonce for a crypto wallet */
  createCryptoWalletNonce?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new direct message feed */
  createDirectMessage?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new discover interaction */
  createDiscoverInteraction?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a DM */
  createDmChannel?: Maybe<CreateDmChannelPayload>;
  /** Creates a webhook for a feed */
  createFeedWebhook?: Maybe<FeedWebhook>;
  /** Creates a forum post */
  createForumPost?: Maybe<CreateForumPostPayload>;
  /** Create an ingress for a livestream */
  createIngress?: Maybe<LivestreamIngress>;
  /** Creates a new lead */
  createLead?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a new connected account for a ledger account */
  createLedgerConnectedAccount?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new line item */
  createLineItem?: Maybe<PublicLineItem>;
  /** Creates a new livekit token for a given feed */
  createLivekitToken?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new member */
  createMember?: Maybe<PublicMember>;
  /** Allows a Company to create a note about a User with a Membership */
  createMemberNote?: Maybe<MemberNote>;
  /** Creates a new payment method under a plan */
  createPaymentMethod?: Maybe<Scalars["String"]["output"]>;
  /** Creates a Stripe Personal account for a company */
  createPersonalAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a new Plan */
  createPlan?: Maybe<Plan>;
  /** Creates a new Product Highlight */
  createProductHighlight?: Maybe<ProductHighlight>;
  /** Creates a new promo code for given Plans */
  createPromoCode?: Maybe<PromoCode>;
  /** Creates a new Quick Link for a Plan */
  createQuickLink?: Maybe<Plan>;
  /** Creates a new review for a Company */
  createReview?: Maybe<Review>;
  /** Creates a new report for a review */
  createReviewReport?: Maybe<ReviewReportV2>;
  /** Generates a setup token to authorized a payment method with Whop. */
  createSetupToken?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new tracking link */
  createTrackingLink?: Maybe<TrackingLink>;
  /** Creates an unverified user social link */
  createUnverifiedUserSocialLink?: Maybe<UserSocialLinks>;
  /** Creates a new ledger account for a user */
  createUserLedgerAccount?: Maybe<LedgerAccount>;
  /** Creates a new abuse report for a user */
  createUserReport?: Maybe<UserReport>;
  /**
   * Creates a user social link
   * @deprecated Use CreateUnverifiedUserSocialLink instead
   */
  createUserSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Generates a code to be used for Telegram verification */
  createUserTelegramVerificationCode?: Maybe<Scalars["String"]["output"]>;
  /** Creates a new webhook */
  createWebhook?: Maybe<Webhook>;
  /** Creates a withdrawal request for a user */
  createWithdrawal?: Maybe<PublicWithdrawal>;
  /** Create a resolution for a user. */
  customerCreateResolution?: Maybe<PublicResolution>;
  /** Respond to a resolution for a user. */
  customerRespondResolution?: Maybe<PublicResolution>;
  /** Deletes an existing Access Pass */
  deleteAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing FAQ for a access pass. */
  deleteAccessPassFaq?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Deletes an existing image for an access pass.
   * @deprecated Use updateAccessPassAttachments instead
   */
  deleteAccessPassImage?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a social link for an Access Pass */
  deleteAccessPassSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing Affiliate */
  deleteAffiliate?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing custom affiliate for a Plan */
  deleteAffiliateForPlan?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing authorized user */
  deleteAuthorizedUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing authorized user invite */
  deleteAuthorizedUserInvite?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing Coinbase account */
  deleteCoinbaseAccount?: Maybe<Scalars["String"]["output"]>;
  /** Deletes an existing company */
  deleteCompany?: Maybe<Scalars["String"]["output"]>;
  /** Deletes a company-wide muted user */
  deleteCompanyMutedUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a crypto wallet linked to a user */
  deleteCryptoWallet?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing Experience */
  deleteExperience?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a feed webhook */
  deleteFeedWebhook?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a connected account for a ledger account */
  deleteLedgerConnectedAccount?: Maybe<Scalars["String"]["output"]>;
  /** Delete a livestream recording */
  deleteLivestreamRecording?: Maybe<Scalars["Boolean"]["output"]>;
  /** Allows a Company to create a note about a User with a Membership */
  deleteMemberNote?: Maybe<Scalars["Boolean"]["output"]>;
  /** Allows a user to delete their account / personal data from Whop */
  deleteMyAccount?: Maybe<Scalars["ID"]["output"]>;
  /** Deletes an existing payment method under a plan */
  deletePaymentMethod?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing payment token */
  deletePaymentToken?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing PayPal account */
  deletePaypalAccount?: Maybe<Scalars["String"]["output"]>;
  /** Deletes an existing plan */
  deletePlan?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing product highlight */
  deleteProductHighlight?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing promo code */
  deletePromoCode?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes an existing Company review */
  deleteReview?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a stripe account in a background job */
  deleteStripeAccountV2?: Maybe<Scalars["String"]["output"]>;
  /** Deletes an existing tracking link */
  deleteTrackingLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes all messages from a user in a chat */
  deleteUserChatMessages?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a user social link */
  deleteUserSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Deletes a webhook */
  deleteWebhook?: Maybe<Scalars["Boolean"]["output"]>;
  /** Disables two factor authentication for the user */
  disableTwoFactor?: Maybe<Scalars["Boolean"]["output"]>;
  /** Disconnects a wallet from a user */
  disconnectWallet?: Maybe<Scalars["String"]["output"]>;
  /** Enables cancelation discounts for a company */
  enableCancelationDiscounts?: Maybe<Scalars["Boolean"]["output"]>;
  /** Ends a livestream for a given feed */
  endLivestream?: Maybe<Scalars["Boolean"]["output"]>;
  /** Exports a table from the creator dashboard */
  exportCreatorDashboardTable: Scalars["String"]["output"];
  /** Fetch AI video characters */
  fetchAiVideoCharacters?: Maybe<FetchVideoCharacters>;
  /** Fetches the status of a job */
  fetchJobStatus?: Maybe<JobStatus>;
  /** Manually fulfills a TradingView experience */
  fulfillTradingViewExperience?: Maybe<Scalars["String"]["output"]>;
  /** Generates a session to access the connected account */
  generateConnectedAccountSession?: Maybe<ConnectedAccountSession>;
  /** Creates a new ledger account for a company */
  generateLedgerAccountManageUrl?: Maybe<Scalars["String"]["output"]>;
  /** Returns an oauth code that can be used by the mobile app to authenticate webviews */
  generateMobileOauthCode?: Maybe<Scalars["String"]["output"]>;
  /** Generates a Mux asset upload URL */
  generateMuxUploadUrl?: Maybe<GenerateMuxUploadUrlOutput>;
  /** Generates a paypal oauth url */
  generatePaypalOauthUrl?: Maybe<Scalars["String"]["output"]>;
  /** Generates a URL to the Stripe dashboard or the Stripe Express dashboard, if available */
  generateStripeManageUrl?: Maybe<Scalars["String"]["output"]>;
  /** Creates a Membership transfer link */
  generateTransferLink?: Maybe<Scalars["String"]["output"]>;
  /** Generates a value with AI */
  generateValueWithAi?: Maybe<Scalars["String"]["output"]>;
  /** Generates a JWT for a websocket connection */
  generateWebsocketJwt?: Maybe<Scalars["String"]["output"]>;
  /** Go live on Whop to multiple access passes. Creates a livestream feed and attaches them to an experience for each access pass. The experience will be created if it doesn't exist. */
  goLive?: Maybe<GoLivePayload>;
  /** Sends an invite to an access pass to another user via DM */
  inviteUserToAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Checks out and joins a free access pass */
  joinFreeAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Forces a user to leave a Whop */
  kickFromAWhop?: Maybe<Scalars["String"]["output"]>;
  /** Leaves a Whop */
  leaveAWhop?: Maybe<Scalars["String"]["output"]>;
  /** Updates the current user's participant permissions to stop being a speaker */
  livestreamLeaveStage?: Maybe<Scalars["Boolean"]["output"]>;
  /** Log out from a Whop account */
  logout?: Maybe<Scalars["Boolean"]["output"]>;
  /** Log out a Whop account from all devices */
  logoutAllDevices?: Maybe<Scalars["Boolean"]["output"]>;
  /** Manually charges a user */
  manualCharge?: Maybe<Scalars["String"]["output"]>;
  /** Marks a user's notifications for an experience as read */
  markExperienceRead?: Maybe<Scalars["Boolean"]["output"]>;
  /** Marks posts viewed */
  markFeedPostsAsViewed?: Maybe<Scalars["Boolean"]["output"]>;
  /** Marks posts as viewed */
  markPostsAsViewed?: Maybe<Scalars["Boolean"]["output"]>;
  /** Marks a Coinbase account as having a settlement address */
  markSetSettlementAddress?: Maybe<Scalars["Boolean"]["output"]>;
  /** Analyze a file attachment */
  mediaAnalyzeAttachment?: Maybe<Scalars["Boolean"]["output"]>;
  /** Directly upload a file to the platform */
  mediaDirectUpload?: Maybe<DirectUpload>;
  /** Respond to a resolution for a merchant. */
  merchantRespondResolution?: Maybe<PublicResolution>;
  /** Mute a user within a livestream */
  muteParticipantMicrophone?: Maybe<Scalars["Boolean"]["output"]>;
  /** Poll the status of an AI video */
  pollAiVideo?: Maybe<PollVideoResponse>;
  /** Creates a presigned upload URL for a file */
  presignedUpload?: Maybe<Scalars["String"]["output"]>;
  /** Processes a checkout session */
  processCheckout?: Maybe<Scalars["String"]["output"]>;
  /** Processes entities */
  processEntities?: Maybe<ProcessEntitiesPayload>;
  /** Processes an entry into a raffle/waitlist */
  processEntry?: Maybe<Scalars["String"]["output"]>;
  /** Processes forum entities */
  processForumEntities?: Maybe<ProcessForumEntitiesPayload>;
  /**
   * Rates an access pass (like or dislike)
   * @deprecated Use create_discover_interaction instead
   */
  rateAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Reassigns ownership of a company to another user */
  reassignOwnership?: Maybe<Scalars["Boolean"]["output"]>;
  /** Refunds a receipt */
  refundReceipt?: Maybe<Receipt>;
  /** Registers a new company */
  registerCompany?: Maybe<Scalars["String"]["output"]>;
  /** Reject a content rewards submission */
  rejectContentRewardsSubmission?: Maybe<Scalars["Boolean"]["output"]>;
  /** Rejects a creator milestone */
  rejectCreatorMilestone: Scalars["Boolean"]["output"];
  /** Removes an entry from a raffle/waitlist */
  removeEntry?: Maybe<Scalars["Boolean"]["output"]>;
  /** Remove a company's Experience from one of their Access Passes */
  removeExperienceFromAccessPass?: Maybe<Scalars["Boolean"]["output"]>;
  /** Removes an FCM token for a user */
  removeFcmToken?: Maybe<Scalars["Boolean"]["output"]>;
  /** Removes a user's social account */
  removeMyAccount?: Maybe<Scalars["String"]["output"]>;
  /** Removes a phone number from a user */
  removePhoneNumber?: Maybe<Scalars["Boolean"]["output"]>;
  /** Remove a redirect URI that is currently whitelisted for OAuth */
  removeRedirectUri?: Maybe<Scalars["Boolean"]["output"]>;
  /** Requests a withdrawal from a ledger account */
  requestLedgerWithdrawal?: Maybe<PublicWithdrawal>;
  /** Toggle your stand request for a livestream */
  requestToStand?: Maybe<Scalars["Boolean"]["output"]>;
  /** Resolves a coinbase payment */
  resolveCoinbasePayment?: Maybe<Scalars["Boolean"]["output"]>;
  /** Retrieves the result of a challenge */
  retrieveChallengeResult?: Maybe<PaymentTokenAuthentication>;
  /** Retries past due payments for the current company */
  retryPastDuePayments?: Maybe<Scalars["Boolean"]["output"]>;
  /** Retry the current payment that is past_due for a membership a user has purchased. */
  retryPaymentMyMembership?: Maybe<Scalars["Boolean"]["output"]>;
  /** Retries a payout */
  retryPayout?: Maybe<Scalars["String"]["output"]>;
  /**
   * Revoke API keys
   * @deprecated Use RevokeApiKeyV2
   */
  revokeApiKey?: Maybe<Scalars["Boolean"]["output"]>;
  /** Revoke an API key for a company */
  revokeApiKeyV2?: Maybe<Scalars["Boolean"]["output"]>;
  /** Revoke a user's OAuth token */
  revokeOauthToken?: Maybe<Scalars["Boolean"]["output"]>;
  /** Sends a message to a user */
  sendMessage?: Maybe<Scalars["String"]["output"]>;
  /** This is what we send when they have no PM setup */
  sendNoPaymentEmail?: Maybe<Scalars["Boolean"]["output"]>;
  /** Sends a phone code to a user */
  sendPhoneCode?: Maybe<Scalars["Boolean"]["output"]>;
  /** For a given withdrawal, will email a PDF invoice for it to the current user. */
  sendWithdrawalPdf?: Maybe<Scalars["String"]["output"]>;
  /** Set a notification preference for a user */
  setNotificationPreference?: Maybe<Scalars["Boolean"]["output"]>;
  /** Resets an API key for a company */
  shuffleApiKey?: Maybe<PrivateApiKey>;
  /** Shuffles a company's OAuth client secret */
  shuffleOauthSecret?: Maybe<OauthApplication>;
  /** Starts email verification for a user */
  startEmailVerification?: Maybe<Scalars["Boolean"]["output"]>;
  /** Complete Stripe OAuth */
  stripeOauthV2?: Maybe<Scalars["String"]["output"]>;
  /** Submits evidence for all Stripe disputes */
  submitAllPaymentDisputes?: Maybe<Scalars["Boolean"]["output"]>;
  /** Submits evidence for a Stripe dispute */
  submitPaymentDispute?: Maybe<Scalars["String"]["output"]>;
  /** This is for terminating YOUR app memberships that you bought.  The company who purchased it must be signed in. */
  terminateMyMembership?: Maybe<PublicMembership>;
  /** Tests a webhook */
  testWebhookV2?: Maybe<WebhookTestResult>;
  /** Either cancels, uncancels, or terminates a user's membership. */
  toggleCancelMyMembership?: Maybe<Scalars["String"]["output"]>;
  /** Transfers funds between ledger accounts */
  transferFunds?: Maybe<Scalars["Boolean"]["output"]>;
  /** Creates a transfer link for a user for their membership. */
  transferLinkMyMembership?: Maybe<Scalars["String"]["output"]>;
  /** Unarchives an existing Affiliate */
  unarchiveAffiliate?: Maybe<Scalars["Boolean"]["output"]>;
  /** Unbans a user from a company */
  unbanUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Unblocks another user */
  unblockUser?: Maybe<Scalars["Boolean"]["output"]>;
  /** Unlinks a Twitter account from a user */
  unlinkTwitterAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing Access Pass */
  updateAccessPass?: Maybe<AccessPass>;
  /** Updates an existing Access Pass Affiliate */
  updateAccessPassAffiliate?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the attachments for an access pass */
  updateAccessPassAttachments?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a access pass's FAQ */
  updateAccessPassFaq?: Maybe<FaqObject>;
  /** Updates a Access Pass's FAQ order */
  updateAccessPassFaqOrder?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Updates the files for an access pass
   * @deprecated Use updateAccessPassAttachments instead
   */
  updateAccessPassFileAttachments?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Allows a company to update the order in which images should be displayed or delete images.
   * @deprecated Use updateAccessPassAttachments instead
   */
  updateAccessPassImageOrder?: Maybe<Scalars["Boolean"]["output"]>;
  /**
   * Updates the images for an access pass
   * @deprecated Use updateAccessPassAttachments instead
   */
  updateAccessPassImages?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the order of a company's access pass items */
  updateAccessPassItemOrdering?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the marketplace categories for a company */
  updateAccessPassMarketplaceCategories?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the order of access pass members */
  updateAccessPassMemberOrder?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the pinned experiences for an access pass */
  updateAccessPassPinnedExperiences?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a social link for an Access Pass */
  updateAccessPassSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing Affiliate */
  updateAffiliate?: Maybe<Affiliate>;
  /** Updates an API key for a company */
  updateApiKey?: Maybe<ApiKeyV2>;
  /** Creates an app */
  updateApp?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing app view */
  updateAppView?: Maybe<AppView>;
  /** Changes the role of an existing authorized user */
  updateAuthorizedUser?: Maybe<AuthorizedUser>;
  /** Updates the auto respond to resolutions settings for a company */
  updateAutoRespondToResolutions?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an automated messages config */
  updateAutomatedMessagesConfig?: Maybe<AutomatedMessagesConfig>;
  /** Updates a user's billing address for their Stripe Customer profile */
  updateBillingAddress?: Maybe<Scalars["String"]["output"]>;
  /** Updates an existing Coinbase account for a company */
  updateCoinbaseAccount?: Maybe<Scalars["String"]["output"]>;
  /** Updates a company's billing information */
  updateCompanyBilling?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a company's checkout settings */
  updateCompanyCheckout?: Maybe<Company>;
  /** Updates the status of a company collab */
  updateCompanyCollab?: Maybe<PublicCompany>;
  /** Updates a company's  general info */
  updateCompanyInfo?: Maybe<Company>;
  /** Updates the order of a company's items */
  updateCompanyItemOrdering?: Maybe<Scalars["Boolean"]["output"]>;
  /** Uodates a ledger account for a company */
  updateCompanyLedgerAccount?: Maybe<LedgerAccount>;
  /** Updates a company's legal settings */
  updateCompanyLegal?: Maybe<Company>;
  /** Allows a company to update their support profile */
  updateCompanyProfile?: Maybe<CompanyProfile>;
  /** Updates a connected account settings */
  updateConnectedAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Update a content rewards campaign */
  updateContentRewardsCampaign?: Maybe<Campaign>;
  /** Updates an existing dispute */
  updateDispute?: Maybe<Dispute>;
  /** Updates an existing raffle entry to make it a winner */
  updateEntry?: Maybe<Entry>;
  /** Updates an existing Experience */
  updateExperience?: Maybe<ExperienceInterface>;
  /** Updates the list of access passes for an experience */
  updateExperienceAccessPasses?: Maybe<Experience>;
  /** Updates a user's favorite access passes */
  updateFavoriteAccessPasses?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a parent access pass's featured access passes */
  updateFeaturedAccessPasses?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a feed webhook */
  updateFeedWebhook?: Maybe<FeedWebhook>;
  /** Updates the global watermark for a user */
  updateGlobalWatermark?: Maybe<Scalars["Boolean"]["output"]>;
  /** Allows a Company to update a note about a User with a Membership */
  updateMemberNote?: Maybe<MemberNote>;
  /** Update a membership that you sold. Like cancelling, pausing, etc. */
  updateMembership?: Maybe<Membership>;
  /** Updates the mobile push paused until attribute. */
  updateMobilePushPausedUntil?: Maybe<Scalars["Boolean"]["output"]>;
  /** Allows a user to update a livestream participant's permissions */
  updateParticipantsPermissions?: Maybe<Scalars["Boolean"]["output"]>;
  /** Allows a user to update one of their attached payment methods. */
  updatePaymentMethod?: Maybe<PaymentMethod>;
  /** Updates a stripe personal account */
  updatePersonalAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing Plan */
  updatePlan?: Maybe<Plan>;
  /** Updates a popup promo */
  updatePopupPromo?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a Product Highlight */
  updateProductHighlight?: Maybe<ProductHighlight>;
  /** Updates the order of a collection of product highlights */
  updateProductHighlightOrder?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the products for an experience */
  updateProductsForExperience?: Maybe<Scalars["Boolean"]["output"]>;
  /** Responsible for refunding receipts and retrying receipt payments. */
  updateReceipt?: Maybe<Receipt>;
  /** Updates a redirect URI for the OAuth application */
  updateRedirectUri?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the notification preference for a user */
  updateSimpleNotificationPreference?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a stream key for a user */
  updateStreamKey?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing Experience for Software */
  updateStripeAccount?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates the upsell access passes of an access pass */
  updateUpsellAccessPasses?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates an existing user */
  updateUser?: Maybe<User>;
  /** Updates the user's onboarding data */
  updateUserOnboardingData?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a user's preferences */
  updateUserPreferences?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a user social link */
  updateUserSocialLink?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a user's VAT ID for a product/currency combination */
  updateVatId?: Maybe<Scalars["Boolean"]["output"]>;
  /** Updates a webhook */
  updateWebhook?: Maybe<Webhook>;
  /** Upgrades a membership to a different plan */
  upgradePlan?: Maybe<Scalars["String"]["output"]>;
  /**
   * Uploads an image to be displayed on the marketplace for a company.
   * @deprecated Use updateAccessPassAttachments instead
   */
  uploadAccessPassImage?: Maybe<Image>;
  /** Processes the change email request and changes it in the DB */
  verifyEmail?: Maybe<Scalars["Boolean"]["output"]>;
  /** Verifies a phone code for a user */
  verifyPhoneCode?: Maybe<Scalars["Boolean"]["output"]>;
  /** Verify a social link */
  verifyUserSocialLink?: Maybe<UserSocialLinks>;
  /** Views the details of a receipt */
  viewReceiptDetails?: Maybe<Scalars["String"]["output"]>;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddAuthorizedUserArgs = {
  input: AddAuthorizedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddExperienceToAccessPassArgs = {
  input: AddExperienceToAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddExternalAccountArgs = {
  input: AddExternalAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddFcmTokenArgs = {
  input: AddFcmTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddLedgerExternalAccountArgs = {
  input: AddLedgerExternalAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddOauthEmailArgs = {
  input: AddOauthEmailInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAddRedirectUriArgs = {
  input: AddRedirectUriInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApplyPromoCodeArgs = {
  input: ApplyPromoCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApplyPromoCodeToMembershipArgs = {
  input: ApplyPromoCodeToMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApplyPromoCodeToMyMembershipArgs = {
  input: ApplyPromoCodeToMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApproveAllEntriesArgs = {
  input: ApproveAllEntriesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApproveAllWaitlistEntriesArgs = {
  input: ApproveAllWaitlistEntriesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApproveContentRewardsSubmissionArgs = {
  input: ApproveSubmissionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApproveEntryArgs = {
  input: ApproveEntryInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationApproveFlaggedContentRewardsSubmissionArgs = {
  input: ApproveFlaggedSubmissionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationArchiveAffiliateArgs = {
  input: ArchiveAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationArchiveContentRewardsCampaignArgs = {
  input: ArchiveCampaignInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAssignAccountManagerArgs = {
  input: AssignAccountManagerInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAttachAffiliateArgs = {
  input: AttachAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAuthenticatorDataArgs = {
  input: AuthenticatorDataInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationAutoJoinDormantUsersArgs = {
  input: AutoJoinDormantUsersInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationBanUserArgs = {
  input: BanUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationBlockUserArgs = {
  input: BlockUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCalculateTaxArgs = {
  input: CalculateTaxInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCancelAbuseReportArgs = {
  input: CancelAbuseReportInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationChangeAccessPassStatusArgs = {
  input: ChangeAccessPassStatusInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationChangeCardMyMembershipArgs = {
  input: ChangeCardMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationChangeEmailArgs = {
  input: ChangeEmailInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCheckAuthenticatorCodeArgs = {
  input: CheckAuthenticatorCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCloneAccessPassArgs = {
  input: CloneAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationConfirmAppleTransactionArgs = {
  input: ConfirmAppleTransactionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationConfirmPaypalOauthArgs = {
  input: ConfirmPaypalOauthInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAccessPassArgs = {
  input: CreateAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAccessPassAbuseReportArgs = {
  input: CreateAccessPassAbuseReportInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAccessPassAffiliateArgs = {
  input: CreateAccessPassAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAccessPassFaqArgs = {
  input: CreateAccessPassFaqInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAccessPassSocialLinkArgs = {
  input: CreateAccessPassSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAdminMembershipArgs = {
  input: CreateAdminMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAffiliateArgs = {
  input: CreateAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAiVideoArgs = {
  input: CreateVideoInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateApiKeyV2Args = {
  input: CreateApiKeyV2Input;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAppExperienceArgs = {
  input: CreateAppExperienceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateAuthorizedUserArgs = {
  input: CreateAuthorizedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateBountyArgs = {
  input: CreateBountyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateCheckoutSessionArgs = {
  input: CreateCheckoutSessionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateCoinbaseAccountArgs = {
  input: CreateCoinbaseAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateCompanyMutedUserArgs = {
  input: CreateCompanyMutedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateContentRewardsCampaignArgs = {
  input: CreateCampaignInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateContentRewardsSubmissionArgs = {
  input: CreateSubmissionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateCryptoWalletArgs = {
  input: CreateCryptoWalletInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateCryptoWalletNonceArgs = {
  input: CreateCryptoWalletNonceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateDirectMessageArgs = {
  input: CreateDirectMessageInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateDiscoverInteractionArgs = {
  input: CreateDiscoverInteractionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateDmChannelArgs = {
  input: CreateDmChannelInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateFeedWebhookArgs = {
  input: CreateFeedWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateForumPostArgs = {
  input: CreateForumPostInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateIngressArgs = {
  input: CreateIngressInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateLeadArgs = {
  input: CreateLeadInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateLedgerConnectedAccountArgs = {
  input: CreateLedgerConnectedAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateLineItemArgs = {
  input: CreateLineItemInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateLivekitTokenArgs = {
  input: CreateLivekitTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateMemberArgs = {
  input: CreateMemberInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateMemberNoteArgs = {
  input: CreateMemberNoteInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreatePaymentMethodArgs = {
  input: CreatePaymentMethodInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreatePersonalAccountArgs = {
  input: CreatePersonalAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreatePlanArgs = {
  input: CreatePlanInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateProductHighlightArgs = {
  input: CreateProductHighlightInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreatePromoCodeArgs = {
  input: CreatePromoCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateQuickLinkArgs = {
  input: CreateQuickLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateReviewArgs = {
  input: CreateReviewInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateReviewReportArgs = {
  input: CreateReviewReportInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateSetupTokenArgs = {
  input: CreateSetupTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateTrackingLinkArgs = {
  input: CreateTrackingLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateUnverifiedUserSocialLinkArgs = {
  input: CreateUnverifiedUserSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateUserLedgerAccountArgs = {
  input: CreateUserLedgerAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateUserReportArgs = {
  input: CreateUserReportInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateUserSocialLinkArgs = {
  input: CreateUserSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateUserTelegramVerificationCodeArgs = {
  input: CreateUserTelegramVerificationCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateWebhookArgs = {
  input: CreateWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCreateWithdrawalArgs = {
  input: CreateWithdrawalInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCustomerCreateResolutionArgs = {
  input: CustomerCreateResolutionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationCustomerRespondResolutionArgs = {
  input: CustomerRespondResolutionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAccessPassArgs = {
  input: DeleteAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAccessPassFaqArgs = {
  input: DeleteAccessPassFaqInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAccessPassImageArgs = {
  input: DeleteAccessPassImageInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAccessPassSocialLinkArgs = {
  input: DeleteAccessPassSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAffiliateArgs = {
  input: DeleteAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAffiliateForPlanArgs = {
  input: DeleteAffiliateForPlanInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAuthorizedUserArgs = {
  input: DeleteAuthorizedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteAuthorizedUserInviteArgs = {
  input: DeleteAuthorizedUserInviteInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteCoinbaseAccountArgs = {
  input: DeleteCoinbaseAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteCompanyArgs = {
  input: DeleteCompanyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteCompanyMutedUserArgs = {
  input: DeleteCompanyMutedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteCryptoWalletArgs = {
  input: DeleteCryptoWalletInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteExperienceArgs = {
  input: DeleteExperienceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteFeedWebhookArgs = {
  input: DeleteFeedWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteLedgerConnectedAccountArgs = {
  input: DeleteLedgerConnectedAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteLivestreamRecordingArgs = {
  input: DeleteRecordingInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteMemberNoteArgs = {
  input: DeleteMemberNoteInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteMyAccountArgs = {
  input: DeleteMyAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeletePaymentMethodArgs = {
  input: DeletePaymentMethodInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeletePaymentTokenArgs = {
  input: DeletePaymentTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeletePaypalAccountArgs = {
  input: DeletePaypalAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeletePlanArgs = {
  input: DeletePlanInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteProductHighlightArgs = {
  input: DeleteProductHighlightInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeletePromoCodeArgs = {
  input: DeletePromoCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteReviewArgs = {
  input: DeleteReviewInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteStripeAccountV2Args = {
  input: DeleteStripeAccountV2Input;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteTrackingLinkArgs = {
  input: DeleteTrackingLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteUserChatMessagesArgs = {
  input: DeleteUserChatMessagesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteUserSocialLinkArgs = {
  input: DeleteUserSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDeleteWebhookArgs = {
  input: DeleteWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDisableTwoFactorArgs = {
  input: DisableTwoFactorInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationDisconnectWalletArgs = {
  input: DisconnectWalletInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationEnableCancelationDiscountsArgs = {
  input: EnableCancelationDiscountsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationEndLivestreamArgs = {
  input: EndLivestreamInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationExportCreatorDashboardTableArgs = {
  input: ExportCreatorDashboardTableInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationFetchAiVideoCharactersArgs = {
  input: FetchVideoCharactersInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationFetchJobStatusArgs = {
  input: FetchJobStatusInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationFulfillTradingViewExperienceArgs = {
  input: FulfillTradingViewExperienceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateConnectedAccountSessionArgs = {
  input: GenerateConnectedAccountSessionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateLedgerAccountManageUrlArgs = {
  input: GenerateLedgerAccountManageUrlInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateMobileOauthCodeArgs = {
  input: GenerateMobileOauthCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateMuxUploadUrlArgs = {
  input: GenerateMuxUploadUrlInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGeneratePaypalOauthUrlArgs = {
  input: GeneratePaypalOauthUrlInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateStripeManageUrlArgs = {
  input: GenerateStripeManageUrlInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateTransferLinkArgs = {
  input: GenerateTransferLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateValueWithAiArgs = {
  input: GenerateValueWithAiInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGenerateWebsocketJwtArgs = {
  input: GenerateWebsocketJwtInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationGoLiveArgs = {
  input: GoLiveInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationInviteUserToAccessPassArgs = {
  input: InviteUserToAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationJoinFreeAccessPassArgs = {
  input: JoinFreeAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationKickFromAWhopArgs = {
  input: KickFromAWhopInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationLeaveAWhopArgs = {
  input: LeaveAWhopInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationLivestreamLeaveStageArgs = {
  input: LeaveStageInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationLogoutArgs = {
  input: LogoutInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationLogoutAllDevicesArgs = {
  input: LogoutAllDevicesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationManualChargeArgs = {
  input: ManualChargeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMarkExperienceReadArgs = {
  input: MarkExperienceReadInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMarkFeedPostsAsViewedArgs = {
  input: MarkFeedPostsAsViewedInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMarkPostsAsViewedArgs = {
  input: MarkPostsAsViewedInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMarkSetSettlementAddressArgs = {
  input: MarkSetSettlementAddressInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMediaAnalyzeAttachmentArgs = {
  input: AnalyzeAttachmentInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMediaDirectUploadArgs = {
  input: DirectUploadInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMerchantRespondResolutionArgs = {
  input: MerchantRespondResolutionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationMuteParticipantMicrophoneArgs = {
  input: MuteParticipantMicrophoneInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationPollAiVideoArgs = {
  input: PollVideoInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationPresignedUploadArgs = {
  input: PresignedUploadInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationProcessCheckoutArgs = {
  input: ProcessCheckoutInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationProcessEntitiesArgs = {
  input: ProcessEntitiesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationProcessEntryArgs = {
  input: ProcessEntryInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationProcessForumEntitiesArgs = {
  input: ProcessForumEntitiesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRateAccessPassArgs = {
  input: RateAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationReassignOwnershipArgs = {
  input: ReassignOwnershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRefundReceiptArgs = {
  input: RefundReceiptInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRegisterCompanyArgs = {
  input: RegisterCompanyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRejectContentRewardsSubmissionArgs = {
  input: RejectSubmissionInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRejectCreatorMilestoneArgs = {
  input: RejectCreatorMilestoneInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemoveEntryArgs = {
  input: RemoveEntryInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemoveExperienceFromAccessPassArgs = {
  input: RemoveExperienceFromAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemoveFcmTokenArgs = {
  input: RemoveFcmTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemoveMyAccountArgs = {
  input: RemoveMyAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemovePhoneNumberArgs = {
  input: RemovePhoneNumberInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRemoveRedirectUriArgs = {
  input: RemoveRedirectUriInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRequestLedgerWithdrawalArgs = {
  input: RequestLedgerWithdrawalInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRequestToStandArgs = {
  input: RequestToStandInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationResolveCoinbasePaymentArgs = {
  input: ResolveCoinbasePaymentInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRetrieveChallengeResultArgs = {
  input: RetrieveChallengeResultInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRetryPastDuePaymentsArgs = {
  input: RetryPastDuePaymentsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRetryPaymentMyMembershipArgs = {
  input: RetryPaymentMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRetryPayoutArgs = {
  input: RetryPayoutInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRevokeApiKeyArgs = {
  input: RevokeApiKeyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRevokeApiKeyV2Args = {
  input: RevokeApiKeyV2Input;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationRevokeOauthTokenArgs = {
  input: RevokeOauthTokenInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSendMessageArgs = {
  input: SendMessageInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSendNoPaymentEmailArgs = {
  input: SendNoPaymentEmailInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSendPhoneCodeArgs = {
  input: SendPhoneCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSendWithdrawalPdfArgs = {
  input: SendWithdrawalPdfInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSetNotificationPreferenceArgs = {
  input: SetNotificationPreferenceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationShuffleApiKeyArgs = {
  input: ShuffleApiKeyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationShuffleOauthSecretArgs = {
  input: ShuffleOauthSecretInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationStartEmailVerificationArgs = {
  input: StartEmailVerificationInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationStripeOauthV2Args = {
  input: StripeOauthV2Input;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSubmitAllPaymentDisputesArgs = {
  input: SubmitAllPaymentDisputesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationSubmitPaymentDisputeArgs = {
  input: SubmitPaymentDisputeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationTerminateMyMembershipArgs = {
  input: TerminateMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationTestWebhookV2Args = {
  input: TestWebhookV2Input;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationToggleCancelMyMembershipArgs = {
  input: ToggleCancelMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationTransferFundsArgs = {
  input: TransferFundsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationTransferLinkMyMembershipArgs = {
  input: TransferLinkMyMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUnarchiveAffiliateArgs = {
  input: UnarchiveAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUnbanUserArgs = {
  input: UnbanUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUnblockUserArgs = {
  input: UnblockUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUnlinkTwitterAccountArgs = {
  input: UnlinkTwitterAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassArgs = {
  input: UpdateAccessPassInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassAffiliateArgs = {
  input: UpdateAccessPassAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassAttachmentsArgs = {
  input: UpdateAccessPassAttachmentsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassFaqArgs = {
  input: UpdateAccessPassFaqInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassFaqOrderArgs = {
  input: UpdateAccessPassFaqOrderInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassFileAttachmentsArgs = {
  input: UpdateAccessPassFileAttachmentsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassImageOrderArgs = {
  input: UpdateAccessPassImageOrderInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassImagesArgs = {
  input: UpdateAccessPassImagesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassItemOrderingArgs = {
  input: UpdateAccessPassItemOrderingInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassMarketplaceCategoriesArgs = {
  input: UpdateAccessPassMarketplaceCategoriesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassMemberOrderArgs = {
  input: UpdateAccessPassMemberOrderInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassPinnedExperiencesArgs = {
  input: UpdateAccessPassPinnedExperiencesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAccessPassSocialLinkArgs = {
  input: UpdateAccessPassSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAffiliateArgs = {
  input: UpdateAffiliateInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateApiKeyArgs = {
  input: UpdateApiKeyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAppArgs = {
  input: UpdateAppInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAppViewArgs = {
  input: UpdateAppViewInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAuthorizedUserArgs = {
  input: UpdateAuthorizedUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAutoRespondToResolutionsArgs = {
  input: UpdateAutoRespondToResolutionsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateAutomatedMessagesConfigArgs = {
  input: UpdateAutomatedMessagesConfigInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateBillingAddressArgs = {
  input: UpdateBillingAddressInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCoinbaseAccountArgs = {
  input: UpdateCoinbaseAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyBillingArgs = {
  input: UpdateCompanyBillingInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyCheckoutArgs = {
  input: UpdateCompanyCheckoutInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyCollabArgs = {
  input: UpdateCompanyCollabInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyInfoArgs = {
  input: UpdateCompanyInfoInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyItemOrderingArgs = {
  input: UpdateCompanyItemOrderingInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyLedgerAccountArgs = {
  input: UpdateCompanyLedgerAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyLegalArgs = {
  input: UpdateCompanyLegalInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateCompanyProfileArgs = {
  input: UpdateCompanyProfileInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateConnectedAccountArgs = {
  input: UpdateConnectedAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateContentRewardsCampaignArgs = {
  input: UpdateCampaignInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateDisputeArgs = {
  input: UpdateDisputeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateEntryArgs = {
  input: UpdateEntryInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateExperienceArgs = {
  input: UpdateExperienceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateExperienceAccessPassesArgs = {
  input: UpdateExperienceAccessPassesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateFavoriteAccessPassesArgs = {
  input: UpdateFavoriteAccessPassesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateFeaturedAccessPassesArgs = {
  input: UpdateFeaturedAccessPassesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateFeedWebhookArgs = {
  input: UpdateFeedWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateGlobalWatermarkArgs = {
  input: UpdateGlobalWatermarkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateMemberNoteArgs = {
  input: UpdateMemberNoteInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateMembershipArgs = {
  input: UpdateMembershipInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateMobilePushPausedUntilArgs = {
  input: UpdateMobilePushPausedUntilInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateParticipantsPermissionsArgs = {
  input: UpdateParticipantsPermissionsInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdatePaymentMethodArgs = {
  input: UpdatePaymentMethodInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdatePersonalAccountArgs = {
  input: UpdatePersonalAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdatePlanArgs = {
  input: UpdatePlanInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdatePopupPromoArgs = {
  input: UpdatePopupPromoInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateProductHighlightArgs = {
  input: UpdateProductHighlightInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateProductHighlightOrderArgs = {
  input: UpdateProductHighlightOrderInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateProductsForExperienceArgs = {
  input: UpdateProductsForExperienceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateReceiptArgs = {
  input: UpdateReceiptInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateRedirectUriArgs = {
  input: UpdateRedirectUriInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateSimpleNotificationPreferenceArgs = {
  input: UpdateSimpleNotificationPreferenceInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateStreamKeyArgs = {
  input: UpdateStreamKeyInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateStripeAccountArgs = {
  input: UpdateStripeAccountInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateUpsellAccessPassesArgs = {
  input: UpdateUpsellAccessPassesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateUserArgs = {
  input: UpdateUserInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateUserOnboardingDataArgs = {
  input: UpdateUserOnboardingDataInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateUserPreferencesArgs = {
  input: UpdateUserPreferencesInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateUserSocialLinkArgs = {
  input: UpdateUserSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateVatIdArgs = {
  input: UpdateVatIdInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpdateWebhookArgs = {
  input: UpdateWebhookInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUpgradePlanArgs = {
  input: UpgradePlanInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationUploadAccessPassImageArgs = {
  input: UploadAccessPassImageInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationVerifyPhoneCodeArgs = {
  input: VerifyPhoneCodeInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationVerifyUserSocialLinkArgs = {
  input: VerifyUserSocialLinkInput;
};

/** A list of all mutations available in the Whop GraphQL API */
export type PublicMutationViewReceiptDetailsArgs = {
  input: ViewReceiptDetailsInput;
};

export type PublicNotification = {
  __typename?: "PublicNotification";
  /** The company that sent the notification */
  company?: Maybe<PublicCompany>;
  /** The content of the notification */
  content: Scalars["String"]["output"];
  /** The time the notification was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The experience this notification is for */
  experience?: Maybe<PublicExperience>;
  /** The external ID of the notification */
  externalId?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the notification */
  id: Scalars["ID"]["output"];
  /** An iframe link to take the user to */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** A link to take the user to */
  link?: Maybe<Scalars["String"]["output"]>;
  /** The notification topic of the notification */
  notificationTopic?: Maybe<PublicNotificationTopic>;
  /** The primary img (big img). */
  primaryImageSrcset: ImgSrcset;
  /** The rest path of the notification */
  restPath?: Maybe<Scalars["String"]["output"]>;
  /** The secondary img (little img) */
  secondaryImageSrcset?: Maybe<ImgSrcset>;
  /** The time the notification was last seen */
  seenAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The user that sent the notification, if any. */
  senderUser?: Maybe<PublicProfileUser>;
  /** The subject of the notification */
  subject: Scalars["String"]["output"];
};

export type PublicNotificationPrimaryImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

export type PublicNotificationSecondaryImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** The connection type for PublicNotification. */
export type PublicNotificationConnection = {
  __typename?: "PublicNotificationConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicNotificationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicNotification>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicNotificationEdge = {
  __typename?: "PublicNotificationEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicNotification>;
};

/** A notification topic */
export type PublicNotificationTopic = {
  __typename?: "PublicNotificationTopic";
  /** The action of the notification topic */
  action?: Maybe<Scalars["String"]["output"]>;
  /** The description of the notification topic */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the notification topic */
  id: Scalars["ID"]["output"];
  /** The name of the notification topic */
  name: Scalars["String"]["output"];
};

/** The connection type for PublicNotificationTopic. */
export type PublicNotificationTopicConnection = {
  __typename?: "PublicNotificationTopicConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicNotificationTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicNotificationTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicNotificationTopicEdge = {
  __typename?: "PublicNotificationTopicEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicNotificationTopic>;
};

/** An object representing a (sanitized) plan of an access pass. */
export type PublicPlan = {
  __typename?: "PublicPlan";
  /** An array of the accepted payment methods for a plan. */
  acceptedPaymentMethods: Array<AcceptedPaymentMethods>;
  /** The access pass for the plan. */
  accessPass?: Maybe<PublicAccessPass>;
  /** Whether or not ACH payments are allowed. */
  achPayments: Scalars["Boolean"]["output"];
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity: Scalars["Boolean"]["output"];
  /** Marks whether the customer has already purchased this plan. */
  alreadyEntered: Scalars["Boolean"]["output"];
  /** Returns true if the customer has already purchased this plan and their membership on the plan is currently active. */
  alreadyOwned: Scalars["Boolean"]["output"];
  /**
   * No longer used.
   * @deprecated No longer available.
   */
  amountSaved?: Maybe<Scalars["String"]["output"]>;
  /** Returns the Apple IAP price for the plan, if applicable. */
  appleIapPrice?: Maybe<Scalars["Float"]["output"]>;
  /** The respective currency identifier for the plan. */
  baseCurrency: Currencies;
  /** The interval at which the plan charges (renewal plans). */
  billingPeriod?: Maybe<Scalars["Int"]["output"]>;
  /** Whether or not the user has a billing setup for this plan */
  billingSetupRequired: Scalars["Boolean"]["output"];
  /** Where the user should be re-directed to when clicking the buy box button. */
  buyButtonLocation: BuyButtonLocations;
  /** The text to display on the buy box. */
  buyButtonText: Scalars["String"]["output"];
  /** How the buyer fee should be applied, if any. */
  buyerFeeMode?: Maybe<BuyerFeeMode>;
  /** The buyer fee percentage to apply to the transaction, if any. */
  buyerFeePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** The payment processors that support the buyer fee, if any. */
  buyerFeeSupportedProcessors: Array<PaymentProcessor>;
  /** Whether the plan supports card payments. */
  cardPayments: Scalars["Boolean"]["output"];
  /** The description to display on the checkout page. */
  checkoutDescription?: Maybe<Scalars["String"]["output"]>;
  /** The title to display on the checkout page. */
  checkoutTitle?: Maybe<Scalars["String"]["output"]>;
  /** An array of plans that are upsells for this plan. */
  checkoutUpsellPlans: Array<PublicPlan>;
  /** Marks whether coinbase commerce payments are/aren't accepted. */
  coinbaseCommerceAccepted: Scalars["Boolean"]["output"];
  /** Whether or not the plan collects tax. */
  collectTax: Scalars["Boolean"]["output"];
  /** The company for the plan. */
  company?: Maybe<PublicCompany>;
  /** When the plan was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The custom fields for the plan. */
  customFields: Array<CustomField>;
  /** The description of the plan. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The direct link to purchase the access pass. */
  directLink: Scalars["String"]["output"];
  /** The interval at which the plan charges (expiration plans). */
  expirationDays?: Maybe<Scalars["Int"]["output"]>;
  /** The price on top of the `renewal` that the user has to pay. (Used for display on the buy box) */
  extraFee?: Maybe<Scalars["String"]["output"]>;
  /** The period the access pass is valid for upon purchase (one-time plans). */
  formattedAccessPeriod?: Maybe<Scalars["String"]["output"]>;
  /** The amount with the currency that this plan costs. */
  formattedAmount: Scalars["String"]["output"];
  /** A human readable format for the billing period cycle. */
  formattedBillingPeriod?: Maybe<Scalars["String"]["output"]>;
  /** The interval at which the plan charges (if applicable). */
  formattedPeriod?: Maybe<Scalars["String"]["output"]>;
  /** The period which the plan renews or expires for the customer. */
  formattedPeriodV2: Scalars["String"]["output"];
  /** The formatted price (including currency) for the plan. */
  formattedPrice: Scalars["String"]["output"];
  /** Whether or not the plan is free. */
  free: Scalars["Boolean"]["output"];
  /** The internal ID of the plan. */
  id: Scalars["ID"]["output"];
  /** Whether or not the plan is in stock. */
  inStock: Scalars["Boolean"]["output"];
  /** The formatted price a person has to pay for a plan on the initial purchase. */
  initialPrice?: Maybe<Scalars["String"]["output"]>;
  /** How much the user has to pay on the first payment. */
  initialPriceDue: Scalars["Float"]["output"];
  /** The initial price due for purchase (in cents). */
  initialPriceDueInCents: Scalars["Int"]["output"];
  /** The ledger account for the plan, if any. */
  ledgerAccount?: Maybe<PublicLedgerAccount>;
  /** How much stock is left or how many more entries that are allowed before it will close. */
  lowStockWarning?: Maybe<Scalars["Float"]["output"]>;
  /** Whether or not the company is the merchant of record. Uses the plan's current stripe account. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** The name of the plan. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Stripe Payment element. If present, pass this value as the on_behalf_of parameter. */
  onBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** Marks whether the plan is one per company. */
  onePerCompany: Scalars["Boolean"]["output"];
  /**
   * Marks whether the plan is one per user.
   * @deprecated No longer used
   */
  onePerUser: Scalars["Boolean"]["output"];
  /** Marks whether the plan is password protected. */
  passwordProtected: Scalars["Boolean"]["output"];
  /** The description of the Plan as seen by the customer on the checkout page. */
  paymentLinkDescription?: Maybe<Scalars["String"]["output"]>;
  /** Used for the Payment Request Button. If present, pass this value as the on_behalf_of parameter. */
  paymentRequestOnBehalfOfId?: Maybe<Scalars["String"]["output"]>;
  /** The capabilities of the stripe account. */
  paymentsCapabilities: Array<Scalars["String"]["output"]>;
  /** The order of this plan in relation to other plans of the same access pass */
  planOrder: Scalars["Int"]["output"];
  /** Indicates if the plan is a one time payment or recurring. */
  planType: PlanTypes;
  /** The price to display inside of the buy box. */
  priceTag: Scalars["String"]["output"];
  /** The datetime the raffle expires. */
  raffleExpiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The price a person has to pay for a plan on the initial purchase. */
  rawInitialPrice: Scalars["Float"]["output"];
  /** The price a person has to pay for a plan on the initial purchase in USD. */
  rawInitialPriceUsd: Scalars["Float"]["output"];
  /** The price a person has to pay for a plan on the renewal purchase. */
  rawRenewalPrice: Scalars["Float"]["output"];
  /** The price a person has to pay for a plan on the renewal purchase in USD. */
  rawRenewalPriceUsd: Scalars["Float"]["output"];
  /** The custom URL to redirect the customer to after purchase. */
  redirectUrl?: Maybe<Scalars["String"]["output"]>;
  /** This is the release method the business uses to sell this plan. */
  releaseMethod: ReleaseMethod;
  /** The formatted renewal price a user pays for the plan. */
  renewalPrice: Scalars["String"]["output"];
  /** The type of purchase being made */
  sessionType: CheckoutSessionTypes;
  /** The setup future usage for the stripe payment intent for the stripe element options, if applicable. */
  setupFutureUsage?: Maybe<Scalars["String"]["output"]>;
  /**
   * Whether or not the payment request button (Apple Pay, Google Pay, etc) should be shown/used.
   * @deprecated This field is no longer implemented.
   */
  showPaymentRequest: Scalars["Boolean"]["output"];
  /** Whether or not the promo code input should be shown on checkout. */
  showPromoCodeInput: Scalars["Boolean"]["output"];
  /** A list of countries that should be skipped when quoting tax for this plan. */
  skipTaxQuotingCountries: Array<Scalars["String"]["output"]>;
  /** Marks whether the customer has already purchased this plan, ever. */
  skippingFreeTrial: Scalars["Boolean"]["output"];
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: Maybe<Scalars["Int"]["output"]>;
  /** The number of units available for purchase. */
  stock?: Maybe<Scalars["Int"]["output"]>;
  /** The stripe public key to use for setting up this plans stripe.js */
  stripeAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe payment method configuration id to use for setting up the stripe.js elements */
  stripePaymentMethodConfigurationId?: Maybe<Scalars["String"]["output"]>;
  /** The stripe public key to use for setting up this plans stripe.js */
  stripePublicKey?: Maybe<Scalars["String"]["output"]>;
  /** The tax type for the plan. */
  taxType: TaxTypes;
  /** The terms and conditions related to purchasing this plan. */
  termsAndConditions: Scalars["String"]["output"];
  /** The title of the owning object. */
  title: Scalars["String"]["output"];
  /** The number of free trial days added before a renewal plan. */
  trialPeriodDays?: Maybe<Scalars["Int"]["output"]>;
  /** Limits/doesn't limit the number of units available for purchase. */
  unlimitedStock: Scalars["Boolean"]["output"];
  /** When the plan was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
  /** Whether or not to use the Basis Theory element during checkout. */
  useBasisTheory: Scalars["Boolean"]["output"];
  /** Shows or hides the plan from public/business view. */
  visibility: Visibility;
};

/** An object representing a (sanitized) plan of an access pass. */
export type PublicPlanCheckoutUpsellPlansArgs = {
  upsellType: UpsellTypes;
};

/** The connection type for PublicPlan. */
export type PublicPlanConnection = {
  __typename?: "PublicPlanConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicPlanEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicPlan>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicPlanEdge = {
  __typename?: "PublicPlanEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicPlan>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUser = {
  __typename?: "PublicProfileUser";
  /** Attributes for the account manager */
  accountManagerAttributes?: Maybe<AccountManagerAttributes>;
  /**
   * The average response time in minutes for the user.
   * @deprecated Use averageResponseTimeInSeconds instead
   */
  averageResponseTimeInMinutes: Scalars["Int"]["output"];
  /** The average response time in seconds for the user. */
  averageResponseTimeInSeconds?: Maybe<Scalars["Int"]["output"]>;
  /** The user's banner image */
  banner?: Maybe<AttachmentInterface>;
  /** The user's banner image. Deprecated, use banner instead. */
  bannerImageSrcset?: Maybe<ImgSrcset>;
  /** The user's bio */
  bio?: Maybe<Scalars["String"]["output"]>;
  /** The time at which the user was blocked by the current user. */
  blockedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The city the user is from. */
  city?: Maybe<Scalars["String"]["output"]>;
  /** All company members for bots owned by the authorized user. */
  companyMembers: CompanyMemberConnection;
  /** The country the user is from. */
  country?: Maybe<Scalars["String"]["output"]>;
  /** When the user was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The crypto wallets for the user. */
  cryptoWallets: CryptoWalletConnection;
  /** The current leaderboard rank for the user. */
  currentLeaderboardRank: LeaderboardSingle;
  /** Discovery Tags associated to this user (ordered by relevance) */
  discoveryTags: DiscoveryTagConnection;
  /** The earnings reports for the user. */
  earningsReports: EarningsReportConnection;
  /** The user's favorite whops. */
  favoriteAccessPasses: PublicAccessPassConnection;
  /** The internal ID of the user. */
  id: Scalars["ID"]["output"];
  /** Whether this user is an authorized user on a given company. */
  isAuthorizedUserOn: Scalars["Boolean"]["output"];
  /** Whether this user is an authorized user on a given experience. */
  isAuthorizedUserOnExperience: Scalars["Boolean"]["output"];
  /** All of the access passes the user has joined. */
  joinedAccessPasses: PublicAccessPassConnection;
  /**
   * The companies the user joined.
   * @deprecated Use joinedAccessPasses instead
   */
  joinedWhops: PublicCompanyConnection;
  /**
   * The last time the user was active.
   * @deprecated Use lastSeenAt instead
   */
  lastActiveAt: Scalars["Timestamp"]["output"];
  /** The last time the user was active. */
  lastSeenAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The number of mutual access passes the user has with the current user. */
  mutualAccessPassesCount?: Maybe<Scalars["Int"]["output"]>;
  /** The mutual access passes the user is an admin of. */
  mutualAccessPassesWithAdminRole: PublicAccessPassConnection;
  /**
   * The mutual companies the user is an admin of.
   * @deprecated Use mutualAccessPassesWithAdminRole instead
   */
  mutualCompaniesWithAdminRole: PublicCompanyConnection;
  /**
   * The number of mutual whops the user has with the current user.
   * @deprecated Use mutualAccessPassesCount instead
   */
  mutualWhopsCount?: Maybe<Scalars["Int"]["output"]>;
  /** The name of the user from their Whop account. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The negative bulletin board badges for the user with their counts. */
  negativeBulletinBoardBadges: Array<BulletinBoardBadgeCount>;
  /** All of the access passes the user owns. */
  ownedAccessPasses: PublicAccessPassConnection;
  /**
   * The companies the user owns.
   * @deprecated Use ownedAccessPasses instead
   */
  ownedWhops: PublicCompanyConnection;
  /** The positive bulletin board badges for the user with their counts. */
  positiveBulletinBoardBadges: Array<BulletinBoardBadgeCount>;
  /** The user's profile image. Deprecated, use profilePicture instead. */
  profileImageSrcset?: Maybe<ImgSrcset>;
  /**
   * The URL of the user's profile picture
   * @deprecated Use profileImageSrcset instead
   */
  profilePic: Scalars["String"]["output"];
  /** The user's profile picture */
  profilePicture?: Maybe<AttachmentInterface>;
  /** The public ledger account for the user. */
  publicLedgerAccount?: Maybe<PublicLedgerAccount>;
  /** Whether this user can be reviewed by the current user. */
  reviewEligibility: UserReviewEligibility;
  /** The reviews the user has made. */
  reviews: ReviewConnection;
  /** The internal roles the user has. */
  roles: Array<Scalars["String"]["output"]>;
  /** The social links for the user. */
  socialLinks: UserSocialLinksConnection;
  /** The state the user is from. */
  state?: Maybe<Scalars["String"]["output"]>;
  /** The time spent in whop by the user. */
  timeSpentInWhopInSeconds?: Maybe<Scalars["Int"]["output"]>;
  /** The user's ranking in the sidebar. */
  timeSpentInWhopInSecondsRank?: Maybe<Scalars["Int"]["output"]>;
  /** The time spent per access pass for the user. */
  timeSpentPerAccessPassL24h: Array<TimeSpentAccessPass>;
  /** The time spent per experience for the user. */
  timeSpentPerExperienceL24h: Array<TimeSpentExperience>;
  /** The user's X account. */
  twitterAccount?: Maybe<TwitterAccount>;
  /** The user's number */
  userNumber: Scalars["Int"]["output"];
  /** The user preferences for this user. */
  userPreferences: UserPreference;
  /** The user's ranking. */
  userRanking?: Maybe<Scalars["Int"]["output"]>;
  /** The user's referral information. */
  userReferral?: Maybe<UserReferral>;
  /** The number of users referred by this user. */
  userReferralCount: Scalars["Int"]["output"];
  /** The number of users referred by this user in the last 7 days. */
  userReferralCountLast7Days: Scalars["Int"]["output"];
  /** The number of users referred by this user in the last 24 hours. */
  userReferralCountLast24Hours: Scalars["Int"]["output"];
  /** The number of users referred by this user in the last 30 days. */
  userReferralCountLast30Days: Scalars["Int"]["output"];
  /** Earning statistics for this user. */
  userStat?: Maybe<UserStat>;
  /** The username of the user from their Whop account. */
  username: Scalars["String"]["output"];
  /** The amount of USD paid out by the companyto the user. This field is only available in the context of the sidebar, b/c we need to set the bot id in context. */
  whopSidebarPaidOutByCompany?: Maybe<Scalars["Float"]["output"]>;
  /** The user's ranking in the sidebar. */
  whopSidebarPaidOutByCompanyRank?: Maybe<Scalars["Int"]["output"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserBannerImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserCompanyMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserCryptoWalletsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserCurrentLeaderboardRankArgs = {
  leaderboardType: LeaderboardTypes;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserEarningsReportsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<EarningsReportPeriods>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserFavoriteAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserIsAuthorizedUserOnArgs = {
  companyId: Scalars["ID"]["input"];
  roles?: InputMaybe<Array<AuthorizedUserRoles>>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserIsAuthorizedUserOnExperienceArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserJoinedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserJoinedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserMutualAccessPassesWithAdminRoleArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserMutualCompaniesWithAdminRoleArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserOwnedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserOwnedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserProfileImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<CompanyImageStyles>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserSocialLinksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserTimeSpentInWhopInSecondsArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a (sanitized) user of the site. */
export type PublicProfileUserTimeSpentInWhopInSecondsRankArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** The connection type for PublicProfileUser. */
export type PublicProfileUserConnection = {
  __typename?: "PublicProfileUserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicProfileUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicProfileUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicProfileUserEdge = {
  __typename?: "PublicProfileUserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicProfileUser>;
};

/** A whop user profile with a ranking value */
export type PublicProfileUserWithRanking = {
  __typename?: "PublicProfileUserWithRanking";
  /** The ranking value for the user. */
  ranking: Scalars["Int"]["output"];
  /** The user */
  user: PublicProfileUser;
};

/** An object representing a promo code for a plan. */
export type PublicPromoCode = {
  __typename?: "PublicPromoCode";
  /** The access pass associated with the promo code, if any. */
  accessPass?: Maybe<PublicAccessPass>;
  /** The amount off (% or flat amount) for the promo. */
  amountOff: Scalars["Float"]["output"];
  /** The monetary currency of the promo code. */
  baseCurrency: Currencies;
  /** The specific code used to apply the promo at checkout. */
  code: Scalars["String"]["output"];
  /** The timestamp of when the promo was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The amount off formatted for display. */
  discountOff: Scalars["String"]["output"];
  /** The duration of the promo. */
  duration: PromoDurations;
  /** Restricts promo use to only be applied to already purchased memberships. */
  existingMembershipsOnly: Scalars["Boolean"]["output"];
  /** The flash sale the promo is associated with, if any. */
  flashSale?: Maybe<PublicFlashSale>;
  /** The ID of the promo. */
  id: Scalars["ID"]["output"];
  /** Whether or not the promo is a popup promo. */
  isPopupPromo: Scalars["Boolean"]["output"];
  /** The number of billing cycles the promo is applied for. */
  numberOfIntervals: Scalars["Int"]["output"];
  /** The type (% or flat amount) of the promo. */
  promoType: PromoTypes;
};

/** The root query field which every query must start with. */
export type PublicQuery = {
  __typename?: "PublicQuery";
  /** Fetch all abuse report categories */
  abuseReportCategories: AbuseReportCategoryConnection;
  /** Fetch all abuse report sub categories */
  abuseReportSubCategories: AbuseReportSubCategoryConnection;
  /** Returns the stats of the affiliate landing page */
  affiliateLandingStats: AffiliateLandingStats;
  /** Search for the affiliate offers. */
  affiliateOffersSearch: Array<PublicAccessPass>;
  /** Returns a list of AI chat suggestions for users to start conversations with */
  aiChatSuggestions: Array<Scalars["String"]["output"]>;
  /** A list of all resources and their endpoints */
  apiEndpoints: Array<ApiKeyPermission>;
  /** The configuration data for an app */
  app: PublicApp;
  /** Returns the attachment */
  attachment: AttachmentInterface;
  /** Fetch all the bulletin board badges */
  bulletinBoardBadges: Array<Scalars["String"]["output"]>;
  /** Fetch a chat feed */
  chatFeed?: Maybe<ChatFeed>;
  /** Fetch a list of chat feeds */
  chatFeeds: Array<ChatFeed>;
  /** Returns the checkout configuration */
  checkoutConfiguration: CheckoutConfiguration;
  /** The requirements for a given plan. */
  checkoutRequirements: Array<CheckoutRequirement>;
  /**
   * A list of products from a collection used in Discovery views.
   * @deprecated The discovery AI API is no longer used.
   */
  collectionProducts: PublicAccessPassConnection;
  /** Fetch a company */
  company?: Maybe<Company>;
  /** Returns a content rewards campaign. */
  contentRewardsCampaign: Campaign;
  /**
   * The content rewards submissions for the discover page
   * @deprecated No longer available
   */
  contentRewardsSubmissions: DiscoverContentRewardsSubmissionTypeConnection;
  /** Returns the converted webhook event types for the necessary table. */
  convertedWebhookEventTypes: Scalars["JSON"]["output"];
  /** a list of countries that are available to select from */
  countries: CountryList;
  /** Returns the export columns for the necessary table. */
  creatorDashboardTableExportColumns: Array<CreatorDashboardTableExportColumn>;
  /** Returns the conditional filters for the necessary table. */
  creatorDashboardTableFilters: Array<TableFilter>;
  /** Fetch product */
  creatorMilestoneProduct: CreatorMilestoneProduct;
  /** The default avatars for the platform. */
  defaultAvatars: Array<DefaultAvatar>;
  /** Returns content rewards campaigns */
  discoverContentRewardsCampaigns: PublicCampaignConnection;
  /** Returns discoverable earning opportunities */
  discoverEarningOpportunities: Array<DiscoverEarningOpportunityInterface>;
  /** Returns discoverable events */
  discoverEvents: Array<Event>;
  /** Fetches access passes recommendations for a user */
  discoverForYouAccessPasses: AccessPassRecommendations;
  /** Returns the top experiences ordered by the amount of active users */
  discoverTopExperiences: Array<AccessibleExperience>;
  /**
   * Returns the categories for the discovery app
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryCategories: DiscoveryCategoryConnection;
  /**
   * A single discovery category
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryCategory: DiscoveryCategory;
  /**
   * Returns the content cards for the discovery app
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryContentCards: Array<DiscoveryContentCard>;
  /**
   * A single discovery module
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryModule: DiscoveryModuleInterface;
  /**
   * A list of modules to display on the Discovery screen.
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryModules: DiscoveryModuleInterfaceConnection;
  /** Search for the discovery app. */
  discoverySearch: DiscoverySearch;
  /**
   * A single discovery tag
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryTag: DiscoveryTag;
  /**
   * Tags to provide to the user in the Discovery context.
   * @deprecated The discovery AI API is no longer used.
   */
  discoveryTags: DiscoveryTagConnection;
  /** Fetch DM feed data for the current user for a specific feed */
  dmsFeedData?: Maybe<DmsFeedDataResponse>;
  /** Fetch a single dms post */
  dmsPost?: Maybe<DmsPostResponse>;
  /** Fetch an experience for a user. It will only return it if they have a valid membership that gives access to this experience */
  experience: PublicExperienceInterface;
  /** Returns the IDs for all experiences that are connected to at least 1 product */
  experienceIdsConnectedToProduct: Array<Scalars["ID"]["output"]>;
  /** Returns all experiences for a given company */
  experiences: PublicExperienceConnection;
  /** Returns all of the featured reviews for the marketplace. */
  featuredReviews: Array<Review>;
  /** Fetch feed posts for the current user */
  feedPosts?: Maybe<FeedPostsResponse>;
  /** Fetches a forum feed based on its experience ID */
  forumFeed?: Maybe<ForumFeed>;
  /** Fetch a single forums post */
  forumPost: ForumPostResponse;
  /** Fetches the hottest affiliate offers */
  hotAffiliateOffers: Array<HotAffiliateOffers>;
  /** Fetches the hottest affiliates */
  hotAffiliates: Array<HotAffiliates>;
  /** A leaderboard result for this access pass */
  leaderboard?: Maybe<Leaderboard>;
  /** Returns the ledger account for a user or a company buyer */
  ledgerAccount: LedgerAccount;
  /** Fetch a livestream feed */
  livestreamFeed?: Maybe<LivestreamFeed>;
  /** Fetches the livestream feed ingress */
  livestreamIngress?: Maybe<LivestreamIngress>;
  /** All mailing addresses of the bot that they can use to buy things */
  mailingAddresses: MailingAddressConnection;
  /** Returns the categories for the marketplace */
  marketplaceCategories: MarketplaceCategoryConnection;
  /** Returns a single marketplace category */
  marketplaceCategory: MarketplaceCategory;
  /** Returns the stats of the marketplace. */
  marketplaceStats: MarketplaceStats;
  /** Fetches a single Mux asset */
  muxAsset: MuxAsset;
  /** Fetch DM channels for the current user */
  myDmsChannels: DmsChannelsResponse;
  /** Fetch DM channels counts for the current user */
  myDmsChannelsCounts: MyDmsChannelsCounts;
  /** The rank of the access_pass on the leaderboard */
  myLeaderboardRank: Leaderboard;
  /** Newest affiliate referrals */
  newAffiliateReferrals: PublicAffiliateReferralLogConnection;
  /** Newest sold memberships */
  newPurchases: Array<PublicEvent>;
  /** A public receipt */
  notLoggedInReceipt: NotLoggedInReceipt;
  /** Retrieve notification topics based on a topic type */
  notificationTopics: PublicNotificationTopicConnection;
  /** Returns the details for the OAuth flow. */
  oauthDetails: OauthDetails;
  /** All payment methods of the bot that they can use to buy things */
  paymentMethods: PaymentMethodConnection;
  /** All payment tokens of the bot that they can use to buy things */
  paymentTokens: PaymentTokenConnection;
  /** Fetch children posts the current user */
  postChildren?: Maybe<FeedPostsResponse>;
  /** Fetch feed reactions for a post */
  postReactions: ReactionConnection;
  /** Fetches the status of a checkout job */
  processCheckoutStatus: ProcessCheckoutStatus;
  /** Fetches the status of an entry job */
  processEntryStatus: ProcessEntryStatus;
  /** Fetches a promo code based on the provided code and plan */
  promoCode: PublicPromoCode;
  /** Fetches an access pass based on the ID or the route */
  publicAccessPass: PublicAccessPass;
  /** Fetches a list of public access passes */
  publicAccessPasses: PublicAccessPassConnection;
  /** Fetches a list of public bounties */
  publicBounties: PublicBountyConnection;
  /** Fetches a public bounty by its id */
  publicBounty: PublicBounty;
  /** Fetches a company based on the ID */
  publicCompany: PublicCompany;
  /** Fetch an experience. */
  publicExperience: PublicExperience;
  /** Returns a line item that can be purchased */
  publicLineItem: PublicLineItem;
  /** Fetches a plan based on the ID */
  publicPlan: PublicPlan;
  /** Fetches a product based on the ID */
  publicProduct: PublicAccessPass;
  /** Fetches a public quick link based on the code */
  publicQuickLink: PublicQuickLink;
  /** Fetch a specific user. */
  publicUser: PublicProfileUser;
  /** Fetch a list of users given a list of IDs or usernames. */
  publicUsers: Array<PublicProfileUser>;
  /** Returns the IDs for all experiences that can be purchased */
  purchaseableExperienceIds: Array<Scalars["ID"]["output"]>;
  /** Returns the random investigate buckets */
  randomInvestigateBuckets?: Maybe<Array<RandomInvestigateBuckets>>;
  /** Returns a User's receipt that they are authorized to own */
  receipt: PublicReceipt;
  /** Returns recommended access passes */
  recommendedAccessPasses: Array<PublicAccessPass>;
  /** A list of recommended searches for the marketplace */
  recommendedSearches: Array<Scalars["String"]["output"]>;
  /** Fetch a specific user. */
  resolveAffiliateUser?: Maybe<PublicProfileUser>;
  /** Resolve a tracking link */
  resolveTrackingLink?: Maybe<PublicTrackingLink>;
  /** Resolves the whop 4 page route */
  resolveWhopFourRoute?: Maybe<PublicAccessPass>;
  /** Fetch a single review. */
  review: Review;
  /** Returns receipts stats */
  stats: Stats;
  /** Returns the countries that Stripe supports for custom accounts. */
  stripeCustomCountries: Array<StripeCustomCountries>;
  /** Returns all of the supported currencies for plans on the marketplace. */
  supportedCurrencies: Array<SupportedCurrencies>;
  /** A universal post */
  universalPost: UniversalPost;
  /** A universal posts search result */
  universalPosts: UniversalPostResult;
  /** Search globally across Whop. */
  universalSearch: UniversalSearch;
  /** Returns the searchable resource types to display names */
  universalSearchResourceTypesToDisplayNames: Array<UniversalSearchResourceTypesToDisplayNames>;
  /** Fetch feed entities for the current user */
  updatedFeedEntities?: Maybe<UpdatedEntitiesResponse>;
  /** Fetch a specific user. */
  user?: Maybe<User>;
  /** Returns the VAT ID for a user or a company buyer */
  vatId?: Maybe<Scalars["String"]["output"]>;
  /** Returns the current user and company. */
  viewer: Viewer;
};

/** The root query field which every query must start with. */
export type PublicQueryAbuseReportCategoriesArgs = {
  additionalFilter?: InputMaybe<Scalars["String"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  resourceType?: InputMaybe<AbuseReportCategoryResourceTypes>;
  visibility?: InputMaybe<AbuseReportCategoryVisibility>;
};

/** The root query field which every query must start with. */
export type PublicQueryAbuseReportSubCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  highLevelCategoryId: Scalars["ID"]["input"];
  last?: InputMaybe<Scalars["Int"]["input"]>;
  visibility?: InputMaybe<AbuseReportCategoryVisibility>;
};

/** The root query field which every query must start with. */
export type PublicQueryAffiliateOffersSearchArgs = {
  query: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryAppArgs = {
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryAttachmentArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryChatFeedArgs = {
  feedId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryChatFeedsArgs = {
  feedIds: Array<Scalars["ID"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryCheckoutConfigurationArgs = {
  amount?: InputMaybe<Scalars["Float"]["input"]>;
  currency?: InputMaybe<Currencies>;
  ledgerAccountId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryCheckoutRequirementsArgs = {
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  customPassword?: InputMaybe<Scalars["String"]["input"]>;
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  quickLinkCode?: InputMaybe<Scalars["String"]["input"]>;
  renewingMembership?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryCollectionProductsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  collectionSlug?: Scalars["String"]["input"];
  discoveryCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  language?: InputMaybe<Scalars["String"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  onlyFree?: InputMaybe<Scalars["Boolean"]["input"]>;
  tags?: Array<Scalars["ID"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryCompanyArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryContentRewardsCampaignArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryContentRewardsSubmissionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<DiscoverContentRewardsSubmissionsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryCreatorDashboardTableExportColumnsArgs = {
  tableName: CreatorDashboardExportableTables;
};

/** The root query field which every query must start with. */
export type PublicQueryCreatorDashboardTableFiltersArgs = {
  tableName: TableNamesV2;
};

/** The root query field which every query must start with. */
export type PublicQueryCreatorMilestoneProductArgs = {
  productId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDefaultAvatarsArgs = {
  variant: ImageAttachmentVariants;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoverContentRewardsCampaignsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  category?: InputMaybe<ContentRewardsCategory>;
  contentType?: InputMaybe<ContentRewardsContentType>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  orderBy?: InputMaybe<CampaignOrder>;
  platform?: InputMaybe<ContentRewardsPlatform>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoverEarningOpportunitiesArgs = {
  type?: InputMaybe<DiscoverEarningOpportunityTypes>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoverForYouAccessPassesArgs = {
  anonymousUserIdentifier?: InputMaybe<Scalars["String"]["input"]>;
  count?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoverTopExperiencesArgs = {
  appIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  count?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryCategoryArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryModuleArgs = {
  discoveryCollectionSlug: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryModulesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  discoveryCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  tags?: Array<Scalars["ID"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoverySearchArgs = {
  query: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryTagArgs = {
  tag: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  discoveryCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryDmsFeedDataArgs = {
  feedId: Scalars["ID"]["input"];
  postsLimit: Scalars["Int"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryDmsPostArgs = {
  includeReactions?: InputMaybe<Scalars["Boolean"]["input"]>;
  postId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryExperienceArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryExperienceIdsConnectedToProductArgs = {
  companyId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyId: Scalars["ID"]["input"];
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryFeedPostsArgs = {
  after?: InputMaybe<Scalars["BigInt"]["input"]>;
  afterId?: InputMaybe<Scalars["ID"]["input"]>;
  aroundId?: InputMaybe<Scalars["ID"]["input"]>;
  aroundTimestamp?: InputMaybe<Scalars["BigInt"]["input"]>;
  before?: InputMaybe<Scalars["BigInt"]["input"]>;
  beforeId?: InputMaybe<Scalars["ID"]["input"]>;
  direction?: InputMaybe<Direction>;
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  feedId?: InputMaybe<Scalars["ID"]["input"]>;
  feedType: FeedTypes;
  includeChildren?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeReactions?: InputMaybe<Scalars["Boolean"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  pinned?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryForumFeedArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryForumPostArgs = {
  postId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryLeaderboardArgs = {
  latestPaginationRank?: InputMaybe<Scalars["Int"]["input"]>;
  leaderboardType: LeaderboardTypes;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryLedgerAccountArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryLivestreamFeedArgs = {
  feedId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryMailingAddressesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryMarketplaceCategoriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  direction?: InputMaybe<Direction>;
  displayOnHomepage?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  level?: InputMaybe<Scalars["Int"]["input"]>;
  marketplaceCategoryType?: InputMaybe<MarketplaceCategoryTypes>;
  order?: InputMaybe<MarketplaceCategoryOrder>;
};

/** The root query field which every query must start with. */
export type PublicQueryMarketplaceCategoryArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryMuxAssetArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryMyDmsChannelsArgs = {
  before?: InputMaybe<Scalars["BigInt"]["input"]>;
  collectionIdentifier?: InputMaybe<Scalars["String"]["input"]>;
  direction?: InputMaybe<Direction>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
  sort?: InputMaybe<DmsChannelsSortTypes>;
  status?: InputMaybe<DmsFeedMemberStatuses>;
  type?: InputMaybe<DmsFeedTypes>;
};

/** The root query field which every query must start with. */
export type PublicQueryMyLeaderboardRankArgs = {
  leaderboardType: LeaderboardTypes;
  providedTargetPrefix?: InputMaybe<Scalars["String"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryNewAffiliateReferralsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryNotLoggedInReceiptArgs = {
  statementDescriptorCode: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryNotificationTopicsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  topicType: NotificationTopicTypes;
};

/** The root query field which every query must start with. */
export type PublicQueryOauthDetailsArgs = {
  clientId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPaymentMethodsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  currency?: InputMaybe<Currencies>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  ledgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPaymentTokensArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  broken?: InputMaybe<Scalars["Boolean"]["input"]>;
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  gatewayType: GatewayTypes;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPostChildrenArgs = {
  before?: InputMaybe<Scalars["BigInt"]["input"]>;
  feedId: Scalars["ID"]["input"];
  feedType: FeedTypes;
  includeReactions?: InputMaybe<Scalars["Boolean"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  postId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPostReactionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  feedId: Scalars["ID"]["input"];
  feedType: FeedTypes;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  postId: Scalars["ID"]["input"];
  reactionType: ReactionTypes;
  value?: InputMaybe<Scalars["String"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryProcessCheckoutStatusArgs = {
  jobId: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryProcessEntryStatusArgs = {
  jobId: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPromoCodeArgs = {
  code: Scalars["String"]["input"];
  directToConsumer?: InputMaybe<Scalars["Boolean"]["input"]>;
  planId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicAccessPassArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<AccessPassFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPublicBountiesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<BountyFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPublicBountyArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicCompanyArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicExperienceArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicLineItemArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicPlanArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  pageRoute?: InputMaybe<Scalars["String"]["input"]>;
  shortLink?: InputMaybe<Scalars["String"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPublicProductArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicQuickLinkArgs = {
  code: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicUserArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryPublicUsersArgs = {
  ids: Array<Scalars["ID"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryPurchaseableExperienceIdsArgs = {
  companyId: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryReceiptArgs = {
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryResolveAffiliateUserArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryResolveTrackingLinkArgs = {
  accessPassRoute?: InputMaybe<Scalars["String"]["input"]>;
  pageRoute?: InputMaybe<Scalars["String"]["input"]>;
  trackingLinkRoute: Scalars["String"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryResolveWhopFourRouteArgs = {
  accessPassRoute?: InputMaybe<Scalars["String"]["input"]>;
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  externalDomain?: InputMaybe<Scalars["String"]["input"]>;
  pageRoute?: InputMaybe<Scalars["String"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryReviewArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryStatsArgs = {
  config: StatsConfigInput;
};

/** The root query field which every query must start with. */
export type PublicQueryUniversalPostArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryUniversalPostsArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  afterCursor?: InputMaybe<Scalars["ID"]["input"]>;
  appId?: InputMaybe<Scalars["ID"]["input"]>;
  appIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  authorId?: InputMaybe<Scalars["ID"]["input"]>;
  beforeCursor?: InputMaybe<Scalars["ID"]["input"]>;
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  feedType: UniversalPostFeedTypes;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryUniversalSearchArgs = {
  query: Scalars["String"]["input"];
  resourceTypes?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** The root query field which every query must start with. */
export type PublicQueryUpdatedFeedEntitiesArgs = {
  after: Scalars["BigInt"]["input"];
  afterId?: InputMaybe<Scalars["ID"]["input"]>;
  collectionId?: InputMaybe<Scalars["ID"]["input"]>;
  entityType: EntityTypes;
  feedType: FeedTypes;
  includeOtherUsersReactions?: InputMaybe<Scalars["Boolean"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The root query field which every query must start with. */
export type PublicQueryUserArgs = {
  id: Scalars["ID"]["input"];
};

/** The root query field which every query must start with. */
export type PublicQueryVatIdArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  currency: Currencies;
};

/** An object representing a link used to transfer a membership. */
export type PublicQuickLink = {
  __typename?: "PublicQuickLink";
  /** The unique code for the quick link (usually a long number). */
  code: Scalars["String"]["output"];
  /** The ID of the quick link. */
  id: Scalars["ID"]["output"];
  /** Whether or not the transfer link is still in stock. */
  inStock: Scalars["Boolean"]["output"];
  /** The membership that the quick link is for. */
  membership: QuickLinkMembership;
};

/** An object representing a (sanitized) receipt of a membership. */
export type PublicReceipt = {
  __typename?: "PublicReceipt";
  /** The billing address of the user. */
  address?: Maybe<Address>;
  /** The billing reason */
  billingReason?: Maybe<Scalars["String"]["output"]>;
  /** The payment processor used to make this payment at checkout. */
  checkoutPaymentProcessor?: Maybe<PaymentProcessor>;
  /** The company that the receipt is for. */
  company?: Maybe<PublicCompany>;
  /** The datetime the receipt was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the payment. */
  currency?: Maybe<Currencies>;
  /** The error message, if any. */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** The final amount of this receipt. */
  finalAmount: Scalars["Float"]["output"];
  /** The formatted final amount of this receipt in its currency */
  formattedPrice?: Maybe<Scalars["String"]["output"]>;
  /** The receipt ID */
  id: Scalars["ID"]["output"];
  /** The reason this receipt is ineligible for a opening a resolution. */
  ineligibleForResolution?: Maybe<ResolutionIneligibilityReason>;
  /** The last 4 digits of the card used to make the payment. */
  last4?: Maybe<Scalars["String"]["output"]>;
  /** The line item attached to this receipt (if any). */
  lineItem?: Maybe<PublicLineItem>;
  /** The membership this receipt is for. */
  membership?: Maybe<ExtraPublicMembership>;
  /** The datetime the receipt was paid */
  paidAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The payment method used for the payment, if available. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Returns the type of payment method used for the payment, if available. Ex. klarna, affirm, card, cashapp */
  paymentMethodType?: Maybe<Scalars["String"]["output"]>;
  /** The payment processor used to make this payment. */
  paymentProcessor?: Maybe<ReceiptPaymentProcessor>;
  /** The payment token used for the payment, if available. */
  paymentToken?: Maybe<PaymentToken>;
  /** The raw final amount of this receipt in its currency */
  rawPrice?: Maybe<Scalars["String"]["output"]>;
  /** The statement descriptor code, if any. Ex. https://whop.com/pay/code */
  statementDescriptorCode?: Maybe<Scalars["String"]["output"]>;
  /** The current state of the receipt. */
  status?: Maybe<ReceiptStatus>;
  /** The wallet address of the user who made the payment. */
  walletAddress?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for PublicReceipt. */
export type PublicReceiptConnection = {
  __typename?: "PublicReceiptConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicReceiptEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicReceipt>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicReceiptEdge = {
  __typename?: "PublicReceiptEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicReceipt>;
};

/** An object representing a resolution case. */
export type PublicResolution = {
  __typename?: "PublicResolution";
  /** The company for the resolution */
  company?: Maybe<PublicCompany>;
  /** When the resolution was first created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether or not the customer appealed the resolution */
  customerAppealed: Scalars["Boolean"]["output"];
  /** The actions the customer can currently take for this resolution */
  customerResponseActions: Array<ResolutionCustomerResponses>;
  dueDate?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the object */
  id: Scalars["ID"]["output"];
  /** The issue type  */
  issue: ResolutionIssueTypes;
  /** The member for this resolution */
  member?: Maybe<ExtraPublicMember>;
  /** Whether or not the merchant appealed the resolution */
  merchantAppealed: Scalars["Boolean"]["output"];
  /** The actions the merchant can currently take for this resolution */
  merchantResponseActions: Array<ResolutionMerchantResponses>;
  /** The actions whop can currently take for this resolution */
  platformResponseActions: Array<ResolutionPlatformResponses>;
  /** The receipt for this resolution */
  receipt: PublicReceipt;
  /** The events for this resolution. */
  resolutionEvents: PublicResolutionEventConnection;
  /** The most recent status of the resolution */
  status: ResolutionStatuses;
  /**
   * The user for this resolution
   * @deprecated This type has been deprecated. Use userAccount instead.
   */
  user: PublicUser;
  /** The user account that performed the action. */
  userAccount: PublicProfileUser;
};

/** An object representing a resolution case. */
export type PublicResolutionResolutionEventsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicResolution. */
export type PublicResolutionConnection = {
  __typename?: "PublicResolutionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicResolutionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicResolution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicResolutionEdge = {
  __typename?: "PublicResolutionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicResolution>;
};

/** An object representing a resolution case. */
export type PublicResolutionEvent = {
  __typename?: "PublicResolutionEvent";
  /** The action taken for this event. */
  action: ResolutionActions;
  /** The attachment for this event. */
  attachments: AttachmentInterfaceConnection;
  /** When the resolution event was first created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The details for a resolution */
  details?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the object */
  id: Scalars["ID"]["output"];
  /** The type of reporter for this event. */
  reporterType: ResolutionReporters;
  /**
   * The files uploaded for this event.
   * @deprecated Use attachments instead
   */
  uploads: PublicResolutionEventUploadConnection;
  /** Should the customer see this event. */
  viewableByCustomer: Scalars["Boolean"]["output"];
  /** Should the merchant see this event. */
  viewableByMerchant: Scalars["Boolean"]["output"];
};

/** An object representing a resolution case. */
export type PublicResolutionEventAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a resolution case. */
export type PublicResolutionEventUploadsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for PublicResolutionEvent. */
export type PublicResolutionEventConnection = {
  __typename?: "PublicResolutionEventConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicResolutionEventEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicResolutionEvent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicResolutionEventEdge = {
  __typename?: "PublicResolutionEventEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicResolutionEvent>;
};

/** An object representing an upload for a resolution event. */
export type PublicResolutionEventUpload = {
  __typename?: "PublicResolutionEventUpload";
  /** When the resolution file upload was first created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The file for the object */
  data: Scalars["File"]["output"];
  /** The ID of the object */
  id: Scalars["ID"]["output"];
};

/** The connection type for PublicResolutionEventUpload. */
export type PublicResolutionEventUploadConnection = {
  __typename?: "PublicResolutionEventUploadConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicResolutionEventUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicResolutionEventUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicResolutionEventUploadEdge = {
  __typename?: "PublicResolutionEventUploadEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicResolutionEventUpload>;
};

/** A StripePayout */
export type PublicStripePayout = {
  __typename?: "PublicStripePayout";
  /** Amount of the withdrawal request. */
  amount: Scalars["Float"]["output"];
  /** When the payout will arrive in the bank account. */
  arrivalDate?: Maybe<Scalars["Timestamp"]["output"]>;
  /** When the withdrawal request was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the payout. */
  currency: Currencies;
  /** Internal ID of the withdrawal request. */
  id: Scalars["ID"]["output"];
  /** Method of the payout. */
  payoutMethod: StripePayoutMethods;
  /** Type of the payout. */
  payoutType: StripePayoutPayoutTypes;
  /** The statement descriptor of the payout. */
  statementDescriptor?: Maybe<Scalars["String"]["output"]>;
  /** Status of the payout. */
  status: StripePayoutStatuses;
  /** The external account used for the payout. */
  stripeExternalAccount?: Maybe<StripeExternalAccount>;
  /** The trace ID of the payout, if any. */
  traceId?: Maybe<Scalars["String"]["output"]>;
  /** The trace status of the payout, if any. */
  traceStatus?: Maybe<StripePayoutTraceStatuses>;
};

/** A public content reward submission object */
export type PublicSubmission = {
  __typename?: "PublicSubmission";
  /** The attachments for this submission */
  attachments: Array<AttachmentInterface>;
  /** The campaign associated with this submission */
  campaign: PublicCampaign;
  /** The public URL where this content is available */
  contentUrl: Scalars["String"]["output"];
  /** Timestamp of when the submission was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The estimated payout for this submission */
  estimatedPayout?: Maybe<Scalars["Float"]["output"]>;
  /**
   * The file attachments for the submission
   * @deprecated Use attachments instead
   */
  fileAttachments: FileAttachmentConnection;
  /** The estimated payout date for the first payout */
  firstPayoutEstimatedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The ID of the submission */
  id: Scalars["ID"]["output"];
  /** The platform to create this submission for */
  platform: ContentRewardsPlatform;
  /** The canonical URL for the post */
  platformPostCanonicalUrl?: Maybe<Scalars["String"]["output"]>;
  /** The text content of the post on the platform */
  platformPostTextContent?: Maybe<Scalars["String"]["output"]>;
  /** The title of the post on the platform */
  platformPostTitle?: Maybe<Scalars["String"]["output"]>;
  /** The reason for the rejection of the submission */
  rejectionReason?: Maybe<Scalars["String"]["output"]>;
  /** The status of the submission */
  status: ContentRewardsSubmissionStatus;
  /** The total comment count for this submission */
  totalCommentCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total like count for this submission */
  totalLikeCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total amount that has been paid out for this campaign in the campaign's currency. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign, normalized to USD. */
  totalPaidInUsd: Scalars["Float"]["output"];
  /** The total repost count for this submission */
  totalRepostCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total save count for this submission */
  totalSaveCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total share count for this submission */
  totalShareCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total view count for this submission */
  totalViewCount: Scalars["Int"]["output"];
  /** The user who created the submission */
  user: PublicProfileUser;
};

/** A public content reward submission object */
export type PublicSubmissionFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Information regarding a tracking link */
export type PublicTrackingLink = {
  __typename?: "PublicTrackingLink";
  /** The access pass associated with the tracking link */
  accessPass?: Maybe<PublicAccessPass>;
  /** The company of the tracking link */
  company: PublicCompany;
  /** The destination of the tracking link */
  destination: TrackingLinkDestination;
  /** The full URL of the tracking link */
  fullUrl: Scalars["String"]["output"];
  /** The internal ID of the tracking link */
  id: Scalars["ID"]["output"];
  /** The plan associated with the tracking link */
  plan?: Maybe<PublicPlan>;
  /** The route of the tracking link */
  route: Scalars["String"]["output"];
};

/** An object representing a (sanitized) user of the site. */
export type PublicUser = {
  __typename?: "PublicUser";
  /** The time at which the user was blocked by the current user. */
  blockedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** When the user was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The discord account id of the user's default Discord account. */
  discordAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The username of the user's default Discord account. */
  discordUsername?: Maybe<Scalars["String"]["output"]>;
  /** The discord username or a placeholder text for the user. */
  header: Scalars["String"]["output"];
  /** The internal ID of the user. */
  id: Scalars["ID"]["output"];
  /**
   * The Discord avatar image or a placeholder for the user.
   * @deprecated Use imageSrcset instead.
   */
  image: Scalars["String"]["output"];
  /** The name of the user from their Whop account. */
  name?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the user's profile picture */
  profilePic: Scalars["String"]["output"];
  /** The URL of the user's profile picture with specific size. */
  profilePicSrcset: ImgSrcset;
  /** The username of the user from their Whop account. */
  username?: Maybe<Scalars["String"]["output"]>;
};

/** An object representing a (sanitized) user of the site. */
export type PublicUserProfilePicSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** A withdrawal request. */
export type PublicWithdrawal = {
  __typename?: "PublicWithdrawal";
  /** Amount of the withdrawal request. */
  amount: Scalars["String"]["output"];
  /** When the withdrawal was approved. */
  approvedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether the withdrawal can be retried for payout. */
  canRetryPayout?: Maybe<Scalars["Boolean"]["output"]>;
  /** When the withdrawal request was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the withdrawal request. */
  currency: Currencies;
  /** Status of the withdrawal. */
  derivedStatus: WithdrawalStatus;
  /** Internal ID of the withdrawal request. */
  id: Scalars["ID"]["output"];
  /** The provider where the payout was made. */
  payoutMethod: WithdrawalMethods;
  /** The provider where the payout was made. */
  provider?: Maybe<WithdrawalProviders>;
  /** Reason why the withdrawal was denied, if it was denied. */
  reason?: Maybe<Scalars["String"]["output"]>;
  /** The speed of the withdrawal. */
  speed: WithdrawalSpeeds;
  /** Status of the withdrawal. */
  status: WithdrawalStatus;
  /** The StripePayout associated with this withdrawal, if any. */
  stripePayout?: Maybe<PublicStripePayout>;
  /** Timeline of the withdrawal. */
  timeline: Array<WithdrawalTimelineEvent>;
  /** The type of withdrawal. */
  withdrawalType: WithdrawalTypes;
};

/** The connection type for PublicWithdrawal. */
export type PublicWithdrawalConnection = {
  __typename?: "PublicWithdrawalConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PublicWithdrawalEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PublicWithdrawal>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type PublicWithdrawalEdge = {
  __typename?: "PublicWithdrawalEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<PublicWithdrawal>;
};

/** A sanitized version of a membership */
export type QuickLinkMembership = {
  __typename?: "QuickLinkMembership";
  /** The timestamp of when this membership expires. */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The membership ID */
  id: Scalars["ID"]["output"];
  /** The plan tied to this membership. */
  plan: PublicPlan;
  /** The timestamp of when this membership renews. */
  renewalPeriodEnd?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether or not the membership is in a valid status. */
  valid: Scalars["Boolean"]["output"];
};

/** The type of promo code used to discount a plan */
export enum RandomInvestigateBuckets {
  /** Brand New User */
  BrandNewUser = "brand_new_user",
  /** Creator With 1 Access Pass No Members */
  CreatorWith_1AccessPassNoMembers = "creator_with_1_access_pass_no_members",
  /** Creator With 1 Access Pass With Members */
  CreatorWith_1AccessPassWithMembers = "creator_with_1_access_pass_with_members",
  /** Creator With 3 Access Pass With Members */
  CreatorWith_3AccessPassWithMembers = "creator_with_3_access_pass_with_members",
  /** User With 1 Whop */
  UserWith_1Whop = "user_with_1_whop",
  /** User With 10 Whops */
  UserWith_10Whops = "user_with_10_whops",
  /** User With 20 Plus Whops */
  UserWith_20PlusWhops = "user_with_20_plus_whops",
}

/** A grouping of three products with numeric rank displayed. */
export type RankedList = DiscoveryModuleInterface & {
  __typename?: "RankedList";
  /** A product collection. */
  collection: DiscoveryCollection;
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** Autogenerated input type of RateAccessPass */
export type RateAccessPassInput = {
  /** The ID of the access pass to save/unsave */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The rating of the access pass */
  rating: DiscoverRating;
  /** The ID of the recommendation set. This is an external ID. */
  recommendationId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Represents a reaction to a feed post */
export type Reaction = BaseEntityInterface & {
  __typename?: "Reaction";
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The type of the card */
  entityType: EntityTypes;
  /** The ID of the feed this reaction belongs to */
  feedId: Scalars["ID"]["output"];
  /** The type of the feed (e.g., 'dms_feed') */
  feedType: FeedTypes;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The ID of the post this reaction belongs to */
  postId: Scalars["ID"]["output"];
  /** The type of the post (e.g., 'dms_post') */
  postType: PostTypes;
  /** The type of reaction (e.g., 'like', 'vote', 'view', 'emoji') */
  reactionType: ReactionTypes;
  /** The score of the reaction */
  score: Scalars["Int"]["output"];
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The user who reacted to the post */
  user: PublicProfileUser;
  /** The ID of the user who made this reaction */
  userId: Scalars["ID"]["output"];
  /** The value of the reaction (e.g., specific emoji) */
  value?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for Reaction. */
export type ReactionConnection = {
  __typename?: "ReactionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Represents a reaction count for a feed post */
export type ReactionCount = BaseEntityInterface & {
  __typename?: "ReactionCount";
  /** The time the entity was created (in milliseconds since Unix epoch) */
  createdAt: Scalars["BigInt"]["output"];
  /** The type of the card */
  entityType: EntityTypes;
  /** The unique identifier for the entity */
  id: Scalars["ID"]["output"];
  /** Whether the entity has been deleted */
  isDeleted: Scalars["Boolean"]["output"];
  /** The type of post */
  postType: PostTypes;
  /** The type of reaction */
  reactionType: ReactionTypes;
  /** The sort key for the entity */
  sortKey: Scalars["String"]["output"];
  /**
   * The total score of the reaction count
   * @deprecated Use total_score_v2 instead
   */
  totalScore: Scalars["Int"]["output"];
  /** The total score of the reaction count v2 */
  totalScoreV2: Scalars["BigInt"]["output"];
  /** The time the entity was last updated (in milliseconds since Unix epoch) */
  updatedAt: Scalars["BigInt"]["output"];
  /** The number of users who reacted */
  userCount: Scalars["Int"]["output"];
  /** The reaction that was used */
  value?: Maybe<Scalars["String"]["output"]>;
};

/** An edge in a connection. */
export type ReactionEdge = {
  __typename?: "ReactionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Reaction>;
};

/** Input for a reaction */
export type ReactionInput = {
  /** The ID of the feed this reaction belongs to */
  feedId: Scalars["ID"]["input"];
  /** The type of the feed this reaction belongs to */
  feedType: FeedTypes;
  /** The unique identifier for the reaction */
  id: Scalars["ID"]["input"];
  /** Whether the entity has been deleted */
  isDeleted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the post this reaction belongs to */
  postId: Scalars["ID"]["input"];
  /** The type of the post (e.g., 'dms_post') */
  postType: PostTypes;
  /** The type of reaction (e.g., 'like', 'vote', 'view', 'emoji') */
  reactionType: ReactionTypes;
  /** The score of the reaction */
  score: Scalars["Int"]["input"];
  /** The value of the reaction (e.g., specific emoji) */
  value: Scalars["String"]["input"];
};

/** The type of reactions */
export enum ReactionTypes {
  /** Emoji */
  Emoji = "emoji",
  /** Like */
  Like = "like",
  /** View */
  View = "view",
  /** Vote */
  Vote = "vote",
}

/** Autogenerated input type of ReassignOwnership */
export type ReassignOwnershipInput = {
  /** The authorized user to reassign ownership to. */
  authorizedUserId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a receipt for a membership. */
export type Receipt = {
  __typename?: "Receipt";
  /** The access pass attached to this receipt. */
  accessPass?: Maybe<AccessPass>;
  /** The billing address of the user. */
  address?: Maybe<Address>;
  /** How much the receipt is for after fees */
  amountAfterFees: Scalars["Float"]["output"];
  /** Whether this payment was auto refunded or not */
  autoRefunded: Scalars["Boolean"]["output"];
  /** The billing reason */
  billingReason?: Maybe<Scalars["String"]["output"]>;
  /** The type of card used as the payment method. */
  brand?: Maybe<Scalars["String"]["output"]>;
  /** The buyer fee amount. */
  buyerFeeAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The buyer fee percentage. */
  buyerFeePercentage?: Maybe<Scalars["Float"]["output"]>;
  /** Whether the charge was skipped because the price was too low. */
  chargeSkippedPriceTooLow: Scalars["Boolean"]["output"];
  /** The payment processor used to make this payment at checkout. */
  checkoutPaymentProcessor?: Maybe<PaymentProcessor>;
  /** The company for the receipt. */
  company?: Maybe<Company>;
  /** The datetime the receipt was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the payment. */
  currency?: Maybe<Currencies>;
  /** The dispute attached to this receipt (if any). */
  dispute?: Maybe<Dispute>;
  /** When an alert came in that this transaction will be disputed */
  disputeAlertedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The email of the user who made the payment. */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The error message, if any. */
  errorMessage?: Maybe<Scalars["String"]["output"]>;
  /** If the payment failed, the reason for the failure. */
  failureMessage?: Maybe<Scalars["String"]["output"]>;
  /** The fee applied to this payment. */
  fee?: Maybe<Scalars["Float"]["output"]>;
  /** The final amount of this receipt. */
  finalAmount: Scalars["Float"]["output"];
  /** The formatted final amount of this receipt in its currency */
  formattedPrice?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the payment is free. */
  free: Scalars["Boolean"]["output"];
  /** The friendly status of the receipt. */
  friendlyStatus: FriendlyReceiptStatus;
  /** The gas cost for the transaction. */
  gas?: Maybe<Scalars["Float"]["output"]>;
  /** The credit for the gas for the transaction. */
  gasCredit?: Maybe<Scalars["Boolean"]["output"]>;
  /** The header of the receipt. */
  header?: Maybe<Scalars["String"]["output"]>;
  /** The receipt ID */
  id: Scalars["ID"]["output"];
  /** The reason this receipt is ineligible for a opening a resolution. */
  ineligibleForResolution?: Maybe<ResolutionIneligibilityReason>;
  /** The last 4 digits of the card used to make the payment. */
  last4?: Maybe<Scalars["String"]["output"]>;
  /** The time of the last payment attempt. */
  lastPaymentAttempt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The line item attached to this receipt (if any). */
  lineItem?: Maybe<LineItem>;
  /** The member attached to this receipt. */
  member?: Maybe<CompanyMember>;
  /** The membership attached to this receipt. */
  membership?: Maybe<Membership>;
  /** The most recent charge on the receipt. */
  mostRecentCharge?: Maybe<Charge>;
  /** The most recent failed charge on the receipt. */
  mostRecentFailedCharge?: Maybe<Charge>;
  /** The time of the next schedule payment retry. */
  nextPaymentAttempt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The datetime the receipt was paid */
  paidAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The payment method used for the payment, if available. */
  paymentMethod?: Maybe<PaymentMethod>;
  /** Returns the type of payment method used for the payment, if available. Ex. klarna, affirm, card, cashapp */
  paymentMethodType?: Maybe<Scalars["String"]["output"]>;
  /** The time of the payment payout release, if applicable. */
  paymentPayoutReleaseAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The payment processor used to make this payment. */
  paymentProcessor?: Maybe<ReceiptPaymentProcessor>;
  /** The payment token used for the payment, if available. */
  paymentToken?: Maybe<PaymentToken>;
  /** The number of failed payment attempts for the receipt. */
  paymentsFailed?: Maybe<Scalars["Int"]["output"]>;
  /** The plan attached to this receipt. */
  plan?: Maybe<Plan>;
  /** The final amount to show to the creator (excluding buyer fees). */
  presentedFinalAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The settled amount in USD to show to the creator. */
  presentedSettledUsdAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The subtotal to show to the creator (excluding buyer fees). */
  presentedSubtotal?: Maybe<Scalars["Float"]["output"]>;
  /** The tax amount to show to the creator (excluding buyer fees). */
  presentedTaxAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The total to show to the creator (excluding buyer fees). */
  presentedTotal?: Maybe<Scalars["Float"]["output"]>;
  /** The total in USD to show to the creator (excluding buyer fees). */
  presentedTotalUsdAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The raw final amount of this receipt in its currency */
  rawPrice?: Maybe<Scalars["String"]["output"]>;
  /** The fees associated with this specific payment. */
  receiptFees: Array<Fee>;
  /** Whether the payment can be refunded. */
  refundable: Scalars["Boolean"]["output"];
  /** The payment refund amount(if applicable). */
  refundedAmount?: Maybe<Scalars["Float"]["output"]>;
  /** When the payment was refunded (if applicable). */
  refundedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The refunds attached to this receipt. */
  refunds: RefundConnection;
  /**
   * The resolution attached to this receipt (if any).
   * @deprecated Use resolutions instead
   */
  resolution?: Maybe<PublicResolution>;
  /** The resolutions attached to this receipt (if any). */
  resolutions: PublicResolutionConnection;
  /** Whether the payment can be retried. */
  retryable: Scalars["Boolean"]["output"];
  /** The payment reversal amount (if applicable). */
  reversedAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The final converted amount of the receipt in USD. */
  settledUsdAmount?: Maybe<Scalars["Float"]["output"]>;
  /** Whether or not to show the amount after fees. */
  showAmountAfterFees: Scalars["Boolean"]["output"];
  /** The statement descriptor code, if any. Ex. https://whop.com/pay/code */
  statementDescriptorCode?: Maybe<Scalars["String"]["output"]>;
  /** The current state of the receipt. */
  status?: Maybe<ReceiptStatus>;
  /** The stripe id of the receipt. */
  stripeId?: Maybe<Scalars["String"]["output"]>;
  /** The subheader of the receipt. */
  subheader?: Maybe<Scalars["String"]["output"]>;
  /** The subtotal of the payment amount. */
  subtotal?: Maybe<Scalars["Float"]["output"]>;
  /** The calculated amount of the sales/VAT tax (if applicable). */
  taxAmount?: Maybe<Scalars["Float"]["output"]>;
  /** Geographic location (country) of the applicable tax. */
  taxCountry?: Maybe<Scalars["String"]["output"]>;
  /** Geographic jurisdiction of the applicable tax. */
  taxJurisdiction?: Maybe<Scalars["String"]["output"]>;
  /** The percentage of the sales/VAT tax (if applicable). */
  taxPercentage?: Maybe<Scalars["Float"]["output"]>;
  /** Geographic location (state) of the applicable tax. */
  taxState?: Maybe<Scalars["String"]["output"]>;
  /** The type of tax being applied to the payment. */
  taxType?: Maybe<Scalars["String"]["output"]>;
  /** The total of the payment amount. */
  total?: Maybe<Scalars["Float"]["output"]>;
  /** The total deductions from the payment. */
  totalDeductions: Scalars["Float"]["output"];
  /** The total of the payment amount in USD. */
  totalUsdAmount?: Maybe<Scalars["Float"]["output"]>;
  /** The transaction id for a cryptocurrency payment. */
  txId?: Maybe<Scalars["String"]["output"]>;
  /** The wallet address of the user who made the payment. */
  walletAddress?: Maybe<Scalars["String"]["output"]>;
};

/** An object representing a receipt for a membership. */
export type ReceiptRefundsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a receipt for a membership. */
export type ReceiptResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Receipt. */
export type ReceiptConnection = {
  __typename?: "ReceiptConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReceiptEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Receipt>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReceiptEdge = {
  __typename?: "ReceiptEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Receipt>;
};

/** The status of the abuse report */
export enum ReceiptFeeTypes {
  /** Other Fee */
  OtherFee = "other_fee",
  /** Processing Fee */
  ProcessingFee = "processing_fee",
  /** Whop Fee */
  WhopFee = "whop_fee",
}

/** The payment processor of a receipt */
export enum ReceiptPaymentProcessor {
  /** Apple */
  Apple = "apple",
  /** Coinbase */
  Coinbase = "coinbase",
  /** Crypto */
  Crypto = "crypto",
  /** Free */
  Free = "free",
  /** Multi Psp */
  MultiPsp = "multi_psp",
  /** Nft */
  Nft = "nft",
  /** Paypal */
  Paypal = "paypal",
  /** Sezzle */
  Sezzle = "sezzle",
  /** Splitit */
  Splitit = "splitit",
  /** Stripe */
  Stripe = "stripe",
}

/** The status of a receipt */
export enum ReceiptStatus {
  /** Draft */
  Draft = "draft",
  /** Open */
  Open = "open",
  /** Paid */
  Paid = "paid",
  /** Pending */
  Pending = "pending",
  /** Uncollectible */
  Uncollectible = "uncollectible",
  /** Unresolved */
  Unresolved = "unresolved",
  /** Void */
  Void = "void",
}

/** The status of a receipt */
export enum ReceiptStatusV2 {
  Failed = "failed",
  PartiallyRefunded = "partially_refunded",
  PastDue = "past_due",
  Refunded = "refunded",
  Succeeded = "succeeded",
}

/** Values to filter receipts on */
export type ReceiptV2Filters = {
  /** A specific access pass. */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The billing reason for the payment */
  billingReasons?: InputMaybe<Array<BillingReasons>>;
  /** The currency of the payment. */
  currencies?: InputMaybe<Array<Currencies>>;
  /** Which way to order the results. */
  direction?: InputMaybe<Direction>;
  /** To get all memberships created before this certain time. */
  endDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** How to order the results. */
  order?: InputMaybe<ReceiptV2Order>;
  /** How the payment was made (method). */
  paymentMethods?: InputMaybe<Array<PaymentMethods>>;
  /** A specific plan. */
  planIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** To get all memberships created after this certain time. */
  startDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The state of the payment. */
  statuses?: InputMaybe<Array<ReceiptStatusV2>>;
};

/** The order to sort the results by. */
export enum ReceiptV2Order {
  CreatedAt = "created_at",
  FinalAmount = "final_amount",
  PaidAt = "paid_at",
}

/** Which columns can be used to sort. */
export enum ReceiptsSortableColumns {
  CreatedAt = "created_at",
  FinalAmount = "final_amount",
  Id = "id",
  PaidAt = "paid_at",
  PresentedFinalAmount = "presented_final_amount",
}

/** Represents a search query the user made. */
export type RecentSearch = {
  __typename?: "RecentSearch";
  /** The time the search query was made. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The internal ID of the search query. */
  id: Scalars["ID"]["output"];
  /** The search query. */
  query: Scalars["String"]["output"];
};

/** The connection type for RecentSearch. */
export type RecentSearchConnection = {
  __typename?: "RecentSearchConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RecentSearchEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RecentSearch>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RecentSearchEdge = {
  __typename?: "RecentSearchEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<RecentSearch>;
};

/** An object representing a report made on a resource. */
export type Refund = {
  __typename?: "Refund";
  /** The amount of the refund. */
  amount: Scalars["Float"]["output"];
  /** The time the refund was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The currency of the refund. */
  currency: Currencies;
  /** The ID of the refund. */
  id: Scalars["ID"]["output"];
  /** The provider of the refund. */
  provider: PaymentProviders;
  /** The time the refund was created by the provider. */
  providerCreatedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The status of the reference. */
  referenceStatus?: Maybe<Scalars["String"]["output"]>;
  /** The type of the reference. */
  referenceType?: Maybe<Scalars["String"]["output"]>;
  /** The value of the reference. */
  referenceValue?: Maybe<Scalars["String"]["output"]>;
  /** The status of the refund. */
  status: RefundStatuses;
};

/** The connection type for Refund. */
export type RefundConnection = {
  __typename?: "RefundConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RefundEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Refund>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RefundEdge = {
  __typename?: "RefundEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Refund>;
};

/** Autogenerated input type of RefundReceipt */
export type RefundReceiptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the payment/receipt you want to update or take action upon. */
  id: Scalars["ID"]["input"];
  /** refund_payment | An amount if the refund is supposed to be partial. */
  partialAmount?: InputMaybe<Scalars["Float"]["input"]>;
};

/** The different statuses for a Refund object */
export enum RefundStatuses {
  Canceled = "canceled",
  Failed = "failed",
  Pending = "pending",
  RequiresAction = "requires_action",
  Succeeded = "succeeded",
}

/** Autogenerated input type of RegisterCompany */
export type RegisterCompanyInput = {
  /** The route of the access pass being created. */
  accessPassRoute?: InputMaybe<Scalars["String"]["input"]>;
  /** The affiliate code of the user who is referring the company. */
  affiliateCode?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether the company is being created as an app. */
  asApp?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The type of company being created.
   * @deprecated No longer used
   */
  companyType?: InputMaybe<CompanyTypes>;
  /** The headline of the company being created. */
  headline?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal identifiers of the apps to automatically install */
  installAppInternalIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The marketplace category of the company being created. */
  marketplaceCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The onboarding version for this company. */
  onboardingVersion?: InputMaybe<AccessPassOnboardingVersionTypes>;
  /** Whether the company is participating in custom creator milestones. */
  participatingInCustomCreatorMilestones?: InputMaybe<
    Scalars["Boolean"]["input"]
  >;
  /** The details to assign an autogenerated plan. */
  planOptions?: InputMaybe<CompanyOnboardingPlanOptions>;
  /** The pricing type of the company being created. */
  pricingType?: InputMaybe<PricingOptions>;
  /** The referer of the site that the user came from */
  refererUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The social links of the company being created. */
  socialLinks?: InputMaybe<SocialLinkInput>;
  /** The id of the company template being used to create the new company. */
  templateCompanyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The name of the company being created. */
  title: Scalars["String"]["input"];
};

/** Autogenerated input type of RejectCreatorMilestone */
export type RejectCreatorMilestoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the creator milestone to reject */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of RejectSubmission */
export type RejectSubmissionInput = {
  /** Whether or not to ban the user. */
  banUser?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The reason for rejecting the submission */
  rejectionReason: Scalars["String"]["input"];
  /** The ID of the submission to reject */
  submissionId: Scalars["ID"]["input"];
};

/** The methods of how a plan can be released (including raffles and waitlists). */
export enum ReleaseMethod {
  /** Buy Now */
  BuyNow = "buy_now",
  /** Raffle */
  Raffle = "raffle",
  /** Waitlist */
  Waitlist = "waitlist",
}

/** Settings for a release method. */
export type ReleaseMethodSettings = {
  __typename?: "ReleaseMethodSettings";
  /** The timestamp the release method expires at */
  expiresAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The maximum number of entries allowed for the release method */
  maxEntries?: Maybe<Scalars["Int"]["output"]>;
  /** Whether the release method is weighted by how many NFTs someone holds */
  nftWeightedEntries?: Maybe<Scalars["Boolean"]["output"]>;
  /** The timestamp the release method starts at */
  startsAt?: Maybe<Scalars["Timestamp"]["output"]>;
};

export type ReleaseMethodSettingsInput = {
  /** When the raffle will expire */
  expiresAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The maximum number of entries allowed for the raffle or waitlist */
  maxEntries?: InputMaybe<Scalars["Int"]["input"]>;
  /** If this is enabled, the raffle will get entries based off of how many NFTs the user owns */
  nftWeightedEntries?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** When the raffle will start */
  startsAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
};

/** Autogenerated input type of RemoveEntry */
export type RemoveEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the entry to cancel. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of RemoveExperienceFromAccessPass */
export type RemoveExperienceFromAccessPassInput = {
  /** The ID of the Access Pass to add the Experience to. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Experience to be added to an Access Pass. */
  experienceId: Scalars["ID"]["input"];
};

/** Autogenerated input type of RemoveFcmToken */
export type RemoveFcmTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The FCM token to remove */
  fcmToken: Scalars["String"]["input"];
};

/** Autogenerated input type of RemoveMyAccount */
export type RemoveMyAccountInput = {
  /** Internal ID (tag) of the account to be removed */
  accountId: Scalars["ID"]["input"];
  /** The type of social account to remove. */
  accountType: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of RemovePhoneNumber */
export type RemovePhoneNumberInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of RemoveRedirectUri */
export type RemoveRedirectUriInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The URL */
  redirectUri: Scalars["String"]["input"];
};

/** The types of reports that can be generated. */
export enum ReportTypes {
  /** Bookmark */
  Bookmark = "bookmark",
  /** Downvote */
  Downvote = "downvote",
  /** Share */
  Share = "share",
  /** Upvote */
  Upvote = "upvote",
}

/** Autogenerated input type of RequestLedgerWithdrawal */
export type RequestLedgerWithdrawalInput = {
  /** The amount to withdraw */
  amount: Scalars["Float"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency that is being withdrawn. */
  currency: Currencies;
  /** The ledger account id to withdraw from */
  ledgerAccountId: Scalars["ID"]["input"];
};

/** Autogenerated input type of RequestToStand */
export type RequestToStandInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed id of the livestream */
  feedId: Scalars["ID"]["input"];
};

/** The different types of requirements that can be returned by the checkout requirements query. */
export enum RequirementIdentifiers {
  AppsNotAllowed = "apps_not_allowed",
  BlockedCountry = "blocked_country",
  CustomPassword = "custom_password",
  EmailRequired = "email_required",
  ExperiencesNotAllowed = "experiences_not_allowed",
  LineItemExpired = "line_item_expired",
  OneActiveAppInstallment = "one_active_app_installment",
  OwnershipOfAccessPasses = "ownership_of_access_passes",
  PhoneVerificationRequired = "phone_verification_required",
  PlanArchived = "plan_archived",
  PlanExpired = "plan_expired",
  PlanNotStarted = "plan_not_started",
  PlanOnePerCompany = "plan_one_per_company",
  PlanOnePerUser = "plan_one_per_user",
  ProductArchived = "product_archived",
  ProductOnePerUser = "product_one_per_user",
  PurchasesDisabled = "purchases_disabled",
  QuickLinkExpired = "quick_link_expired",
  QuickLinkOutOfStock = "quick_link_out_of_stock",
  UserBannedFromWhop = "user_banned_from_whop",
  UserSuspended = "user_suspended",
}

/** The different types of actions for a resolution event */
export enum ResolutionActions {
  /** Accepted */
  Accepted = "accepted",
  /** Appealed */
  Appealed = "appealed",
  /** Created */
  Created = "created",
  /** Denied */
  Denied = "denied",
  /** Dispute Customer Won */
  DisputeCustomerWon = "dispute_customer_won",
  /** Dispute Merchant Won */
  DisputeMerchantWon = "dispute_merchant_won",
  /** Dispute Opened */
  DisputeOpened = "dispute_opened",
  /** Escalated */
  Escalated = "escalated",
  /** Requested More Info */
  RequestedMoreInfo = "requested_more_info",
  /** Responded */
  Responded = "responded",
  /** Withdrew */
  Withdrew = "withdrew",
}

/** The types of responses a customer can make to a resolution. */
export enum ResolutionCustomerResponses {
  Appeal = "appeal",
  Respond = "respond",
  Withdraw = "withdraw",
}

/** Filters for the resolutions */
export type ResolutionFilters = {
  /** A specific access pass. */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** Filter by their case state */
  caseState?: InputMaybe<CaseStates>;
  /** The direction to filter */
  direction?: InputMaybe<Direction>;
  /** Filter by the end date */
  endDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The order to filter */
  order?: InputMaybe<ResolutionOrder>;
  /** How the payment was made (method). */
  paymentMethods?: InputMaybe<Array<PaymentMethods>>;
  /** The text to search by */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** Filter by the start date */
  startDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** Filter by their status */
  statuses?: InputMaybe<Array<ResolutionStatuses>>;
};

/** A reason why a specific receipt cannot have a resolution created. */
export enum ResolutionIneligibilityReason {
  AlreadyOpened = "already_opened",
  AlreadyRefunded = "already_refunded",
  Free = "free",
  NotPaid = "not_paid",
  OutOfDate = "out_of_date",
  UnsupportedPaymentProcessor = "unsupported_payment_processor",
}

/** The different types of issues a resolution can be */
export enum ResolutionIssueTypes {
  /** Forgot To Cancel */
  ForgotToCancel = "forgot_to_cancel",
  /** Item Not Received */
  ItemNotReceived = "item_not_received",
  /** Product Unacceptable */
  ProductUnacceptable = "product_unacceptable",
  /** Significantly Not As Described */
  SignificantlyNotAsDescribed = "significantly_not_as_described",
  /** Unauthorized Transaction */
  UnauthorizedTransaction = "unauthorized_transaction",
}

/** The types of responses a merchant can make to a resolution. */
export enum ResolutionMerchantResponses {
  Accept = "accept",
  Appeal = "appeal",
  Deny = "deny",
  RequestMoreInfo = "request_more_info",
  Respond = "respond",
}

/** Possible values to filter user on */
export enum ResolutionOrder {
  DueDate = "due_date",
  Id = "id",
}

/** The types of responses the platform can make to a resolution. */
export enum ResolutionPlatformResponses {
  MerchantRefund = "merchant_refund",
  MerchantWins = "merchant_wins",
  PlatformRefund = "platform_refund",
  RequestBuyerInfo = "request_buyer_info",
  RequestMerchantInfo = "request_merchant_info",
}

/** The different types of reporters for a resolution event */
export enum ResolutionReporters {
  /** Customer */
  Customer = "customer",
  /** Merchant */
  Merchant = "merchant",
  /** Platform */
  Platform = "platform",
  /** System */
  System = "system",
}

/** The statuses a resolution object can have */
export enum ResolutionStatuses {
  /** Customer Info Needed */
  CustomerInfoNeeded = "customer_info_needed",
  /** Customer Response Needed */
  CustomerResponseNeeded = "customer_response_needed",
  /** Customer Withdrew */
  CustomerWithdrew = "customer_withdrew",
  /** Customer Won */
  CustomerWon = "customer_won",
  /** Merchant Info Needed */
  MerchantInfoNeeded = "merchant_info_needed",
  /** Merchant Response Needed */
  MerchantResponseNeeded = "merchant_response_needed",
  /** Merchant Won */
  MerchantWon = "merchant_won",
  /** Under Platform Review */
  UnderPlatformReview = "under_platform_review",
}

/** Which columns can be used to sort. */
export enum ResolutionsSortableColumns {
  CreatedAt = "created_at",
  DueDate = "due_date",
  Id = "id",
}

/** Autogenerated input type of ResolveCoinbasePayment */
export type ResolveCoinbasePaymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the membership you want to resolve the payment for. */
  id: Scalars["ID"]["input"];
};

/** An object representing the path to an experience from an experience ID */
export type ResolvedMobileExperience = {
  __typename?: "ResolvedMobileExperience";
  /** The app tag for the experience */
  appTag: Scalars["String"]["output"];
  /** The name of the experience */
  experienceName: Scalars["String"]["output"];
  /** The link to the experience */
  iframeLink?: Maybe<Scalars["String"]["output"]>;
  /** Whether the user is an authorized user for the experience's company */
  isAuthorizedUser: Scalars["Boolean"]["output"];
};

/** The different reason codes. */
export enum RestrictionSetReasonCodes {
  BlockedCountry = "blocked_country",
}

/** Autogenerated input type of RetrieveChallengeResult */
export type RetrieveChallengeResultInput = {
  /** The ID of the Basis Theory 3DS session to retrieve the challenge result for. */
  basisTheory3dsSessionId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the payment token authentication to retrieve the challenge result for. */
  paymentTokenAuthenticationId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of RetryPastDuePayments */
export type RetryPastDuePaymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of RetryPaymentMyMembership */
export type RetryPaymentMyMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the membership to retry the payment for. */
  membershipId: Scalars["ID"]["input"];
};

/** Autogenerated input type of RetryPayout */
export type RetryPayoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ledger account id to withdraw from */
  ledgerAccountId: Scalars["ID"]["input"];
  /** The withdrawal id to retry the payout for */
  withdrawalId: Scalars["ID"]["input"];
};

/** An object representing a user review of a company. */
export type Review = {
  __typename?: "Review";
  /** The access pass the review is for. */
  accessPass: PublicAccessPass;
  /** The attachments attached to the review. */
  attachments: Array<AttachmentInterface>;
  /** The company the review is for. */
  company: PublicCompany;
  /** The timestamp of when the review was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The description of the review */
  description: Scalars["String"]["output"];
  /** Whether or not the review is featured on the marketplace. */
  featured: Scalars["Boolean"]["output"];
  /** The internal ID of the review. */
  id: Scalars["ID"]["output"];
  /**
   * The images attached to the review.
   * @deprecated Use attachments instead
   */
  images: Array<Image>;
  /** The timestamp of when the user joined the access pass. */
  joinedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** A list of all the reports made on this review by the current user. */
  myReports?: Maybe<Array<ReviewReport>>;
  /** Whether or not the user paid for the product. If null, the payment status is unknown. */
  paidForProduct?: Maybe<Scalars["Boolean"]["output"]>;
  /** The timestamp of when the review was published. */
  publishedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The number of replies the review has. */
  replyCount: Scalars["Int"]["output"];
  /** A list of all the reports made on this review. */
  reviewReports?: Maybe<ReviewReportV2Connection>;
  /** The number of stars the user gave the access pass. */
  stars: Scalars["Int"]["output"];
  /** The status of the review. */
  status: ReviewStatus;
  /** The title of the review */
  title?: Maybe<Scalars["String"]["output"]>;
  /** The timestamp of when the review was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
  /** The number of upvotes the review has. */
  upvotes: Scalars["Int"]["output"];
  /**
   * The user who wrote the review.
   * @deprecated This type has been deprecated. Use userAccount instead.
   */
  user: PublicUser;
  /** The user account that performed the action. */
  userAccount: PublicProfileUser;
  /** Whether or not a review was made by a Whop employee */
  whopReviewed: Scalars["Boolean"]["output"];
};

/** An object representing a user review of a company. */
export type ReviewReviewReportsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for Review. */
export type ReviewConnection = {
  __typename?: "ReviewConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Review>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReviewEdge = {
  __typename?: "ReviewEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Review>;
};

/** Filters for the reviews search */
export type ReviewFilters = {
  /** The direction to filter the reviews */
  direction?: InputMaybe<Direction>;
  /** The order to filter the reviews */
  order?: InputMaybe<ReviewOrder>;
  /** The text to search by */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** Filter reviews by star count */
  stars?: InputMaybe<Scalars["Int"]["input"]>;
  /** Filter reviews by the person who created the review */
  userId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Possible values to filter reviews on */
export enum ReviewOrder {
  CreatedAt = "created_at",
  Stars = "stars",
}

/** An object representing a report made on a review. */
export type ReviewReport = {
  __typename?: "ReviewReport";
  /** When the report was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The internal ID of the report. */
  id: Scalars["ID"]["output"];
  /** The type of report that was made. */
  reportType: ReportTypes;
  /** The review that the report is for. */
  review: Review;
  /** When the report was last updated. */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The status of a review report */
export enum ReviewReportStatus {
  /** Accepted */
  Accepted = "accepted",
  /** Pending */
  Pending = "pending",
  /** Rejected */
  Rejected = "rejected",
}

/** Information regarding a review report */
export type ReviewReportV2 = {
  __typename?: "ReviewReportV2";
  /** The attachments attached to the review report. */
  attachments: AttachmentInterfaceConnection;
  /** When the report was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /**
   * The files attached to the review report
   * @deprecated Use `attachments` instead.
   */
  fileAttachments: FileAttachmentConnection;
  /** The internal ID of the report. */
  id: Scalars["ID"]["output"];
  /** The reason for the report */
  reason: Scalars["String"]["output"];
  /** The review the report was made for */
  review: Review;
  /** The status of the report */
  status: ReviewReportStatus;
};

/** Information regarding a review report */
export type ReviewReportV2AttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Information regarding a review report */
export type ReviewReportV2FileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The connection type for ReviewReportV2. */
export type ReviewReportV2Connection = {
  __typename?: "ReviewReportV2Connection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReviewReportV2Edge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReviewReportV2>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type ReviewReportV2Edge = {
  __typename?: "ReviewReportV2Edge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<ReviewReportV2>;
};

/** The statuses a review can have */
export enum ReviewStatus {
  /** Pending */
  Pending = "pending",
  /** Published */
  Published = "published",
  /** Removed */
  Removed = "removed",
}

/** Which columns can be used to sort. */
export enum ReviewsSortableColumns {
  CreatedAt = "created_at",
  Id = "id",
  Stars = "stars",
}

/** Autogenerated input type of RevokeApiKey */
export type RevokeApiKeyInput = {
  /** The API key to revoke */
  apiKey: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of RevokeApiKeyV2 */
export type RevokeApiKeyV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the API key to revoke */
  id: Scalars["String"]["input"];
};

/** Autogenerated input type of RevokeOauthToken */
export type RevokeOauthTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The OAuth token to revoke */
  oauthToken: Scalars["String"]["input"];
};

/** The available reward units to choose from. */
export enum RewardUnits {
  /** Per Submission */
  PerSubmission = "per_submission",
  /** Per View */
  PerView = "per_view",
}

/** An RFI is a request for information belonging to a connected account. */
export type Rfi = {
  __typename?: "Rfi";
  /** The date and time the RFI is due. */
  currentDeadline?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The description of the RFI. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the RFI. */
  id: Scalars["ID"]["output"];
  /** The status of the RFI. */
  status: RfiStatuses;
};

/** The status of an RFI */
export enum RfiStatuses {
  /** Ignored */
  Ignored = "ignored",
  /** Pending Provider */
  PendingProvider = "pending_provider",
  /** Resolved */
  Resolved = "resolved",
  /** Waiting For Platform */
  WaitingForPlatform = "waiting_for_platform",
  /** Waiting For User */
  WaitingForUser = "waiting_for_user",
}

/** Represents an rsvp for an event */
export type Rsvp = {
  __typename?: "Rsvp";
  /** The date and time the rsvp was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The event that this rsvp is for */
  event: Event;
  /** The unique identifier of the rsvp */
  id: Scalars["ID"]["output"];
  /** The user that RSVPed */
  user: PublicProfileUser;
};

/** An experience activity card about an event rsvp */
export type RsvpCard = ExperienceActivityCardInterface & {
  __typename?: "RsvpCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The rsvp that this card is about */
  rsvp?: Maybe<Rsvp>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** The connection type for Rsvp. */
export type RsvpConnection = {
  __typename?: "RsvpConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RsvpEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Rsvp>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type RsvpEdge = {
  __typename?: "RsvpEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Rsvp>;
};

/** The level of security an account has */
export enum SecurityLevels {
  None = "none",
  TwoFactor = "two_factor",
}

/** Autogenerated input type of SendMessage */
export type SendMessageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the chat experience to send the message in. */
  experienceId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the feed to send to. */
  feedId?: InputMaybe<Scalars["String"]["input"]>;
  /** The type of the feed to send to. */
  feedType?: InputMaybe<FeedTypes>;
  /** The message to send. */
  message: Scalars["String"]["input"];
  /** The user to send the direct message to. */
  toUserId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of SendNoPaymentEmail */
export type SendNoPaymentEmailInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company to backtrack. biz_xxxxx */
  companyId: Scalars["ID"]["input"];
};

/** Autogenerated input type of SendPhoneCode */
export type SendPhoneCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A 10 digit phone number. */
  phone: Scalars["String"]["input"];
};

/** Autogenerated input type of SendWithdrawalPdf */
export type SendWithdrawalPdfInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ledger account id */
  ledgerAccountId: Scalars["ID"]["input"];
  /** The withdrawal id */
  withdrawalId: Scalars["ID"]["input"];
};

/** Autogenerated input type of SetNotificationPreference */
export type SetNotificationPreferenceInput = {
  /** The channel to set this preference for */
  channel?: InputMaybe<NotificationPreferenceChannel>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company to set this preference for */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the company team to set this preference for */
  companyTeamId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether the preference is enabled */
  enabled: Scalars["Boolean"]["input"];
  /** The ID of the experience to set this preference for */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the notification topic to set this preference for */
  notificationTopicId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Any additional data required for processing a Sezzle checkout. */
export type SezzleData = {
  __typename?: "SezzleData";
  /** The url for the Sezzle checkout session. */
  redirectUrl: Scalars["String"]["output"];
};

/** Autogenerated input type of ShuffleApiKey */
export type ShuffleApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the API key to reset */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of ShuffleOauthSecret */
export type ShuffleOauthSecretInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** The output of the sidebar */
export type SidebarOutput = {
  __typename?: "SidebarOutput";
  /** The current user's rank, if any */
  currentUserRank?: Maybe<Scalars["Int"]["output"]>;
  /** The current user's value, if any */
  currentUserValue?: Maybe<Scalars["Int"]["output"]>;
  /** The users */
  users: PublicProfileUserConnection;
};

/** The output of the sidebar */
export type SidebarOutputUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** The status of a simple notification preference */
export enum SimpleNotificationPreferenceStatus {
  /** Everything */
  Everything = "everything",
  /** Nothing */
  Nothing = "nothing",
  /** Only Mentions */
  OnlyMentions = "only_mentions",
}

/** Represents a social media account or external online presence. */
export type Social = {
  __typename?: "Social";
  /** The handle for the external source, if applicable. */
  handle: Scalars["String"]["output"];
  /** The URL for the icon for the external source, if applicable. */
  icon: Scalars["String"]["output"];
  /** The name of the platform for the external source. */
  platform: Scalars["String"]["output"];
  /** The URL for the external source, if applicable. */
  url: Scalars["String"]["output"];
  /** Whether or not the external source is verified. */
  verified: Scalars["Boolean"]["output"];
};

/** The social account of a user. */
export type SocialAccount = {
  __typename?: "SocialAccount";
  /** Whether or not the account is the default for its type. */
  default: Scalars["Boolean"]["output"];
  /** The permission scopes granted for the account. */
  scopes: Array<Scalars["String"]["output"]>;
  /** The name of the service provider. */
  service: Scalars["String"]["output"];
  /** The username of the account. */
  username: Scalars["String"]["output"];
};

/** A social link attached to a resource on the site. */
export type SocialLink = {
  __typename?: "SocialLink";
  /** The ID */
  id: Scalars["ID"]["output"];
  /** The URL */
  url: Scalars["String"]["output"];
  /** The website */
  website: SocialLinkWebsites;
};

export type SocialLinkInput = {
  /** The Discord lobby/waiting room URL for the company */
  discord?: InputMaybe<Scalars["String"]["input"]>;
  /** The Facebook handle for the company */
  facebook?: InputMaybe<Scalars["String"]["input"]>;
  /** The Instagram handle for the company */
  instagram?: InputMaybe<Scalars["String"]["input"]>;
  /** The LinkedIn handle for the company */
  linkedin?: InputMaybe<Scalars["String"]["input"]>;
  /** The TikTok handle for the company */
  tiktok?: InputMaybe<Scalars["String"]["input"]>;
  /** The Twitch handle for the company */
  twitch?: InputMaybe<Scalars["String"]["input"]>;
  /** The Twitter handle for the company */
  twitter?: InputMaybe<Scalars["String"]["input"]>;
  /** A personal or professional website for the company */
  website?: InputMaybe<Scalars["String"]["input"]>;
  /** The YouTube handle for the company */
  youtube?: InputMaybe<Scalars["String"]["input"]>;
};

/** The different websites you can have social links for */
export enum SocialLinkWebsites {
  Facebook = "facebook",
  Instagram = "instagram",
  Linkedin = "linkedin",
  Tiktok = "tiktok",
  Twitch = "twitch",
  Website = "website",
  X = "x",
  Youtube = "youtube",
}

/** A wheel spin */
export type Spin = {
  __typename?: "Spin";
  /** When the wheel spin was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the wheel spin */
  id: Scalars["ID"]["output"];
  /** The prize this spin is for */
  prize: Prize;
  /** The status of the wheel spin */
  status: Scalars["String"]["output"];
  /** The wheel this spin is for */
  wheel: Wheel;
};

/** An experience activity card about a wheel spin */
export type SpinCard = ExperienceActivityCardInterface & {
  __typename?: "SpinCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The wheel spin that this card is about */
  spin?: Maybe<Spin>;
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
};

/** Any additional data required for processing a Splitit checkout. */
export type SplititData = {
  __typename?: "SplititData";
  /** The url for the checkout session. */
  redirectUrl: Scalars["String"]["output"];
  /** The type of service used for the Splitit checkout. */
  serviceType?: Maybe<CheckoutServiceTypes>;
};

/** Autogenerated input type of StartEmailVerification */
export type StartEmailVerificationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** A list of all queryable stats. */
export type Stats = {
  __typename?: "Stats";
  /** Churn Rate measures the percentage of users who churned (stopped renewing their subscription) in a given period. It is calculated by dividing the number of churned users by the total number of users with an active subscription in the period. */
  statsChurnRate: ChartsDataNumberNoSum;
  /** Total number of users with an active subscription in a given period that did not renew it in the next period */
  statsChurnedUsers: ChartsDataNumberNoSum;
  /** Conversion Rate */
  statsConversionRate: ChartsDataNumberNoSum;
  /** Total number of conversions */
  statsConversions: ChartsDataNumber;
  /** Total number of new users that started a subscription in your whop */
  statsNewUsers: ChartsDataNumberNoSum;
  /** Conversion Rate on paid plans */
  statsPaidConversionRate: ChartsDataNumberNoSum;
  /** Total number of paid conversions */
  statsPaidConversions: ChartsDataNumber;
  /** Total number of storepage views with paid plans available */
  statsPaidStorepageViews: ChartsDataNumber;
  /** Quick Ratio measures user growth by dividing new and returning users by churned users. A ratio above 1 indicates net user growth (gaining more users than losing), while below 1 indicates net user loss (losing more users than gaining). */
  statsQuickRatio: ChartsDataNumberNoSum;
  /** Total number of users with an active subscription in a given period that were retained in the next period */
  statsRetainedUsers: ChartsDataNumberNoSum;
  /** Total number of storepage views */
  statsStorepageViews: ChartsDataNumber;
  /** Total time spent by users in your whop */
  statsTimeSpent: ChartsDataNumber;
  /** Final net earnings after deducting credit card processing fees, marketplace fees, money paid to affiliates, fees for opened disputes, money lost in disputes, money withheld to pay sales tax if applicable, and money refunded to customers. */
  statsTotalEarnings: ChartsDataNumber;
  /** Total number of users that spent time in your whop */
  statsUsersWithTimeSpent: ChartsDataNumberNoSum;
  /** Total number of users with an active subscription in the past that came back after churning */
  statsWonBackUsers: ChartsDataNumberNoSum;
};

/** The configuration for receipts stats query. */
export type StatsConfigInput = {
  /** The access pass ids to filter the data by. */
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The bot ids to filter the data by. */
  botIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The currency to use for the chart. */
  currency?: InputMaybe<Currencies>;
  /** Whether or not to filter data by direct to consumer or marketplace */
  directToConsumer?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The feed ids to filter the data by. */
  feedIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The start date to take into account. */
  from: Scalars["Timestamp"]["input"];
  /** The interval to group the data by. */
  interval?: InputMaybe<ChartIntervals>;
  /** The plan ids to filter the data by. */
  planIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  /** The time zone used for start of day calculations. */
  timeZone?: InputMaybe<Scalars["String"]["input"]>;
  /** The end date to take into account. */
  to: Scalars["Timestamp"]["input"];
  /** The week mode to group the data by. For details, look at https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#toweek */
  weekMode?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Statuses for resources */
export enum Status {
  Active = "active",
  Archived = "archived",
  Deleted = "deleted",
}

/** The available bounty statuses to choose from. */
export enum Statuses {
  /** Archived */
  Archived = "archived",
  /** Published */
  Published = "published",
}

/** A Stripe account. */
export type StripeAccount = {
  __typename?: "StripeAccount";
  /** The type of account (ex. custom, express, personal, or standard) */
  accountType: StripeAccountTypes;
  /** Whether or not the account can be deleted to restart the setup process */
  canDelete: Scalars["Boolean"]["output"];
  /** Whether the account is collecting tax or not. */
  collectTax: Scalars["Boolean"]["output"];
  /** The connected account for the stripe account, if it exists. */
  connectedAccount?: Maybe<ConnectedAccount>;
  /** Whether this is the default account. */
  defaultAccount: Scalars["Boolean"]["output"];
  /** The ID of the stripe account, internal */
  id: Scalars["ID"]["output"];
  /** The items that should be displayed for the express stripe account. */
  managementItems: Array<ManagementItems>;
  /** Whether or not the stripe account is the merchant of record for payments. */
  merchantOfRecord: Scalars["Boolean"]["output"];
  /** The type of account, either personal, express, standard, or whop_credit. */
  normalizedAccountType: NormalizedAccountTypes;
  /** Whether the account is setup or not. */
  setup: Scalars["Boolean"]["output"];
  /** Whether or not the Stripe account should see the tax settings toggle. */
  showTaxSettings: Scalars["Boolean"]["output"];
  /**
   * Whether or not to upsell the account to upgrade to Stripe standard or express
   * @deprecated No longer used
   */
  showUpsell: Scalars["Boolean"]["output"];
  /** Whether or not to show the verification modal for the account. */
  showVerification: Scalars["Boolean"]["output"];
  /** The status of the account to display on the card. */
  status: StripeAccountStatuses;
  /** The Id of the account (from stripe). Starts with acct_ */
  stripeId?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not Stripe tax has been enabled on the account */
  stripeTaxEnabled: Scalars["Boolean"]["output"];
  /** The tax type for the account, if it exists. */
  taxType: TaxTypes;
};

/** Statuses for stripe accounts */
export enum StripeAccountStatuses {
  Connected = "connected",
  DisabledByWhop = "disabled_by_whop",
  NeedsCompletion = "needs_completion",
  NeedsReauthorization = "needs_reauthorization",
  ReconnectApiKeys = "reconnect_api_keys",
  Rejected = "rejected",
  RequirementsNotMet = "requirements_not_met",
  UnderReview = "under_review",
}

/** Types of Stripe accounts */
export enum StripeAccountTypes {
  Connect = "connect",
  Custom = "custom",
  Express = "express",
  Personal = "personal",
  Standard = "standard",
}

/** Statuses for stripe accounts */
export enum StripeActionTypes {
  Payment = "payment",
  RequiresMicroDepositVerification = "requires_micro_deposit_verification",
  Setup = "setup",
  ThreeDSecure = "three_d_secure",
}

/** The different types of businesses a connected account can be */
export enum StripeBusinessTypes {
  /** Company */
  Company = "company",
  /** Corporation */
  Corporation = "corporation",
  /** Government Entity */
  GovernmentEntity = "government_entity",
  /** Individual */
  Individual = "individual",
  /** Llc */
  Llc = "llc",
  /** Non Profit */
  NonProfit = "non_profit",
  /** Sole Prop */
  SoleProp = "sole_prop",
}

/** The countries that support Stripe payments on the Whop platform */
export enum StripeCountries {
  Ae = "ae",
  At = "at",
  Au = "au",
  Be = "be",
  Bg = "bg",
  Ca = "ca",
  Ch = "ch",
  Cy = "cy",
  Cz = "cz",
  De = "de",
  Dk = "dk",
  Ee = "ee",
  Es = "es",
  Fi = "fi",
  Fr = "fr",
  Gb = "gb",
  Gi = "gi",
  Gr = "gr",
  Hk = "hk",
  Hr = "hr",
  Hu = "hu",
  Id = "id",
  Ie = "ie",
  In = "in",
  It = "it",
  Jp = "jp",
  Li = "li",
  Lt = "lt",
  Lu = "lu",
  Lv = "lv",
  Mt = "mt",
  Mx = "mx",
  Nl = "nl",
  No = "no",
  Nz = "nz",
  Ph = "ph",
  Pl = "pl",
  Pt = "pt",
  Ro = "ro",
  Se = "se",
  Sg = "sg",
  Si = "si",
  Sk = "sk",
  Th = "th",
  Us = "us",
}

/** The countries that support Stripe custom payments on the Whop platform */
export enum StripeCustomCountries {
  Ae = "ae",
  Ag = "ag",
  Al = "al",
  Am = "am",
  Ar = "ar",
  At = "at",
  Au = "au",
  Ba = "ba",
  Be = "be",
  Bg = "bg",
  Bh = "bh",
  Bo = "bo",
  Bs = "bs",
  Ca = "ca",
  Ch = "ch",
  Ci = "ci",
  Cl = "cl",
  Co = "co",
  Cr = "cr",
  Cy = "cy",
  Cz = "cz",
  De = "de",
  Dk = "dk",
  Do = "do",
  Ec = "ec",
  Ee = "ee",
  Eg = "eg",
  Es = "es",
  Et = "et",
  Fi = "fi",
  Fr = "fr",
  Gb = "gb",
  Gh = "gh",
  Gm = "gm",
  Gr = "gr",
  Gt = "gt",
  Gy = "gy",
  Hk = "hk",
  Hr = "hr",
  Id = "id",
  Ie = "ie",
  Il = "il",
  In = "in",
  Is = "is",
  It = "it",
  Jm = "jm",
  Jo = "jo",
  Jp = "jp",
  Ke = "ke",
  Kh = "kh",
  Kr = "kr",
  Kw = "kw",
  Lc = "lc",
  Li = "li",
  Lk = "lk",
  Lt = "lt",
  Lu = "lu",
  Lv = "lv",
  Ma = "ma",
  Md = "md",
  Mg = "mg",
  Mk = "mk",
  Mn = "mn",
  Mo = "mo",
  Mt = "mt",
  Mu = "mu",
  Mx = "mx",
  My = "my",
  Na = "na",
  Ne = "ne",
  Ng = "ng",
  Nl = "nl",
  No = "no",
  Nz = "nz",
  Om = "om",
  Pa = "pa",
  Pe = "pe",
  Ph = "ph",
  Pk = "pk",
  Pl = "pl",
  Pt = "pt",
  Py = "py",
  Qa = "qa",
  Ro = "ro",
  Rs = "rs",
  Rw = "rw",
  Sa = "sa",
  Se = "se",
  Sg = "sg",
  Si = "si",
  Sk = "sk",
  Sn = "sn",
  Sv = "sv",
  Th = "th",
  Tn = "tn",
  Tr = "tr",
  Tt = "tt",
  Tz = "tz",
  Us = "us",
  Uy = "uy",
  Uz = "uz",
  Vn = "vn",
  Za = "za",
}

/** Any additional data required for processing a Stripe checkout. */
export type StripeData = {
  __typename?: "StripeData";
  /** The type of action to be performed. */
  actionType: StripeActionTypes;
  /** This is present if the user needs to confirm the 3DS payment on Stripe. ONLY USE THIS DATA IF REQUIRES_ACTION IS TRUE */
  clientSecret?: Maybe<Scalars["String"]["output"]>;
  /** This is present if the user needs to confirm the 3DS payment on Stripe. ONLY USE THIS DATA IF REQUIRES_ACTION IS TRUE */
  paymentIntentId?: Maybe<Scalars["String"]["output"]>;
};

/** The countries that support Stripe payments on the Whop platform and are located in the EU */
export enum StripeEuCountries {
  At = "at",
  Be = "be",
  Bg = "bg",
  Cy = "cy",
  Cz = "cz",
  De = "de",
  Dk = "dk",
  Ee = "ee",
  Es = "es",
  Fi = "fi",
  Fr = "fr",
  Gr = "gr",
  Hr = "hr",
  Hu = "hu",
  Ie = "ie",
  It = "it",
  Li = "li",
  Lt = "lt",
  Lu = "lu",
  Lv = "lv",
  Mt = "mt",
  Nl = "nl",
  No = "no",
  Pl = "pl",
  Pt = "pt",
  Ro = "ro",
  Se = "se",
  Si = "si",
  Sk = "sk",
}

/** An external account used for payouts attached to a connected account. */
export type StripeExternalAccount = {
  __typename?: "StripeExternalAccount";
  /** The name of the account holder. */
  accountHolderName?: Maybe<Scalars["String"]["output"]>;
  /** The type of account holder. */
  accountHolderType?: Maybe<Scalars["String"]["output"]>;
  /** The type of account. */
  accountType?: Maybe<Scalars["String"]["output"]>;
  /** The available payout methods for the account. */
  availablePayoutMethods?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The name of the bank. */
  bankName?: Maybe<Scalars["String"]["output"]>;
  /** The country of the account. */
  country: Scalars["String"]["output"];
  /** The currency of the account. */
  currency: Currencies;
  /** Whether or not the account is the default for the currency. */
  defaultForCurrency: Scalars["Boolean"]["output"];
  /** The fingerprint of the account. */
  fingerprint: Scalars["String"]["output"];
  /** The ID of the stripe account, internal */
  id: Scalars["ID"]["output"];
  /** The last 4 digits of the account. */
  last4: Scalars["String"]["output"];
  /** The routing number of the account. */
  routingNumber?: Maybe<Scalars["String"]["output"]>;
  /** The status of the account. */
  status: StripeExternalAccountStatuses;
};

/** The status that an external payout account can have */
export enum StripeExternalAccountStatuses {
  /** Errored */
  Errored = "errored",
  /** New */
  New = "new",
  /** Validated */
  Validated = "validated",
  /** Verification Failed */
  VerificationFailed = "verification_failed",
  /** Verified */
  Verified = "verified",
}

/** Autogenerated input type of StripeOauthV2 */
export type StripeOauthV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The OAuth code */
  code: Scalars["String"]["input"];
};

/** The methods that a StripePayout can have */
export enum StripePayoutMethods {
  /** Instant */
  Instant = "instant",
  /** Standard */
  Standard = "standard",
}

/** The payout types that a StripePayout can have */
export enum StripePayoutPayoutTypes {
  /** Bank Account */
  BankAccount = "bank_account",
  /** Card */
  Card = "card",
}

/** The status that a StripePayout can have */
export enum StripePayoutStatuses {
  /** Canceled */
  Canceled = "canceled",
  /** Failed */
  Failed = "failed",
  /** In Transit */
  InTransit = "in_transit",
  /** Paid */
  Paid = "paid",
  /** Pending */
  Pending = "pending",
}

/** The status that a StripePayout's trace can have */
export enum StripePayoutTraceStatuses {
  /** Pending */
  Pending = "pending",
  /** Supported */
  Supported = "supported",
  /** Unsupported */
  Unsupported = "unsupported",
}

/** A content reward submission object */
export type Submission = {
  __typename?: "Submission";
  /** The attachments for this submission */
  attachments: Array<AttachmentInterface>;
  /** The time at which the submission was automatically approved, if any. */
  autoApprovedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The time at which the submission was automatically rejected, if any. */
  autoRejectedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The time at which the post for this submission was deemed broken, if any. */
  brokenAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The campaign associated with this submission */
  campaign: PublicCampaign;
  /** The public URL where this content is available */
  contentUrl: Scalars["String"]["output"];
  /** Timestamp of when the submission was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The estimated payout for this submission */
  estimatedPayout?: Maybe<Scalars["Float"]["output"]>;
  /** The number of consecutive failures when trying to retrieve post data. */
  failureCount: Scalars["Int"]["output"];
  /**
   * The file attachments for the submission
   * @deprecated Use attachments instead
   */
  fileAttachments: FileAttachmentConnection;
  /** The estimated payout date for the first payout */
  firstPayoutEstimatedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether or not this submission has a pending flag */
  hasPendingFlag: Scalars["Boolean"]["output"];
  /** The ID of the submission */
  id: Scalars["ID"]["output"];
  /** The last time this submission was approved, if any. */
  lastApprovedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The last time this submission was flagged, if any. */
  lastFlaggedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The last time this submission was rejected, if any. */
  lastRejectedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The platform to create this submission for */
  platform: ContentRewardsPlatform;
  /** The canonical URL for the post */
  platformPostCanonicalUrl?: Maybe<Scalars["String"]["output"]>;
  /** The text content of the post on the platform */
  platformPostTextContent?: Maybe<Scalars["String"]["output"]>;
  /** The title of the post on the platform */
  platformPostTitle?: Maybe<Scalars["String"]["output"]>;
  /** The reason for the rejection of the submission */
  rejectionReason?: Maybe<Scalars["String"]["output"]>;
  /** The status of the submission */
  status: ContentRewardsSubmissionStatus;
  /** The flags for this submission. */
  submissionFlags: ContentRewardsSubmissionFlagConnection;
  /** The total comment count for this submission */
  totalCommentCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total like count for this submission */
  totalLikeCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total amount that has been paid out for this campaign in the campaign's currency. */
  totalPaid: Scalars["Float"]["output"];
  /** The total amount that has been paid out for this campaign, normalized to USD. */
  totalPaidInUsd: Scalars["Float"]["output"];
  /** The total repost count for this submission */
  totalRepostCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total save count for this submission */
  totalSaveCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total share count for this submission */
  totalShareCount?: Maybe<Scalars["Int"]["output"]>;
  /** The total view count for this submission */
  totalViewCount: Scalars["Int"]["output"];
  /** The charts for the content rewards app. */
  totalViewsChart: TotalSubmissionViewsChart;
  /** The user who created the submission */
  user: PublicProfileUser;
  /** The result of the video analysis */
  videoAnalysisResult: ContentRewardsSubmissionAnalysisResults;
};

/** A content reward submission object */
export type SubmissionFileAttachmentsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A content reward submission object */
export type SubmissionSubmissionFlagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  isApproved?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  reason?: InputMaybe<ContentRewardsSubmissionFlagReasons>;
};

/** A content reward submission object */
export type SubmissionTotalViewsChartArgs = {
  config: ContentRewardsSubmissionViewsChartConfigInput;
};

/** The connection type for Submission. */
export type SubmissionConnection = {
  __typename?: "SubmissionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type SubmissionEdge = {
  __typename?: "SubmissionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Submission>;
};

/** Autogenerated input type of SubmitAllPaymentDisputes */
export type SubmitAllPaymentDisputesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of SubmitPaymentDispute */
export type SubmitPaymentDisputeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the dispute you want to submit evidence for. */
  id: Scalars["ID"]["input"];
};

export type SupportAddressInput = {
  /** The city of the address */
  city?: InputMaybe<Scalars["String"]["input"]>;
  /** The country of the address */
  country?: InputMaybe<Scalars["String"]["input"]>;
  /** The first line of the address */
  line1?: InputMaybe<Scalars["String"]["input"]>;
  /** The second line of the address */
  line2?: InputMaybe<Scalars["String"]["input"]>;
  /** The postal code of the address */
  postalCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of the address */
  state?: InputMaybe<Scalars["String"]["input"]>;
};

/** The currencies that are currently eligible to be used with plans on the platform */
export enum SupportedCurrencies {
  Aed = "aed",
  All = "all",
  Amd = "amd",
  Ars = "ars",
  Aud = "aud",
  Bam = "bam",
  Bgn = "bgn",
  Bhd = "bhd",
  Bob = "bob",
  Brl = "brl",
  Bsd = "bsd",
  Cad = "cad",
  Chf = "chf",
  Clp = "clp",
  Cop = "cop",
  Crc = "crc",
  Czk = "czk",
  Dkk = "dkk",
  Dop = "dop",
  Dzd = "dzd",
  Egp = "egp",
  Etb = "etb",
  Eur = "eur",
  Gbp = "gbp",
  Ghs = "ghs",
  Gmd = "gmd",
  Gtq = "gtq",
  Gyd = "gyd",
  Hkd = "hkd",
  Huf = "huf",
  Idr = "idr",
  Ils = "ils",
  Inr = "inr",
  Jmd = "jmd",
  Jod = "jod",
  Jpy = "jpy",
  Kes = "kes",
  Khr = "khr",
  Krw = "krw",
  Kwd = "kwd",
  Lkr = "lkr",
  Mad = "mad",
  Mdl = "mdl",
  Mga = "mga",
  Mkd = "mkd",
  Mnt = "mnt",
  Mop = "mop",
  Mur = "mur",
  Mxn = "mxn",
  Myr = "myr",
  Nad = "nad",
  Ngn = "ngn",
  Nok = "nok",
  Nzd = "nzd",
  Omr = "omr",
  Pen = "pen",
  Php = "php",
  Pkr = "pkr",
  Pln = "pln",
  Pyg = "pyg",
  Qar = "qar",
  Ron = "ron",
  Rsd = "rsd",
  Rub = "rub",
  Rwf = "rwf",
  Sar = "sar",
  Sek = "sek",
  Sgd = "sgd",
  Thb = "thb",
  Tnd = "tnd",
  Try = "try",
  Ttd = "ttd",
  Twd = "twd",
  Tzs = "tzs",
  Usd = "usd",
  Uyu = "uyu",
  Uzs = "uzs",
  Vnd = "vnd",
  Xcd = "xcd",
  Xof = "xof",
  Zar = "zar",
}

/** Represents a sync error */
export type SyncError = {
  __typename?: "SyncError";
  /** The error message */
  message: Scalars["String"]["output"];
};

/** An object representing a filter for a table. */
export type TableFilter = {
  __typename?: "TableFilter";
  /** The argument of the filter. */
  argument: Scalars["String"]["output"];
  /** The options of the filter. */
  options: Array<TableFilterOption>;
  /** The title of the filter. */
  title: Scalars["String"]["output"];
  /** The type of the filter. */
  type: Scalars["String"]["output"];
  /** Whether the filter is visible. */
  visible: Scalars["Boolean"]["output"];
};

/** An object representing a filter for a table. */
export type TableFilterOption = {
  __typename?: "TableFilterOption";
  /** The argument of the option. */
  argument?: Maybe<Scalars["String"]["output"]>;
  /** The count of the option. */
  count?: Maybe<Scalars["Int"]["output"]>;
  /** The description of the option. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The options of the option. */
  options?: Maybe<Array<TableFilterOption>>;
  /** The showOn of the option. */
  showOn?: Maybe<Scalars["String"]["output"]>;
  /** The title of the option. */
  title: Scalars["String"]["output"];
  /** The value of the option. */
  value: Scalars["String"]["output"];
};

/** The names of tables that can have filters pulled. */
export enum TableNamesV2 {
  AccessPasses = "access_passes",
  Affiliates = "affiliates",
  AuditLogs = "audit_logs",
  CancelationReasons = "cancelation_reasons",
  CheckoutLinks = "checkout_links",
  CompanyCollabs = "company_collabs",
  ContentRewardsSubmissions = "content_rewards_submissions",
  CreditTransactionTransfers = "credit_transaction_transfers",
  Disputes = "disputes",
  Entries = "entries",
  Leads = "leads",
  Members = "members",
  Memberships = "memberships",
  Payments = "payments",
  Plans = "plans",
  PromoCodes = "promo_codes",
  Raffles = "raffles",
  Resolutions = "resolutions",
  Reviews = "reviews",
  TrackingLinks = "tracking_links",
  Withdrawals = "withdrawals",
}

/** Whether or not the tax is included in a plan's price (or if it hasn't been set up) */
export enum TaxTypes {
  /** Tax is exclusive in the price of the plan. If its $20 before tax, its $25 after tax. The user is paying tax */
  Exclusive = "exclusive",
  /** Tax is inclusive in the price of the plan. If its $20, its $20. The company already factored in tax and is paying tax */
  Inclusive = "inclusive",
  /** The company hasn't set up tax yet */
  Unspecified = "unspecified",
}

/** Information regarding a Telegram Account */
export type TelegramAccount = {
  __typename?: "TelegramAccount";
  /** The timestamp of when the account was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The internal ID of the Telegram Account */
  id: Scalars["ID"]["output"];
  /** The Telegram ID for this account */
  telegramAccountId: Scalars["String"]["output"];
  /** The Telegram first name for this account */
  telegramFirstName?: Maybe<Scalars["String"]["output"]>;
  /** The Telegram last name for this account */
  telegramLastName?: Maybe<Scalars["String"]["output"]>;
  /** The Telegram username for this account */
  telegramUsername?: Maybe<Scalars["String"]["output"]>;
};

/** The connection type for TelegramAccount. */
export type TelegramAccountConnection = {
  __typename?: "TelegramAccountConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TelegramAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TelegramAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type TelegramAccountEdge = {
  __typename?: "TelegramAccountEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TelegramAccount>;
};

/** Information regarding available telegram channels for a company */
export type TelegramChannel = {
  __typename?: "TelegramChannel";
  /** The date and time the telegram channel was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the telegram channel */
  telegramChannelId: Scalars["String"]["output"];
  /** The name of the telegram channel */
  telegramChannelName: Scalars["String"]["output"];
  /** The date and time the telegram channel was last updated */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The connection type for TelegramChannel. */
export type TelegramChannelConnection = {
  __typename?: "TelegramChannelConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TelegramChannelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TelegramChannel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type TelegramChannelEdge = {
  __typename?: "TelegramChannelEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TelegramChannel>;
};

/** Autogenerated input type of TerminateMyMembership */
export type TerminateMyMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The internal ID of the membership to terminate. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of TestWebhookV2 */
export type TestWebhookV2Input = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The event to test the webhook for. */
  event: WebhookEvent;
  /** The ID of the webhook to test. */
  id: Scalars["ID"]["input"];
};

/** A grouping of three products. */
export type ThreeItemList = DiscoveryModuleInterface & {
  __typename?: "ThreeItemList";
  /** A product collection. */
  collection: DiscoveryCollection;
  /** The type of this module. */
  moduleType: DiscoveryModuleTypes;
};

/** Information regarding the time spent on an access pass */
export type TimeSpentAccessPass = {
  __typename?: "TimeSpentAccessPass";
  /** The access pass */
  accessPass: PublicAccessPass;
  /** The time spent in seconds */
  timeSpentInSeconds: Scalars["Int"]["output"];
};

/** Information regarding the time spent on an experience */
export type TimeSpentExperience = {
  __typename?: "TimeSpentExperience";
  /** The experience */
  experience: PublicExperience;
  /** The time spent in seconds */
  timeSpentInSeconds: Scalars["Int"]["output"];
};

/** Autogenerated input type of ToggleCancelMyMembership */
export type ToggleCancelMyMembershipInput = {
  /** A multiple choice selection for why the user canceled. */
  cancelOption?: InputMaybe<CancelOptions>;
  /** The custom input from the user for canceling the membership. */
  cancelationReason?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the membership to cancel at the end of the period. */
  membershipId: Scalars["ID"]["input"];
};

/** Whether this flow is for the company or the user. This is how we determine which notification topics to create upon user creation. */
export enum Topic {
  /** Company */
  Company = "company",
  /** Company Team */
  CompanyTeam = "company_team",
  /** User */
  User = "user",
}

/** A chart of total views for a content rewards submission */
export type TotalSubmissionViewsChart = {
  __typename?: "TotalSubmissionViewsChart";
  /** Total comments over time. */
  totalComments: CreatorDashboardChartsDataNumber;
  /** Total engagement over time. */
  totalEngagement: CreatorDashboardChartsDataNumber;
  /** Total likes over time. */
  totalLikes: CreatorDashboardChartsDataNumber;
  /** Total reposts over time. */
  totalReposts: CreatorDashboardChartsDataNumber;
  /** Total saves over time. */
  totalSaves: CreatorDashboardChartsDataNumber;
  /** Total shares over time. */
  totalShares: CreatorDashboardChartsDataNumber;
  /** Total views over time. */
  totalViews: CreatorDashboardChartsDataNumber;
};

/** Information regarding a tracking link */
export type TrackingLink = {
  __typename?: "TrackingLink";
  /** The access pass associated with the tracking link */
  accessPass?: Maybe<PublicAccessPass>;
  /** The channel of the tracking link */
  channel: Scalars["String"]["output"];
  /** The number of clicks on the tracking link */
  clicks: Scalars["Int"]["output"];
  /** The company of the tracking link */
  company: PublicCompany;
  /** The conversion rate of the tracking link */
  conversionRate: Scalars["Float"]["output"];
  /** The number of users who converted from the tracking link */
  convertedUsers: Scalars["Int"]["output"];
  /** The date and time the tracking link was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The destination of the tracking link */
  destination: TrackingLinkDestination;
  /** The full URL of the tracking link */
  fullUrl: Scalars["String"]["output"];
  /** The internal ID of the tracking link */
  id: Scalars["ID"]["output"];
  /** The name of the tracking link */
  name: Scalars["String"]["output"];
  /** The plan associated with the tracking link */
  plan?: Maybe<PublicPlan>;
  /** The revenue generated from the tracking link */
  revenueGenerated: Scalars["Float"]["output"];
  /** The route of the tracking link */
  route: Scalars["String"]["output"];
};

/** The connection type for TrackingLink. */
export type TrackingLinkConnection = {
  __typename?: "TrackingLinkConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TrackingLinkEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TrackingLink>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** The destination of the custom link */
export enum TrackingLinkDestination {
  /** Access Pass Page */
  AccessPassPage = "access_pass_page",
  /** Bot Page */
  BotPage = "bot_page",
  /** Checkout Page */
  CheckoutPage = "checkout_page",
}

/** An edge in a connection. */
export type TrackingLinkEdge = {
  __typename?: "TrackingLinkEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TrackingLink>;
};

/** Which columns can be used to sort. */
export enum TrackingLinksSortableColumns {
  Clicks = "clicks",
  ConversionRate = "conversion_rate",
  ConvertedUsers = "converted_users",
  CreatedAt = "created_at",
  Id = "id",
  RevenueGenerated = "revenue_generated",
}

/** An object representing a Tracking Pixel */
export type TrackingPixel = {
  __typename?: "TrackingPixel";
  /** Timestamp of when the Tracking Pixel was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the Tracking Pixel */
  id: Scalars["ID"]["output"];
  /** The type of the Tracking Pixel */
  pixelType: TrackingPixelTypes;
  /** Timestamp of when the Tracking Pixel was updated */
  updatedAt: Scalars["Timestamp"]["output"];
  /** The value of the Tracking Pixel */
  value: Scalars["String"]["output"];
};

/** The connection type for TrackingPixel. */
export type TrackingPixelConnection = {
  __typename?: "TrackingPixelConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TrackingPixelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<TrackingPixel>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type TrackingPixelEdge = {
  __typename?: "TrackingPixelEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<TrackingPixel>;
};

/** The different types for a tracking pixel */
export enum TrackingPixelTypes {
  /** X Checkout Initiated Event */
  XCheckoutInitiatedEvent = "x_checkout_initiated_event",
  /** X Payment Method Event */
  XPaymentMethodEvent = "x_payment_method_event",
  /** X Purchase Event */
  XPurchaseEvent = "x_purchase_event",
}

/** Autogenerated input type of TransferFunds */
export type TransferFundsInput = {
  /** The amount to withdraw */
  amount: Scalars["Float"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The currency that is being withdrawn. */
  currency: Currencies;
  /** The ID of the destination (either a User tag, Bot tag, or LedgerAccount tag) */
  destinationId: Scalars["ID"]["input"];
  /** The feed identifier to notify of the transfer. */
  feedId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The feed type to notify of the transfer. */
  feedType?: InputMaybe<FeedTypes>;
  /** A unique key to ensure idempotence. Use a UUID or similar. */
  idempotenceKey: Scalars["String"]["input"];
  /** The ledger account id to transfer from. */
  ledgerAccountId: Scalars["ID"]["input"];
  /** Notes for the transfer. Maximum of 50 characters. */
  notes?: InputMaybe<Scalars["String"]["input"]>;
  /** The reason for the transfer. */
  reason?: InputMaybe<CreditTransactionTransferReasons>;
  /** The fee that the client thinks it is being charged for the transfer. Used to verify the fee. */
  transferFee?: InputMaybe<Scalars["Float"]["input"]>;
};

/** The metadata for a fund transfer. */
export type TransferFundsMetadata = {
  /** The ID of the referring feed. */
  feedId?: InputMaybe<Scalars["String"]["input"]>;
  /** The type of the referring feed. */
  feedType?: InputMaybe<FeedTypes>;
  /** Notes for the transfer. Maximum of 50 characters. */
  notes?: InputMaybe<Scalars["String"]["input"]>;
  /** The reason for the transfer. */
  reason?: InputMaybe<CreditTransactionTransferReasons>;
};

/** Autogenerated input type of TransferLinkMyMembership */
export type TransferLinkMyMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** This is the ID of the membership you want to create a transfer link for. */
  id: Scalars["ID"]["input"];
};

/** A representation of an X account. */
export type TwitterAccount = {
  __typename?: "TwitterAccount";
  /** The ID of the X account. */
  id: Scalars["ID"]["output"];
  /** The profile picture of the X account. */
  twitterProfilePic?: Maybe<Scalars["String"]["output"]>;
  /** The username of the X account. */
  username: Scalars["String"]["output"];
};

/** Autogenerated input type of UnarchiveAffiliate */
export type UnarchiveAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the affiliate to archive. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of UnbanUser */
export type UnbanUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user to unban */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of UnblockUser */
export type UnblockUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the user to unblock */
  userId: Scalars["ID"]["input"];
};

/** The definition of a content item */
export type UniversalPost = {
  __typename?: "UniversalPost";
  /** The access pass for the content item */
  accessPass?: Maybe<PublicAccessPass>;
  /** The app for the content item */
  app: PublicApp;
  /** The user for the content item */
  author: PublicProfileUser;
  /** The number of comments for the content item */
  commentCount: Scalars["Int"]["output"];
  /** The company for the content item */
  company: PublicCompany;
  /** The creation timestamp for the content item */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether or not the current user has liked the content item */
  currentUserHasLiked: Scalars["Boolean"]["output"];
  /** The experience for the content item */
  experience: PublicExperience;
  /** The ID for the content item */
  id: Scalars["ID"]["output"];
  /** The last activity timestamp for the content item */
  lastActivityAt: Scalars["Timestamp"]["output"];
  /** The number of likes for the content item */
  likeCount: Scalars["Int"]["output"];
  /** The primary attachment for the content item */
  primaryAttachment?: Maybe<AttachmentInterface>;
  /** The resource for the content item */
  resource: UniversalPostResourceInterface;
  /** The number of shares for the content item */
  shareCount: Scalars["Int"]["output"];
  /** The update timestamp for the content item */
  updatedAt: Scalars["Timestamp"]["output"];
};

/** The types of universal post feeds that you can retrieve */
export enum UniversalPostFeedTypes {
  AccessPass = "access_pass",
  Discover = "discover",
  Home = "home",
  RecentContentRewardSubmissions = "recent_content_reward_submissions",
  UserProfile = "user_profile",
}

export type UniversalPostResourceInterface = {
  /** The type of the resource */
  resourceType: Scalars["String"]["output"];
};

/** The root object containing universal posts */
export type UniversalPostResult = {
  __typename?: "UniversalPostResult";
  /** The next cursor */
  afterCursor?: Maybe<Scalars["ID"]["output"]>;
  /** The previous cursor */
  beforeCursor?: Maybe<Scalars["ID"]["output"]>;
  /** The ID of the recommendation set */
  recommendationId?: Maybe<Scalars["ID"]["output"]>;
  /** The list of universal posts */
  universalPosts: Array<UniversalPost>;
};

/** The return value from searching globally across Whop. */
export type UniversalSearch = {
  __typename?: "UniversalSearch";
  /** The data that matches the search. */
  results: Array<UniversalSearchResult>;
};

/** Additional data on the resource used for routing to it */
export type UniversalSearchDeeplink = {
  __typename?: "UniversalSearchDeeplink";
  /** The tag of the access pass. */
  accessPassId?: Maybe<Scalars["String"]["output"]>;
  /** The tag of the experience. */
  experienceId?: Maybe<Scalars["String"]["output"]>;
  /** The external ID of the chat feed. */
  feedId?: Maybe<Scalars["String"]["output"]>;
  /** The type of the feed, i.e ForumFeed, DmsPost. */
  feedType?: Maybe<Scalars["String"]["output"]>;
  /** The external ID of the message, i.e ForumPost.external_id, DmsPost.external_id */
  postId?: Maybe<Scalars["String"]["output"]>;
  /** The type of the post, i.e ForumPost, DmsPost. */
  postType?: Maybe<Scalars["String"]["output"]>;
  /** The tag of the user. */
  userId?: Maybe<Scalars["String"]["output"]>;
};

/** The searchable resource types mapped to their display names */
export type UniversalSearchResourceTypesToDisplayNames = {
  __typename?: "UniversalSearchResourceTypesToDisplayNames";
  /** The display name for the resource type (e.g., 'Post') */
  displayName: Scalars["String"]["output"];
  /** The resource type (e.g., 'Feed::ForumPost') */
  resourceType: Scalars["String"]["output"];
};

/** A single result from a universal search across Whop. */
export type UniversalSearchResult = {
  __typename?: "UniversalSearchResult";
  /** Additional data on the resource used for routing to it */
  deeplink: UniversalSearchDeeplink;
  /** The description of the result. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** The URL of the file with specific size. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The timestamp the resource was created. */
  resourceCreatedAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** The id of the resource */
  resourceId: Scalars["String"]["output"];
  /** The type of the result. Ex. AccessPass, Experience, User, etc. */
  resourceType: Scalars["String"]["output"];
  /** Any additional data related to this resource type, and how to display it */
  tags: Array<UniversalSearchTag>;
  /** The title of the result. */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** A single result from a universal search across Whop. */
export type UniversalSearchResultImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** Any additional data related to this resource type, used in universal search */
export type UniversalSearchTag = {
  __typename?: "UniversalSearchTag";
  /** Whether the metadata should be rendered with a border. */
  border: Scalars["Boolean"]["output"];
  /** The URL of the file with specific size. */
  imageSrcset?: Maybe<ImgSrcset>;
  /** The title of the metadata object. */
  title?: Maybe<Scalars["String"]["output"]>;
};

/** Any additional data related to this resource type, used in universal search */
export type UniversalSearchTagImageSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<ImageImageStyles>;
};

/** Autogenerated input type of UnlinkTwitterAccount */
export type UnlinkTwitterAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassAffiliate */
export type UpdateAccessPassAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the access pass affiliate. */
  id: Scalars["ID"]["input"];
  /** The status of this affiliate */
  status?: InputMaybe<AccessPassAffiliateStatuses>;
};

/** Autogenerated input type of UpdateAccessPassAttachments */
export type UpdateAccessPassAttachmentsInput = {
  /** The internal ID of the access pass to upload the file to. */
  accessPassId: Scalars["ID"]["input"];
  /** The attachments to upload */
  attachments: Array<AttachmentInput>;
  /** The category of the attachments. */
  category: AccessPassAttachmentCategories;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassFaq */
export type UpdateAccessPassFaqInput = {
  /** The answer of the FAQ. */
  answer: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the FAQ that is being updated. */
  faqId: Scalars["ID"]["input"];
  /** The question of the FAQ. */
  question: Scalars["String"]["input"];
};

/** Autogenerated input type of UpdateAccessPassFaqOrder */
export type UpdateAccessPassFaqOrderInput = {
  /** The ID of the access pass that the faq is being created on. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A list of FAQ ids on that access pass in the order they should be displayed. */
  faqIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassFileAttachments */
export type UpdateAccessPassFileAttachmentsInput = {
  /** The internal ID of the access pass to upload the file to. */
  accessPassId: Scalars["ID"]["input"];
  /** The files to upload */
  attachmentUrls: Array<Scalars["String"]["input"]>;
  /** The category of the files. */
  category: AccessPassAttachmentCategories;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassImageOrder */
export type UpdateAccessPassImageOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the access pass to upload the image to. */
  id: Scalars["ID"]["input"];
  /** Array of image IDs in the order they should be displayed. */
  imageIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassImages */
export type UpdateAccessPassImagesInput = {
  /** The internal ID of the access pass to upload the image to. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Images to upload */
  imageUrls: Array<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPass */
export type UpdateAccessPassInput = {
  /** A banner image for the access pass in png, jpeg format */
  bannerImage?: InputMaybe<AttachmentInput>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The creator pitch for the access pass. */
  creatorPitch?: InputMaybe<Scalars["String"]["input"]>;
  /** The custom call to action for the access pass. */
  customCta?: InputMaybe<CustomCtas>;
  /** The custom call to action URL for the access pass. */
  customCtaUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** A written description of the access pass. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The percentage of the revenue that goes to the global affiliate program. */
  globalAffiliatePercentage?: InputMaybe<Scalars["Float"]["input"]>;
  /** The status of the global affiliate program for this access pass. */
  globalAffiliateStatus?: InputMaybe<GlobalAffiliateStatuses>;
  /** The headline of the access pass. */
  headline?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID (tag) of the access pass */
  id: Scalars["ID"]["input"];
  /**
   * An attachment image that is either a png, jpeg, or gif.
   * @deprecated Use logo instead
   */
  image?: InputMaybe<Scalars["File"]["input"]>;
  /** The latitude of the access pass. */
  latitude?: InputMaybe<Scalars["Float"]["input"]>;
  /** The preceding characters before a randomly generated license key. */
  licenseKeyPrefix?: InputMaybe<Scalars["String"]["input"]>;
  /** The logo for the access pass in png, jpeg, or gif format */
  logo?: InputMaybe<AttachmentInput>;
  /** The longitude of the access pass. */
  longitude?: InputMaybe<Scalars["Float"]["input"]>;
  /** The name of the access pass. It must be max 50 characters. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * A user can/cannot own multiple of this pass
   * @deprecated No longer used
   */
  onePerUser?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The ID of the page that this access pass is associated with.
   * @deprecated No longer applied.
   */
  pageId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the experience pinned to this access pass */
  pinnedExperienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The URL to redirect the customer to after a purchase. */
  redirectPurchaseUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** The route of the access pass. */
  route?: InputMaybe<Scalars["String"]["input"]>;
  /** A short description of what the access pass offers or does. Must be 150 chars or less. */
  shortenedDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to show the member count on the access pass. */
  showMemberCount?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not to show the offers on the access pass. */
  showOffers?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not to show reviews on the access pass. */
  showReviewsDtc?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A license key can/can't be scrambled. */
  shuffleable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The title of the access pass, for Whop 4.0. */
  title?: InputMaybe<Scalars["String"]["input"]>;
  /** This access pass can/cannot be transferred to another user */
  transferable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The description of the upsell for the access pass. */
  upsellDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** The media for the upsell of the access pass, either an image or video. */
  upsellMedia?: InputMaybe<AttachmentInput>;
  /** The title of the upsell for the access pass. */
  upsellTitle?: InputMaybe<Scalars["String"]["input"]>;
  /** This access pass will/will not be displayed publicly. */
  visibility?: InputMaybe<Visibility>;
};

/** Autogenerated input type of UpdateAccessPassItemOrdering */
export type UpdateAccessPassItemOrderingInput = {
  /** The ID of the AccessPass to update the ordering for. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ordering array to store. Ex. ['exp_123', 'exp_456', 'exp_789', 'exp_101112'] */
  data: Array<Scalars["String"]["input"]>;
  /** The type of ordering to update. */
  orderType: ItemOrderingOrderTypes;
};

/** Autogenerated input type of UpdateAccessPassMarketplaceCategories */
export type UpdateAccessPassMarketplaceCategoriesInput = {
  /** The ID of the access pass that is being updated. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The categories to assign to the access pass. */
  marketplaceCategoryId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassMemberOrder */
export type UpdateAccessPassMemberOrderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Array of access pass IDs and their new orders, e.g. [{accessPassId: '123', order: 1.5}, {accessPassId: '456', order: 2.0}] */
  updates: Array<AccessPassOrderInput>;
};

/** Autogenerated input type of UpdateAccessPassPinnedExperiences */
export type UpdateAccessPassPinnedExperiencesInput = {
  /** The ID of the access pass to pin the experiences to. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The IDs of which experiences to pin, in order. Any missing experiences will be unpinned. */
  experienceIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateAccessPassSocialLink */
export type UpdateAccessPassSocialLinkInput = {
  /** The ID of the Access Pass this social link belongs to */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the social link */
  id: Scalars["ID"]["input"];
  /** The URL of the social link */
  url?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** The website this link is for */
  website?: InputMaybe<SocialLinkWebsites>;
};

/** Autogenerated input type of UpdateAffiliate */
export type UpdateAffiliateInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The amount the affiliate will earn (either amount or percent 1-100) */
  fee?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** The ID (tag) of the affiliate. */
  id: Scalars["ID"]["input"];
  /** Whether or not the affiliate will only get one payout or it will be recurring. */
  onlyOnePayout?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The type of payout. */
  payoutType?: InputMaybe<PayoutTypes>;
  /** The IDs of the plans that the affiliate can refer. */
  planId: Scalars["String"]["input"];
  /** Sets the affiliate as active/inactive. */
  status?: InputMaybe<Status>;
};

/** Autogenerated input type of UpdateApiKey */
export type UpdateApiKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the API key to reset */
  id: Scalars["ID"]["input"];
  /** A user set name to identify an API key */
  nickname?: InputMaybe<Scalars["String"]["input"]>;
  /** The permissions this api key should have enabled. If empty, it will be unscoped. */
  permissions?: InputMaybe<Array<ApiKeyPermissions>>;
};

/** Autogenerated input type of UpdateApp */
export type UpdateAppInput = {
  /** The base developer url of the app */
  baseDevUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** The base preview url of the app */
  basePreviewUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** The base production url of the app */
  baseUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the app */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The path for the hub view of the app */
  experiencePath?: InputMaybe<Scalars["String"]["input"]>;
  /** If the apps experience's should force showing the pre-checkout iframe, and not rely on app connections. */
  forceCheckoutIframe?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The hub call to action text of the app */
  hubCta?: InputMaybe<Scalars["String"]["input"]>;
  /** The icon for the app */
  icon?: InputMaybe<AttachmentInput>;
  /** The ID of the app */
  id: Scalars["ID"]["input"];
  /**
   * The image for the app
   * @deprecated Use icon instead
   */
  image?: InputMaybe<Scalars["File"]["input"]>;
  /** The name of the app */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** The product page text of the app */
  productPage?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateAppView */
export type UpdateAppViewInput = {
  /** The ID of the app view to update */
  appViewId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The path of the app view */
  path: Scalars["String"]["input"];
};

/** Autogenerated input type of UpdateAuthorizedUser */
export type UpdateAuthorizedUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID (tag) of the authorized user. */
  id: Scalars["ID"]["input"];
  /** The role (access level) the user should be granted. */
  role: AuthorizedUserRoles;
};

/** Autogenerated input type of UpdateAutoRespondToResolutions */
export type UpdateAutoRespondToResolutionsInput = {
  /** Whether to auto respond to resolutions or not */
  autoRespond: Scalars["Boolean"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A custom message to send when auto responding to resolutions */
  customMessage?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of days to wait before auto responding to resolutions */
  waitDays?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Autogenerated input type of UpdateAutomatedMessagesConfig */
export type UpdateAutomatedMessagesConfigInput = {
  /** The ID of the access pass that the automated message is associated with. */
  accessPassId: Scalars["ID"]["input"];
  /** The attachments for this config */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The ID of the automated messages trigger that the automated message is associated with. */
  automatedMessagesTriggerId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The content of the automated message. */
  content: Scalars["String"]["input"];
  /** Whether the automated message should send an email when triggered. */
  emailEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * The file attachments for this message
   * @deprecated Use the 'attachments' instead
   */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** Whether the automated message is enabled. */
  isEnabled: Scalars["Boolean"]["input"];
  /** The ID of the team member that the automated message will be sent from. */
  sendFromTeamMemberId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateBillingAddress */
export type UpdateBillingAddressInput = {
  /** The ID of the access pass. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The address to update the customer's profile with. */
  address: AddressInput;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company buyer. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the company that the checkout is occurring on. */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The currency of the purchase. */
  currency: Currencies;
  /** The IP address of the customer. */
  ipAddress?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the ledger account. */
  ledgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the line item. */
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the mailing address object to update. */
  mailingAddressId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The payment processor to use for the transaction. */
  paymentProcessor?: InputMaybe<PaymentProcessor>;
  /** The ID of the plan. */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The VAT ID to update the customer's profile with. */
  vatId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateCampaign */
export type UpdateCampaignInput = {
  /** Whether to allow Instagram submissions */
  allowInstagram?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to allow TikTok submissions */
  allowTiktok?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to allow X submissions */
  allowX?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether to allow YouTube submissions */
  allowYoutube?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The array of included assets for this campaign */
  assets?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The attachments for this campaign */
  attachments?: InputMaybe<Array<AttachmentInput>>;
  /** The number of hours after which submissions get auto-approved */
  autoApproveSubmissionsInHours?: InputMaybe<Scalars["Int"]["input"]>;
  /** Which category to assign */
  category: ContentRewardsCategory;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Which content type is accepted */
  contentType: ContentRewardsContentType;
  /** When this campaign ends, if not set, the campaign will not expire */
  expiresAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /**
   * The file attachments for this campaign
   * @deprecated Use `attachments` instead
   */
  fileAttachments?: InputMaybe<Array<FileAttachmentInput>>;
  /** Whether submissions to this campaign require file uploads */
  fileUploadRequired?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the campaign you want to update */
  id: Scalars["ID"]["input"];
  /** The maximum amount that can be paid out per submission */
  maxPayoutPerSubmission?: InputMaybe<Scalars["Float"]["input"]>;
  /** The minimum amount owed before a submission is eligible for payouts */
  minPayoutPerSubmission?: InputMaybe<Scalars["Float"]["input"]>;
  /** URL that must be present in the submitter's social account bio */
  requiredCreatorBioLink?: InputMaybe<Scalars["String"]["input"]>;
  /** Text patterns that must be present in the submitted post description */
  requiredDescriptionText?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** Instagram audio that must be used in the submissions */
  requiredInstagramAudio?: InputMaybe<Scalars["String"]["input"]>;
  /** TikTok audio that must be used in the submissions */
  requiredTiktokAudio?: InputMaybe<Scalars["String"]["input"]>;
  /** An array of requirements that the user must complete to collect a reward */
  requirements?: InputMaybe<Array<Scalars["String"]["input"]>>;
  /** The title of this campaign */
  title: Scalars["String"]["input"];
  /** The total amount that will be paid out for this campaign */
  totalBudget: Scalars["Float"]["input"];
};

/** Autogenerated input type of UpdateCoinbaseAccount */
export type UpdateCoinbaseAccountInput = {
  /** The Coinbase Commerce API key to use. */
  apiKey: Scalars["String"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the Coinbase account to update. */
  id: Scalars["ID"]["input"];
  /** The Coinbase Commerce shared secret to use. */
  webhookSecret: Scalars["String"]["input"];
};

/** Autogenerated input type of UpdateCompanyBilling */
export type UpdateCompanyBillingInput = {
  /** The minimum USD amount in which we'll auto refund dispute warnings */
  autoRefundThreshold: Scalars["Int"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateCompanyCheckout */
export type UpdateCompanyCheckoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The google analytics ID */
  googleAnalyticsId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The google tag manager ID */
  gtmId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The Hyros API key */
  hyrosApiKey?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The Hyros pixel ID */
  hyrosPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The meta pixel ID */
  metaPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** Whether or not the company considers past due memberships as valid. */
  pastDueIsValid?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The pinterest pixel ID */
  pinterestPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The reddit pixel ID */
  redditPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The URL to redirect the customer to after a purchase. */
  redirectPurchaseUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** Whether or not the company requires phone verification to checkout. */
  requirePhoneVerification?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not the company wants to send transactional emails and discord dms to members. */
  sendEmails?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** whether they should send the oauth code or not during redirect */
  sendOauthCode?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not the company wants to allow Whop to send promotional emails to its members. */
  sendPromoEmails?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The tiktok pixel ID */
  tiktokPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The Twitter pixel ID */
  twitterPixelId?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The x checkout initiated event */
  xCheckoutInitiatedEvent?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The x payment method event */
  xPaymentMethodEvent?: InputMaybe<Scalars["SanitizedString"]["input"]>;
  /** The x purchase event */
  xPurchaseEvent?: InputMaybe<Scalars["SanitizedString"]["input"]>;
};

/** Autogenerated input type of UpdateCompanyCollab */
export type UpdateCompanyCollabInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company you want to accept or reject a collab for. */
  id: Scalars["ID"]["input"];
  /** The status you want to change the friendship request to. */
  status: CompanyCollabStatuses;
};

/** Autogenerated input type of UpdateCompanyInfo */
export type UpdateCompanyInfoInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The country the company is located in. */
  country?: InputMaybe<Countries>;
  /**
   * A description of what the company offers.
   * @deprecated No longer used.
   */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * Whether or not the company has edited their store page.
   * @deprecated No longer used.
   */
  editedStorePage?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The company's banner. */
  headerImage?: InputMaybe<Scalars["File"]["input"]>;
  /** The company's logo. */
  image?: InputMaybe<Scalars["File"]["input"]>;
  /** The company's custom link preview image URL. */
  ogImage?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not a company requires their authorized users to have 2fa enabled. */
  require2fa?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * A short description of what the company offers.
   * @deprecated No longer used.
   */
  shortenedDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the company wants to show their users in joined_whops on other creator's accounts. */
  showJoinedWhops?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not the company wants to show reviews via direct to consumer links on their product pages. */
  showReviewsDtc?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not the company wants to show their users in the user directory. */
  showUserDirectory?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The name/title of the company. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateCompanyItemOrdering */
export type UpdateCompanyItemOrderingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ordering array to store. Ex. ['exp_123', 'exp_456', ['Folder Name', 'exp_789', 'exp_101112']] */
  data: Scalars["JSON"]["input"];
  /** The type of ordering to update. */
  orderType: ItemOrderingOrderTypes;
};

/** Autogenerated input type of UpdateCompanyLedgerAccount */
export type UpdateCompanyLedgerAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The minimum balance to retain in the account after an automatic withdrawal */
  minimumBalanceToRetain?: InputMaybe<Scalars["Float"]["input"]>;
  /** The currency for the minimum retain balance */
  minimumBalanceToRetainCurrency?: InputMaybe<Currencies>;
  /** The day to withdraw funds on. 1-31 for monthly, 0-6 for weekly. */
  withdrawalDay?: InputMaybe<Scalars["Int"]["input"]>;
  /** The frequency of automatic withdrawals */
  withdrawalFrequency?: InputMaybe<LedgerWithdrawalFrequencies>;
};

/** Autogenerated input type of UpdateCompanyLegal */
export type UpdateCompanyLegalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The company's EULA. It should be a PDF file. */
  eula?: InputMaybe<AttachmentInput>;
  /**
   * The company's EULA PDF.
   * @deprecated Use eula instead
   */
  eulaPdf?: InputMaybe<Scalars["File"]["input"]>;
  /** The company's privacy policy. It should be a PDF file. */
  privacyPolicy?: InputMaybe<AttachmentInput>;
  /**
   * The company's privacy policy PDF.
   * @deprecated Use privacyPolicy instead
   */
  privacyPolicyPdf?: InputMaybe<Scalars["File"]["input"]>;
  /** A VAT, tax, or other legal ID for the company. */
  registeredCompanyNumber?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the company requires the user to agree to the terms of service before checkout. */
  requireTermsAgreement?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not the company allows customers to submit VAT IDs on checkout. */
  requireVatId?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The company's return policy. It should be a PDF file. */
  returnPolicy?: InputMaybe<AttachmentInput>;
  /**
   * The company's return policy PDF.
   * @deprecated Use returnPolicy instead
   */
  returnPolicyPdf?: InputMaybe<Scalars["File"]["input"]>;
  /** The company's terms of service. It should be a PDF file. */
  termsOfService?: InputMaybe<AttachmentInput>;
  /**
   * The company's terms of service PDF.
   * @deprecated Use termsOfService instead
   */
  tosPdf?: InputMaybe<Scalars["File"]["input"]>;
};

/** Autogenerated input type of UpdateCompanyProfile */
export type UpdateCompanyProfileInput = {
  /** The business name of the company */
  businessName?: InputMaybe<Scalars["String"]["input"]>;
  /** The city of the address */
  city?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The country of the address */
  country?: InputMaybe<Scalars["String"]["input"]>;
  /** The support email address for the profile. */
  email?: InputMaybe<Scalars["String"]["input"]>;
  /** The first line of the address */
  line1?: InputMaybe<Scalars["String"]["input"]>;
  /** The second line of the address */
  line2?: InputMaybe<Scalars["String"]["input"]>;
  /** The postal code of the address */
  postalCode?: InputMaybe<Scalars["String"]["input"]>;
  /** The state of the address */
  state?: InputMaybe<Scalars["String"]["input"]>;
  /** The tax type to use for this account. One of: exclusive, inclusive, unspecified. */
  taxType?: InputMaybe<TaxTypes>;
};

/** Autogenerated input type of UpdateConnectedAccount */
export type UpdateConnectedAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the connected account to update. */
  id: Scalars["ID"]["input"];
  /** A payout anchor to schedule withdrawals. */
  monthlyAnchor?: InputMaybe<Scalars["Int"]["input"]>;
  /** A payout interval to schedule withdrawals. */
  payoutInterval?: InputMaybe<PayoutIntervals>;
  /** A statement descriptor to use for all charges on Stripe Connect. */
  statementDescriptor?: InputMaybe<Scalars["String"]["input"]>;
  /** A support address to use for all charges on Stripe Connect. */
  supportAddress?: InputMaybe<SupportAddressInput>;
  /** A support email to use for all charges on Stripe Connect. */
  supportEmail?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the company, which will be show on invoices. */
  supportName?: InputMaybe<Scalars["String"]["input"]>;
  /** A support phone number to use for all charges on Stripe Connect. */
  supportPhone?: InputMaybe<Scalars["String"]["input"]>;
  /** A URL to use for all charges on Stripe Connect. */
  url?: InputMaybe<Scalars["String"]["input"]>;
  /** A payout anchor to schedule withdrawals. */
  weeklyAnchor?: InputMaybe<WeeklyAnchors>;
};

/** Autogenerated input type of UpdateDispute */
export type UpdateDisputeInput = {
  /** An IP access log for the user from Whop. */
  accessActivityLog?: InputMaybe<Scalars["String"]["input"]>;
  /** The billing address of the user from their payment details. */
  billingAddress?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * A file containing the cancellation policy from the company.
   * @deprecated Use cancellation_policy_v2 instead
   */
  cancellationPolicy?: InputMaybe<Scalars["File"]["input"]>;
  /** A file containing the cancellation policy from the company. */
  cancellationPolicyAttachment?: InputMaybe<AttachmentInput>;
  /** A cancellation policy disclosure from the company. */
  cancellationPolicyDisclosure?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * A file containing the customer communication from the company (An image).
   * @deprecated Use customer_communication_v2 instead
   */
  customerCommunication?: InputMaybe<Scalars["File"]["input"]>;
  /** A file containing the customer communication from the company (An image). */
  customerCommunicationAttachment?: InputMaybe<AttachmentInput>;
  /** The email of the customer from their payment details. */
  customerEmailAddress?: InputMaybe<Scalars["String"]["input"]>;
  /** The name of the customer from their payment details. */
  customerName?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the dispute you want to update. */
  id: Scalars["ID"]["input"];
  /** Additional notes the company chooses to submit regarding the dispute. */
  notes?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the product from the company. */
  productDescription?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * A file containing the refund policy from the company.
   * @deprecated Use refund_policy_v2 instead
   */
  refundPolicy?: InputMaybe<Scalars["File"]["input"]>;
  /** A file containing the refund policy from the company. */
  refundPolicyAttachment?: InputMaybe<AttachmentInput>;
  /** A refund policy disclosure from the company. */
  refundPolicyDisclosure?: InputMaybe<Scalars["String"]["input"]>;
  /** A description on why the refund is being refused by the company. */
  refundRefusalExplanation?: InputMaybe<Scalars["String"]["input"]>;
  /** When the product was delivered by the company. */
  serviceDate?: InputMaybe<Scalars["String"]["input"]>;
  /** A file that does not fit in the other categories. */
  uncategorizedAttachment?: InputMaybe<AttachmentInput>;
  /**
   * A file that does not fit in the other categories.
   * @deprecated Use uncategorized_file_v2 instead
   */
  uncategorizedFile?: InputMaybe<Scalars["File"]["input"]>;
};

/** Autogenerated input type of UpdateEntry */
export type UpdateEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The action to take upon the entry. */
  entryAction?: InputMaybe<EntryActions>;
  /** The ID (tag) of the entry scoped to the current company. */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of UpdateExperienceAccessPasses */
export type UpdateExperienceAccessPassesInput = {
  /** An array of access pass IDs that will contain this experience. */
  accessPassIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** An experience ID */
  experienceId: Scalars["ID"]["input"];
};

/** Autogenerated input type of UpdateExperience */
export type UpdateExperienceInput = {
  /**
   * The access level of the experience.
   * @deprecated You can't set this anymore
   */
  accessLevel?: InputMaybe<ExperienceAccessLevels>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The description of the experience. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The expiration date of the experience. If not set, the experience will not expire. */
  expiresAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** Whether to hide the experience if it is not accessible. */
  hideIfNotAccessible?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The internal ID of the Discord experience to update. */
  id: Scalars["ID"]["input"];
  /**
   * The image for the experience
   * @deprecated Use logo instead
   */
  image?: InputMaybe<Scalars["File"]["input"]>;
  /** The logo for the experience */
  logo?: InputMaybe<AttachmentInput>;
  /** The name of the experience. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether screenshots are allowed for the experience, enforced on the client side */
  screenshotsAllowed?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not experience content is shown in the explore page */
  showExploreContent?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** Autogenerated input type of UpdateFavoriteAccessPasses */
export type UpdateFavoriteAccessPassesInput = {
  /** The access pass IDs to update. */
  accessPassIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateFeaturedAccessPasses */
export type UpdateFeaturedAccessPassesInput = {
  /** The access pass IDs to update. */
  accessPassIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The parent access pass ID to update, the one you're setting the offers for
   * @deprecated Don't use this
   */
  parentAccessPassId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateFeedWebhook */
export type UpdateFeedWebhookInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the webhook to update */
  id: Scalars["ID"]["input"];
  /** The name of the webhook */
  name: Scalars["String"]["input"];
};

/** Autogenerated input type of UpdateGlobalWatermark */
export type UpdateGlobalWatermarkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateMemberNote */
export type UpdateMemberNoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A freeform text description to write about a member. */
  notes: Scalars["String"]["input"];
  /** The member to associate the notes with. */
  userId: Scalars["ID"]["input"];
};

/** Autogenerated input type of UpdateMembership */
export type UpdateMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of trial days to add to the membership to extend it. */
  freeDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** The ID (tag) of the membership. */
  id: Scalars["ID"]["input"];
  /** The action being applied to the specific membership. */
  membershipAction: MembershipActions;
};

/** Autogenerated input type of UpdateMobilePushPausedUntil */
export type UpdateMobilePushPausedUntilInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The time until mobile push notifications are paused. */
  mobilePushPausedUntil?: InputMaybe<Scalars["Timestamp"]["input"]>;
};

/** Autogenerated input type of UpdateParticipantsPermissions */
export type UpdateParticipantsPermissionsInput = {
  /** The action for the participant being updated */
  action: LivestreamParticipantAction;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The feed ID for the room to update */
  feedId: Scalars["ID"]["input"];
  /** The ID of the user you want to update */
  userIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdatePaymentMethod */
export type UpdatePaymentMethodInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company buyer to attach this payment method to. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** Whether or not this payment method should be the default one. */
  default?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the payment_method (tag) */
  id: Scalars["ID"]["input"];
};

/** Autogenerated input type of UpdatePersonalAccount */
export type UpdatePersonalAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Stripe Publishable Key */
  stripePublishableKey: Scalars["String"]["input"];
  /** Stripe Secret Key */
  stripeSecretKey: Scalars["String"]["input"];
};

/** Autogenerated input type of UpdatePlan */
export type UpdatePlanInput = {
  /** Whether or not ACH payments are accepted */
  achPayments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Marks whether customers can purchase multiple quantity of the plan. */
  allowMultipleQuantity?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The respective currency identifier for the plan. */
  baseCurrency?: InputMaybe<Currencies>;
  /** The interval at which the plan charges (renewal plans). */
  billingPeriod?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether or not to cancel dependant collab passes if a user loses access to this one. */
  cancelCollabPasses?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Either forever (0), first payment (1), or a specified number of months (2, 3, 4...). */
  cancelDiscountIntervals?: InputMaybe<Scalars["Int"]["input"]>;
  /** The percentage discount to offer when canceling a subscription. */
  cancelDiscountPercentage?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether or not card payments are accepted */
  cardPayments?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether coinbase commerce payments are/aren't accepted. */
  coinbaseCommerceAccepted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Reward information for custom affiliates. */
  customAffiliateSettings?: InputMaybe<AffiliateSettingsInput>;
  /** An array of custom field objects. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** The description of the plan. */
  description?: InputMaybe<Scalars["String"]["input"]>;
  /** The interval at which the plan charges (expiration plans). */
  expirationDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** The time period (in days) after a sub expires where the customer can still top-up. */
  gracePeriodDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** The ID */
  id: Scalars["ID"]["input"];
  /** An additional amount charged upon first purchase. */
  initialPrice?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** A personal description or notes section for the business. */
  internalNotes?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to offer a discount to cancel a subscription. */
  offerCancelDiscount?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Marks whether or not a plan can be purchased multiple times by a company. Used most likely for free trial plans  */
  onePerCompany?: InputMaybe<Scalars["Boolean"]["input"]>;
  /**
   * Marks whether or not a plan can be purchased multiple times by a user. Used most likely for free trial plans
   * @deprecated No longer used
   */
  onePerUser?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** An override for tax to specify for this specific plan. */
  overrideTaxType?: InputMaybe<TaxTypes>;
  /** Reward information for passholder affiliates. */
  passholderAffiliateSettings?: InputMaybe<AffiliateSettingsInput>;
  /** The description of the Plan as seen by the customer on the checkout page. */
  paymentLinkDescription?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether paypal payments are/aren't accepted. */
  paypalAccepted?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The URL to redirect the customer to after purchase. */
  redirectUrl?: InputMaybe<Scalars["String"]["input"]>;
  /** Marks whether an expiration plan can/can't be topped-up. */
  refillable?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Configurable settings on how this plan is released. */
  releaseMethodSettings?: InputMaybe<ReleaseMethodSettingsInput>;
  /** The amount the customer is charged every billing period. */
  renewalPrice?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** Requirements that block/enable purchasing a plan for a user. */
  requirements?: InputMaybe<Scalars["Requirements"]["input"]>;
  /** Whether the plan should be set as the default for its access pass. */
  setAsDefault?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The short link identifier for the plan. */
  shortLink?: InputMaybe<Scalars["String"]["input"]>;
  /** The number of payments required before pausing the subscription. */
  splitPayRequiredPayments?: InputMaybe<Scalars["Int"]["input"]>;
  /** The number of units available for purchase. */
  stock?: InputMaybe<Scalars["Int"]["input"]>;
  /** The number of free trial days added before a renewal plan. */
  trialPeriodDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** Limits/doesn't limit the number of units available for purchase. */
  unlimitedStock?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Shows or hides the plan from public/business view. */
  visibility?: InputMaybe<Visibility>;
};

/** Autogenerated input type of UpdatePopupPromo */
export type UpdatePopupPromoInput = {
  /** The ID (tag) of the access pass. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The discount percentage for the popup promo. Ex. 10 for 10%, 25 for 25% off */
  discountPercentage?: InputMaybe<Scalars["Int"]["input"]>;
  /** Whether the popup promo is enabled or not. */
  enabled: Scalars["Boolean"]["input"];
};

/** Autogenerated input type of UpdateProductHighlight */
export type UpdateProductHighlightInput = {
  /** The access pass ID to use. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Text to display to describe the product highlight (max length 250). */
  content?: InputMaybe<Scalars["String"]["input"]>;
  /**
   * The type of this highlight.
   * @deprecated Use productHighlightId instead.
   */
  highlightType?: InputMaybe<ProductHighlightTypes>;
  /** The ID of the product highlight to update. */
  productHighlightId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The title of the product highlight, if applicable. */
  title?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateProductHighlightOrder */
export type UpdateProductHighlightOrderInput = {
  /** The ID of the access pass that the product highlights are on. */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The type of this highlight. */
  highlightType: ProductHighlightTypes;
  /** A list of product highlight ids ids on that access pass in the order they should be displayed. */
  productHighlightIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateProductsForExperience */
export type UpdateProductsForExperienceInput = {
  /** The list of access passes to add to the experience */
  addAccessPassIds: Array<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The experience to update */
  experienceId: Scalars["ID"]["input"];
  /** The list of access passes to remove from the experience */
  removeAccessPassIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateReceipt */
export type UpdateReceiptInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the payment/receipt you want to update or take action upon. */
  id: Scalars["ID"]["input"];
  /** refund_payment | An amount if the refund is supposed to be partial. */
  partialAmount?: InputMaybe<Scalars["StringFloat"]["input"]>;
  /** This is the type of action that is being executed on the payment. */
  paymentAction: PaymentActions;
};

/** Autogenerated input type of UpdateRedirectUri */
export type UpdateRedirectUriInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The new redirect URL */
  newRedirectUri: Scalars["UrlString"]["input"];
  /** The old redirect URL */
  oldRedirectUri: Scalars["UrlString"]["input"];
};

/** Autogenerated input type of UpdateSimpleNotificationPreference */
export type UpdateSimpleNotificationPreferenceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the experience to update the notification preference for */
  experienceId: Scalars["ID"]["input"];
  /** The status of the notification preference */
  status: SimpleNotificationPreferenceStatus;
};

/** Autogenerated input type of UpdateStreamKey */
export type UpdateStreamKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The service of the stream key */
  destination: LivestreamDestination;
  /** The key for the destination service */
  key?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateStripeAccount */
export type UpdateStripeAccountInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Automatically collect tax info */
  collectTax?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The ID of the Stripe account to update. */
  id: Scalars["ID"]["input"];
  /** The tax type to use for this account. One of: exclusive, inclusive, unspecified. */
  taxType?: InputMaybe<TaxTypes>;
};

/** Autogenerated input type of UpdateUpsellAccessPasses */
export type UpdateUpsellAccessPassesInput = {
  /** The access pass ID to update, the one you're setting the upsells for */
  accessPassId: Scalars["ID"]["input"];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The access pass IDs to update. */
  upsellAccessPassIds: Array<Scalars["ID"]["input"]>;
};

/** Autogenerated input type of UpdateUser */
export type UpdateUserInput = {
  /** Whether the user should be able to receive DMs from anyone. */
  allowDmsFromAnyone?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** An image for the user's banner. */
  banner?: InputMaybe<AttachmentInput>;
  /**
   * An image for the user's banner.
   * @deprecated Use banner instead.
   */
  bannerImage?: InputMaybe<Scalars["File"]["input"]>;
  /** A bio for the user. */
  bio?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the user has investigation mode enabled. */
  investigationEnabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A first and last name for the user. */
  name?: InputMaybe<Scalars["String"]["input"]>;
  /** A one time passcode. */
  otp?: InputMaybe<Scalars["String"]["input"]>;
  /** A 10 digit phone number. */
  phone?: InputMaybe<Scalars["String"]["input"]>;
  /** The Posthog person ID for the user. */
  posthogPersonId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the Discord account to set as the primary for the User. */
  primaryDiscordId?: InputMaybe<Scalars["ID"]["input"]>;
  /**
   * An image for the user for their avatar.
   * @deprecated Use profilePicture instead.
   */
  profilePhoto?: InputMaybe<Scalars["File"]["input"]>;
  /** An image for the user for their avatar. */
  profilePicture?: InputMaybe<AttachmentInput>;
  /** The user's timezone */
  timezone?: InputMaybe<Scalars["String"]["input"]>;
  /** The user's Tradingview username (pass empty string to clear) */
  tradingViewUsername?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether two factor should be enabled. */
  twoFactor?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** A Whop username */
  username?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of UpdateUserOnboardingData */
export type UpdateUserOnboardingDataInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** When the user completed onboarding */
  onboardingCompletedAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** When the user skipped adding their phone number */
  skippedAddingPhoneAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** When the user skipped downloading the mobile app */
  skippedDownloadingMobileAppAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
};

/** Autogenerated input type of UpdateUserPreferences */
export type UpdateUserPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not to show their earnings on their profile */
  showEarnings?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** Whether or not to show the whops they joined on their profile */
  showJoinedWhops: Scalars["Boolean"]["input"];
  /** Whether or not to show their location on their profile */
  showLocation: Scalars["Boolean"]["input"];
  /** Whether or not to show the whops they own on their profile */
  showOwnedWhops: Scalars["Boolean"]["input"];
  /** Whether or not to show their ranking on their profile */
  showUserRanking: Scalars["Boolean"]["input"];
};

/** Autogenerated input type of UpdateUserSocialLink */
export type UpdateUserSocialLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the social link */
  id: Scalars["ID"]["input"];
  /** The URL of the social link */
  url?: InputMaybe<Scalars["UrlString"]["input"]>;
  /** The website this link is for */
  website?: InputMaybe<UserSocialLinkWebsites>;
};

/** Autogenerated input type of UpdateVatId */
export type UpdateVatIdInput = {
  /** The ID of the access pass the customer is applying the VAT ID for. */
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company buyer the customer is applying the VAT ID for. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the company that the checkout is occurring on. */
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The currency the customer is applying the VAT ID for. */
  currency: Currencies;
  /** The ID of the ledger account the customer is applying the VAT ID for. */
  ledgerAccountId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the line item the customer is applying the VAT ID for. */
  lineItemId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the plan the customer is applying the VAT ID for. */
  planId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The VAT ID to update the customer's profile with. */
  vatId: Scalars["ID"]["input"];
};

/** Autogenerated input type of UpdateWebhook */
export type UpdateWebhookInput = {
  /** The API version for this webhook */
  apiVersion?: InputMaybe<ApiVersion>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** Whether or not the webhook is enabled. */
  enabled?: InputMaybe<Scalars["Boolean"]["input"]>;
  /** The events to send the webhook for. */
  events?: InputMaybe<Array<WebhookEvent>>;
  /** The ID of the Webhook to update */
  id: Scalars["ID"]["input"];
  /** The URL to send the webhook to. */
  url?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** Response type for updated entities query */
export type UpdatedEntitiesResponse = {
  __typename?: "UpdatedEntitiesResponse";
  /** Cursor for pagination */
  cursor?: Maybe<Cursor>;
  /** List of entities */
  entities: Array<BaseEntityInterface>;
};

/** Autogenerated input type of UpgradePlan */
export type UpgradePlanInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the membership to update. */
  membershipId: Scalars["ID"]["input"];
  /** The plan the membership wants to switch to. */
  planId: Scalars["String"]["input"];
};

/** Autogenerated input type of UploadAccessPassImage */
export type UploadAccessPassImageInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The internal ID of the access pass to upload the image to. */
  id: Scalars["ID"]["input"];
  /** Image for upload */
  image: Scalars["File"]["input"];
};

export type UploadPartInput = {
  /** The ETag of the part */
  etag: Scalars["String"]["input"];
  /** The part number of the part */
  partNumber: Scalars["Int"]["input"];
};

export type UpsellPlanInput = {
  /** The base currency of the upsell. */
  baseCurrency?: InputMaybe<Currencies>;
  /** An array of custom field objects. */
  customFields?: InputMaybe<Array<CustomFieldInput>>;
  /** The interval at which the plan charges (expiration plans). */
  expirationDays?: InputMaybe<Scalars["Int"]["input"]>;
  /** The price of the upsell. */
  initialPrice?: InputMaybe<Scalars["Float"]["input"]>;
  /** The method of release for the upsell. */
  releaseMethod?: InputMaybe<ReleaseMethod>;
};

/** The different types of upsells an experience can have. */
export enum UpsellTypes {
  /** After Checkout */
  AfterCheckout = "after_checkout",
  /** Before Checkout */
  BeforeCheckout = "before_checkout",
  /** Only In Whop */
  OnlyInWhop = "only_in_whop",
}

/** An object representing a user */
export type User = {
  __typename?: "User";
  /** Fetch a specific abuse report */
  abuseReport: PublicAbuseReportInterface;
  /** The access pass affiliates for the user. */
  accessPassAffiliates: AccessPassAffiliateConnection;
  /** The access pass member for the user */
  accessPassMember?: Maybe<AccessPassMember>;
  /** Returns the ordered access pass members for the user */
  accessPassMembers: AccessPassMemberConnection;
  /** All of the access passes the user has memberships for. */
  accessPasses: Array<PublicAccessPass>;
  /** The apps the user has access to */
  accessibleApps: Array<PublicApp>;
  /** All experiences the user has access to. */
  accessibleExperiences: AccessibleExperienceConnection;
  /** All of the experiences the user owns that are active. */
  activeOwnedExperienceIds: Array<Scalars["ID"]["output"]>;
  /** Whether the user is an admin */
  admin: Scalars["Boolean"]["output"];
  /** The total monthly expected affiliate earnings, multiplied by 12. */
  affiliateArr: Scalars["String"]["output"];
  /** The total amount of expected affiliate earnings in the next 30 days. */
  affiliateExpectedEarnings: Scalars["String"]["output"];
  /**
   * The number of link clicks this user had for their affiliate links this month
   * @deprecated No longer implemented.
   */
  affiliateLinkClicksThisMonth: Scalars["Int"]["output"];
  /** The total amount of affiliate referral earnings */
  affiliateReferralEarnings: Scalars["String"]["output"];
  /** All of the referral logs connected to a user */
  affiliateReferralLogs: UserAffiliateReferralLogConnection;
  /** Whether or not the user allow DMs from anyone. */
  allowDmsFromAnyone: Scalars["Boolean"]["output"];
  /** Whether or not the user has applied to be a seller */
  appliedToBeSeller: Scalars["Boolean"]["output"];
  /** Fetch all distinct authorized balance cache currencies for this user */
  authorizedBalanceCacheCurrencies: Array<Currencies>;
  /** Fetch all authorized ledger accounts for this user */
  authorizedLedgerAccounts: LedgerAccountConnection;
  /** The authorized user for the user and company. */
  authorizedUser?: Maybe<AuthorizedUser>;
  /** The authorized users for the user */
  authorizedUsers: AuthorizedUserConnection;
  /** The amount of money the user is able to withdraw from their account */
  balance: Scalars["Float"]["output"];
  /** The user's banner image */
  bannerImage?: Maybe<Scalars["File"]["output"]>;
  /** The user's bio */
  bio?: Maybe<Scalars["String"]["output"]>;
  /** One bulk task */
  bulkTask: BulkTask;
  /** All of the bulk tasks the user has made. */
  bulkTasks: BulkTaskConnection;
  /** The amount a user has been paid out for business affiliates grouped by day */
  businessAffiliateLogsByDay: Scalars["JSON"]["output"];
  /** The business affiliates payout length */
  businessAffiliatePayoutLength: Scalars["Float"]["output"];
  /** The business affiliates payout percentage */
  businessAffiliatePayoutPercentage: Scalars["Float"]["output"];
  /** The status of the user's business affiliate application */
  businessAffiliateStatus: BusinessAffiliateStatuses;
  /** The total number of companies this user has referred. */
  businessAffiliatesCount: Scalars["Int"]["output"];
  /** The total amount of money this user has earned from referring companies. */
  businessAffiliatesEarnings: Scalars["String"]["output"];
  /** The company that the user has referred to Whop. */
  businessAffiliatesV2: BusinessAffiliateConnection;
  /** Whether or not the user owns a company on Whop business. */
  businessUser: Scalars["Boolean"]["output"];
  /** Whether or not the user can join the access pass */
  canJoinAccessPass: AccessPassControlCenterJoinEligibility;
  /** Whether or not the user can review the access pass. */
  canReviewAccessPass: AccessPassReviewEligibility;
  /** All of the chat experiences the user has access to. */
  chatExperiences: PublicExperienceConnection;
  /** All of the companies the user is an AuthorizedUser for. */
  companies: Array<Company>;
  /** All of the companies the user is an AuthorizedUser for. */
  companiesV2: CompanyConnection;
  /** All of the access passes the user has access to in the composer grouped by company */
  composerAccessPasses: AccessPassConnection;
  /** Retrieve a specific content reward for this user */
  contentRewardsSubmission: Submission;
  /** The content rewards submissions for the user. */
  contentRewardsSubmissions: SubmissionConnection;
  /** The timestamp of when the user was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether the user owns a bot that has a negative balance */
  createdBotsHaveDebt: Scalars["Boolean"]["output"];
  /** An array of crypto wallets that the user has connected to their account */
  cryptoWallets: CryptoWalletConnection;
  /** The current leaderboard rank for the user. */
  currentLeaderboardRank: LeaderboardSingle;
  /** The day of the user's date of birth */
  dateOfBirthDay?: Maybe<Scalars["Int"]["output"]>;
  /** The month of the user's date of birth */
  dateOfBirthMonth?: Maybe<Scalars["Int"]["output"]>;
  /** The year of the user's date of birth */
  dateOfBirthYear?: Maybe<Scalars["Int"]["output"]>;
  /** The default withdrawal method the user has set */
  defaultWithdrawalMethod?: Maybe<Scalars["String"]["output"]>;
  /** Current state of the user's direct message notification badges */
  directMessageNotificationBadges: DirectMessageNotificationBadgeConnection;
  /** Current state of the user's direct message notification badges */
  directMessageNotificationBadgesV2: Array<DirectMessageNotificationBadge>;
  /** Search for users when creating DMs & GCs */
  directMessagesUserSearch: DirectMessagesUserSearch;
  /** The Discord ID of the user's default Discord account. */
  discordAccountId?: Maybe<Scalars["String"]["output"]>;
  /** The Discord username set on the default Discord connected to the user's Whop account */
  discordUsername?: Maybe<Scalars["String"]["output"]>;
  /** All of the discord accounts connected to the user. */
  discords: Array<DiscordAccount>;
  /** The Discord accounts connected to the user for login and role assignment. */
  discordsV2: DiscordAccountConnection;
  /** The last unread notification for this user for an experience */
  earliestUnreadNotification?: Maybe<PublicNotification>;
  /** The earnings reports for the user. */
  earningsReports: EarningsReportConnection;
  /** The email address of the user */
  email?: Maybe<Scalars["String"]["output"]>;
  /** The entries the user has made. */
  entries: PublicEntryConnection;
  /** A specific entry for the user. */
  entry: PublicEntry;
  /**
   * Fetch all the experiences the user has access to
   * @deprecated Use experiences_from_access_passes for whop 4
   */
  experiences: PublicExperienceInterfaceConnection;
  /** Fetch all the experiences the user has access to */
  experiencesFromAccessPasses: PublicExperienceConnection;
  /**
   * All experiences the user has along with their associated notification information. Sorted by most recent notification first, then last viewed at.
   * @deprecated Unused
   */
  experiencesWithNotifications: Array<ExperienceWithNotification>;
  /** Reason for failed email delivery */
  failedEmailDelivery?: Maybe<Scalars["String"]["output"]>;
  /** All of the access passes the user has favorited. */
  favoriteAccessPasses: PublicAccessPassConnection;
  /** All of the user's Firebase Cloud Messaging tokens. */
  fcmTokens: Array<Scalars["String"]["output"]>;
  /** An array of features this user has access to */
  features: Array<Scalars["String"]["output"]>;
  /** The amount of money the user is able to withdraw from their account, formatted as a string. */
  formattedBalance: Scalars["String"]["output"];
  /** The amount of money that the user has earned but is pending release to be able to be withdrawn, formatted as a string. */
  formattedPendingBalance: Scalars["String"]["output"];
  /** Whether or not the user has access pass affiliates. */
  hasAccessPassAffiliates: Scalars["Boolean"]["output"];
  /** Returns true or false depending on whether or not the user has access to this access passes experiences. */
  hasAccessToAccessPassExperiences: Scalars["Boolean"]["output"];
  /** Whether or not the user has an active membership */
  hasActiveMembership: Scalars["Boolean"]["output"];
  /** Whether or not the user has the business app installed. */
  hasBusinessApp: Scalars["Boolean"]["output"];
  /** Whether or not the user has investigation access. */
  hasInvestigationAccess: Scalars["Boolean"]["output"];
  /** Whether or not the user has the marketplace app installed. */
  hasMarketplaceApp: Scalars["Boolean"]["output"];
  /** Whether the user has parental consent for an action (used with KYC, content rewards submission, etc.) */
  hasParentalConsent: Scalars["Boolean"]["output"];
  /** Whether or not the user has available raffles */
  hasRaffles: Scalars["Boolean"]["output"];
  /** Whether or not the user has available waitlists */
  hasWaitlists: Scalars["Boolean"]["output"];
  /** All the accessible experiences the user has muted on the home feed. */
  homeFeedMutedAccessibleExperiences: AccessibleExperienceConnection;
  /** The recent searches the user has made for the hub. */
  hubRecentSearches: RecentSearchConnection;
  /** Search for the creator dashboard. */
  hubSearch: HubSearch;
  /** The internal ID of the user */
  id: Scalars["ID"]["output"];
  /** Intercom authentication hash */
  intercomHash: Scalars["String"]["output"];
  /** Whether or not the user has investigation enabled. */
  investigationEnabled: Scalars["Boolean"]["output"];
  /** Whether or not the user is a minor */
  isMinor: Scalars["Boolean"]["output"];
  /** Whether or not the user is able to receive payments */
  isPayable: Scalars["Boolean"]["output"];
  /** The user's item ordering. */
  itemOrdering: ItemOrdering;
  /** All of the access passes the user has joined. */
  joinedAccessPasses: PublicAccessPassConnection;
  /**
   * The companies the user joined.
   * @deprecated Use joinedAccessPasses instead.
   */
  joinedWhops: PublicCompanyConnection;
  /** The last time the user was active. */
  lastSeenAt: Scalars["Timestamp"]["output"];
  /** The user's ledger account. */
  ledgerAccount: LedgerAccount;
  /** Fetches all the discover access passes the user has liked */
  likedDiscoverAccessPasses: PublicAccessPassConnection;
  /** Fetches all the discover access passes the user has liked */
  likedDiscoverAccessPassesV2: LikedAccessPassConnection;
  /** The live livestream feeds the user has access to */
  liveLivestreamFeeds: LivestreamFeedConnection;
  /** The livestream stream keys for the user. */
  livestreamStreamKeys: Array<LivestreamStreamKey>;
  /** Custom rates or passholder settings the user has been added to refer */
  madeForYouPlans: MadeForYouPlanConnection;
  /** Whether the user is a manager */
  manager: Scalars["Boolean"]["output"];
  /** A specific member of the user's company. */
  member: PublicMember;
  /** All of the members of the user's company. */
  members: PublicMemberConnection;
  /** A membership object that belongs to the user. */
  membership: PublicMembership;
  /** All memberships of the user */
  membershipByExperienceId?: Maybe<PublicMembership>;
  /** All memberships of the user */
  memberships: PublicMembershipConnection;
  /** All memberships of the user */
  membershipsByPlanId: PublicMembershipConnection;
  /** The wallets a user has connected to their account */
  metamaskWallets: Array<MetamaskWallet>;
  /** How long notifications are paused until. */
  mobilePushPausedUntil?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether the user is a moderator */
  mod: Scalars["Boolean"]["output"];
  /** The name of the user */
  name?: Maybe<Scalars["String"]["output"]>;
  /**
   * The token that is associated with a user's mobile device
   * @deprecated Use the FCM token table
   */
  newFcmTokens: Array<FcmToken>;
  /** Current state of the user's notification badges */
  notificationBadges: NotificationBadgeConnection;
  /** The user's notification preferences */
  notificationPreferencesV2: UserNotificationPreferenceConnection;
  /** Fetch all the notifications for the user */
  notificationsV4: PublicNotificationConnection;
  /** The old Whop ID used to identify users (integer). */
  ogId: Scalars["Int"]["output"];
  /** Array of criteria the user must follow to complete onboarding */
  onboardingSteps: UserOnboardingSteps;
  /** All of a user's payments */
  orderHistory: PublicReceiptConnection;
  /** All of the access passes the user owns. */
  ownedAccessPasses: PublicAccessPassConnection;
  /** Fetch all the experiences the user is a team member of */
  ownedExperiences: ExperienceConnection;
  /**
   * The companies the user owns.
   * @deprecated Use ownedAccessPasses instead.
   */
  ownedWhops: PublicCompanyConnection;
  /** The number of paid memberships the user has */
  paidMembershipsCount: Scalars["Int"]["output"];
  /** All payment methods of the user */
  paymentMethods: PaymentMethodConnection;
  /** All payment tokens of the user */
  paymentTokens: PaymentTokenConnection;
  /** The amount of money that the user has earned but is pending release to be able to be withdrawn. */
  pendingBalance: Scalars["Float"]["output"];
  /** The level of access a user has to a company's Whop dashboard */
  permissionLevel?: Maybe<Scalars["Int"]["output"]>;
  /** Discovery Tags associated to this user (ordered by relevance) */
  personalizedDiscoveryTags: DiscoveryTagConnection;
  /** The phone number of the user */
  phone?: Maybe<Scalars["String"]["output"]>;
  /** Whether or not the user's phone is verified */
  phoneVerified: Scalars["Boolean"]["output"];
  /** The primary Discord ID for the user */
  primaryDiscordId?: Maybe<Scalars["Int"]["output"]>;
  /**
   * The URL of the user's profile picture
   * @deprecated Use profileImageSrcset instead
   */
  profilePic: Scalars["String"]["output"];
  /** The user's profile image. Deprecated, use profilePicture instead. */
  profilePicSrcset: ImgSrcset;
  /** The user's profile picture */
  profilePicture?: Maybe<AttachmentInterface>;
  /** A receipt object that belongs to the user. */
  receipt: PublicReceipt;
  /** All of a user's receipts. */
  receipts: PublicReceiptConnection;
  /** The total number of receipts a user has */
  receiptsCount: Scalars["Int"]["output"];
  /** The most recent apps the user has interacted with. */
  recentExperiences: Array<PublicExperience>;
  /** All of the access passes the user has joined. Recently joined first. */
  recentlyJoinedAccessPasses: PublicAccessPassConnection;
  /** The number of memberships this user has been an affiliate for */
  referralsCount: Scalars["Int"]["output"];
  /** A specific resolution for the user. */
  resolution: PublicResolution;
  /** Whether or not the user has a resolution that requires a response. */
  resolutionRequiresResponse: Scalars["Boolean"]["output"];
  /** The resolutions that the user has created */
  resolutions: PublicResolutionConnection;
  /** Resolve an experience ID to a full path */
  resolveMobileExperience: ResolvedMobileExperience;
  /** A review the user has made for a given an access pass, if they have made one. */
  review?: Maybe<Review>;
  /** All reviews the user has made. */
  reviews: ReviewConnection;
  /** What role the user has in respect to the context of the current company. */
  role?: Maybe<AuthorizedUserRoles>;
  /** The roles a user has */
  roles: Array<Scalars["String"]["output"]>;
  /**
   * Whether or not the user is an approved bot rental seller
   * @deprecated No longer used
   */
  seller: Scalars["Boolean"]["output"];
  /**
   * The tier of seller the user is
   * @deprecated No longer used
   */
  sellerTier: Scalars["String"]["output"];
  /** Fetches the user's simple notification preference for a given experience */
  simpleNotificationPreference: SimpleNotificationPreferenceStatus;
  /** The list of social accounts a user has set */
  socialAccounts: Array<SocialAccount>;
  /** The social links for the user. */
  socialLinks: UserSocialLinksConnection;
  /** Whether or not the user is an authorized support user */
  support: Scalars["Boolean"]["output"];
  /** Whether or not the user is suspended on Whop */
  suspended: Scalars["Boolean"]["output"];
  /** The code representing why the user was suspended. */
  suspensionCode?: Maybe<Scalars["String"]["output"]>;
  /** Why the user was suspended, if they were/are suspended. */
  suspensionReason?: Maybe<Scalars["String"]["output"]>;
  /** Search for a telegram account using the verification code provided */
  telegramAccount?: Maybe<TelegramAccount>;
  /** This user's known Telegram accounts */
  telegramAccounts: TelegramAccountConnection;
  /** Whether the user is a tester */
  tester: Scalars["Boolean"]["output"];
  /** This user's TradingView username (if any is set) */
  tradingViewUsername?: Maybe<Scalars["String"]["output"]>;
  /** The X account connected to the user. */
  twitterAccount?: Maybe<TwitterAccount>;
  /** Whether or not the user has 2FA enabled */
  twoFactor: Scalars["Boolean"]["output"];
  /** The type of 2FA the user has set. If null, the user does not have 2fa enabled. */
  twoFactorMethod?: Maybe<AuthenticationMethods>;
  /** Whether or not the user has an unassigned email */
  unassignedEmail: Scalars["Boolean"]["output"];
  /** An array of mutable wallet strings that used for raffles so users don't need to sign transactions to add them */
  unverifiedWallets: Array<Scalars["String"]["output"]>;
  /**
   * The amount of money the user can spend with Whop Cash
   * @deprecated No longer implemented.
   */
  usableBalance: Scalars["Float"]["output"];
  /** Whether or not the user used Tipalti, our old withdrawals system. */
  usedTipalti: Scalars["Boolean"]["output"];
  /** The charts for the user. */
  userCharts: UserCharts;
  /** The user preferences for this user. */
  userPreferences: UserPreference;
  /** Earning statistics for this user. */
  userStat?: Maybe<UserStat>;
  /** The Whop username for this user */
  username: Scalars["String"]["output"];
  /** All of a user's valid memberships */
  validMemberships: PublicMembershipConnection;
  /** The VAT ID of the user */
  vatId?: Maybe<Scalars["String"]["output"]>;
  /**
   * The Whop crypto wallet address of the user
   * @deprecated No longer used
   */
  whopCryptoWallet?: Maybe<Scalars["String"]["output"]>;
  /** The withdrawals the user has made. */
  withdrawals: PublicWithdrawalConnection;
  /** The forum experiences the user can write to */
  writeableForumExperiences: PublicExperienceConnection;
};

/** An object representing a user */
export type UserAbuseReportArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
  resourceId?: InputMaybe<Scalars["ID"]["input"]>;
  resourceType?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a user */
export type UserAccessPassAffiliatesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<AccessPassAffiliateStatuses>;
};

/** An object representing a user */
export type UserAccessPassMemberArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserAccessPassMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a user */
export type UserAccessPassesArgs = {
  id?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An object representing a user */
export type UserAccessibleExperiencesArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  appInternalIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  excludeAppInternalIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  happeningNow?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeDraftExperiences?: InputMaybe<Scalars["Boolean"]["input"]>;
  includeUpsellExperiences?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserActiveOwnedExperienceIdsArgs = {
  companyId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserAffiliateReferralLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<UserAffiliateReferralLogFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserAuthorizedLedgerAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasBalanceInCurrency?: InputMaybe<Currencies>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserAuthorizedUserArgs = {
  companyId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserAuthorizedUsersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserBulkTaskArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserBulkTasksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserBusinessAffiliatesV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserCanJoinAccessPassArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserCanReviewAccessPassArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserChatExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserCompaniesArgs = {
  companyType?: InputMaybe<CompanyTypes>;
  direction?: InputMaybe<Direction>;
  isApp?: InputMaybe<Scalars["Boolean"]["input"]>;
  order?: InputMaybe<CompaniesOrder>;
};

/** An object representing a user */
export type UserCompaniesV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyType?: InputMaybe<CompanyTypes>;
  direction?: InputMaybe<Direction>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  isApp?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<CompaniesOrder>;
};

/** An object representing a user */
export type UserComposerAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a user */
export type UserContentRewardsSubmissionArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserContentRewardsSubmissionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<UserContentRewardsSubmissionsFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserCryptoWalletsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserCurrentLeaderboardRankArgs = {
  leaderboardType: LeaderboardTypes;
};

/** An object representing a user */
export type UserDirectMessageNotificationBadgesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status: DirectMessageStatus;
};

/** An object representing a user */
export type UserDirectMessageNotificationBadgesV2Args = {
  status?: InputMaybe<DirectMessageStatus>;
};

/** An object representing a user */
export type UserDirectMessagesUserSearchArgs = {
  excludeUserIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  query: Scalars["String"]["input"];
};

/** An object representing a user */
export type UserDiscordsV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserEarliestUnreadNotificationArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserEarningsReportsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<EarningsReportPeriods>;
};

/** An object representing a user */
export type UserEntriesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  entryType?: InputMaybe<EntryTypes>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  status?: InputMaybe<PerkStatus>;
};

/** An object representing a user */
export type UserEntryArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  experienceIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  experienceType?: InputMaybe<ExperienceTypes>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  hasTopics?: InputMaybe<Scalars["Boolean"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserExperiencesFromAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserExperiencesWithNotificationsArgs = {
  appInternalIdentifier?: InputMaybe<Scalars["ID"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserFavoriteAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserHasAccessToAccessPassExperiencesArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserHasActiveMembershipArgs = {
  accessPassId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserHomeFeedMutedAccessibleExperiencesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  appInternalIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserHubRecentSearchesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserHubSearchArgs = {
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  experienceId?: InputMaybe<Scalars["String"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
  query: Scalars["String"]["input"];
};

/** An object representing a user */
export type UserItemOrderingArgs = {
  orderType: ItemOrderingOrderTypes;
};

/** An object representing a user */
export type UserJoinedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserJoinedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserLikedDiscoverAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserLikedDiscoverAccessPassesV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  order?: InputMaybe<LikedDiscoverAccessPassesOrder>;
};

/** An object representing a user */
export type UserLiveLivestreamFeedsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserMadeForYouPlansArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<MadeForYouPlanFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserMemberArgs = {
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An object representing a user */
export type UserMembersArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  statuses?: InputMaybe<Array<MemberStatuses>>;
};

/** An object representing a user */
export type UserMembershipArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserMembershipByExperienceIdArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserMembershipsArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  validStatus?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** An object representing a user */
export type UserMembershipsByPlanIdArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  planId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserNotificationBadgesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  clientLastFetchedAt?: InputMaybe<Scalars["Timestamp"]["input"]>;
  experienceIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserNotificationPreferencesV2Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<NotificationPreferencesFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserNotificationsV4Args = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<NotificationsV4Filters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  pagination?: InputMaybe<NotificationsV4Pagination>;
};

/** An object representing a user */
export type UserOnboardingStepsArgs = {
  clientSupportedIdentifiers?: InputMaybe<Array<Scalars["String"]["input"]>>;
  deviceType?: InputMaybe<Device>;
};

/** An object representing a user */
export type UserOrderHistoryArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<UserReceiptFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserOwnedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserOwnedExperiencesArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  accessPassIds?: InputMaybe<Array<Scalars["ID"]["input"]>>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  appInternalIdentifier: Scalars["String"]["input"];
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserOwnedWhopsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserPaymentMethodsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  planId?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An object representing a user */
export type UserPaymentTokensArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  broken?: InputMaybe<Scalars["Boolean"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  gatewayType: GatewayTypes;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserPersonalizedDiscoveryTagsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserProfilePicSrcsetArgs = {
  allowAnimation?: InputMaybe<Scalars["Boolean"]["input"]>;
  extension?: ImageExtensions;
  size?: InputMaybe<Scalars["Int"]["input"]>;
  style?: InputMaybe<AvatarImageStyles>;
};

/** An object representing a user */
export type UserReceiptArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserReceiptsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserRecentExperiencesArgs = {
  appInternalIdentifier?: InputMaybe<Scalars["ID"]["input"]>;
  limit?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserRecentlyJoinedAccessPassesArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserResolutionArgs = {
  id: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserResolutionsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<ResolutionFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserResolveMobileExperienceArgs = {
  experienceId: Scalars["ID"]["input"];
  restPath?: InputMaybe<Scalars["String"]["input"]>;
};

/** An object representing a user */
export type UserReviewArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  id?: InputMaybe<Scalars["ID"]["input"]>;
};

/** An object representing a user */
export type UserReviewsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserSimpleNotificationPreferenceArgs = {
  experienceId: Scalars["ID"]["input"];
};

/** An object representing a user */
export type UserSocialLinksArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserTelegramAccountArgs = {
  code: Scalars["String"]["input"];
};

/** An object representing a user */
export type UserTelegramAccountsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserUserChartsArgs = {
  config: UserChartConfigInput;
};

/** An object representing a user */
export type UserValidMembershipsArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  companyId?: InputMaybe<Scalars["ID"]["input"]>;
  direction?: InputMaybe<Direction>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  lifetime?: InputMaybe<Scalars["Boolean"]["input"]>;
  order?: InputMaybe<ValidMembershipsOrder>;
  status?: InputMaybe<HubMembershipStatus>;
};

/** An object representing a user */
export type UserWithdrawalsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  filter?: InputMaybe<UserWithdrawalFilters>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** An object representing a user */
export type UserWriteableForumExperiencesArgs = {
  accessPassId?: InputMaybe<Scalars["ID"]["input"]>;
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
};

/** A log of a user's affiliate referral activity. */
export type UserAffiliateReferralLog = {
  __typename?: "UserAffiliateReferralLog";
  /** The type of affiliate. */
  affiliateType?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the affiliate user. */
  affiliateUserId?: Maybe<Scalars["ID"]["output"]>;
  /** The username of the affiliate. */
  affiliateUsername?: Maybe<Scalars["String"]["output"]>;
  /** The amount the affiliate was paid for the referral. */
  amount?: Maybe<Scalars["String"]["output"]>;
  /** The internal ID of the buyer. */
  buyerId?: Maybe<Scalars["ID"]["output"]>;
  /** The username of the buyer. */
  buyerUsername?: Maybe<Scalars["String"]["output"]>;
  /** The company of the plan the buyer purchased. */
  company?: Maybe<PublicCompany>;
  /** The date the log was created. */
  createdAt?: Maybe<Scalars["Timestamp"]["output"]>;
  /** Whether or not this is the first payment for the plan. */
  firstPayment?: Maybe<Scalars["Boolean"]["output"]>;
  /** The internal ID of the log. */
  id?: Maybe<Scalars["ID"]["output"]>;
  /** The receipt for the referral. */
  receipt?: Maybe<NotLoggedInReceipt>;
};

/** The connection type for UserAffiliateReferralLog. */
export type UserAffiliateReferralLogConnection = {
  __typename?: "UserAffiliateReferralLogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserAffiliateReferralLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserAffiliateReferralLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserAffiliateReferralLogEdge = {
  __typename?: "UserAffiliateReferralLogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserAffiliateReferralLog>;
};

/** Filters for the user affiliate referral logs search */
export type UserAffiliateReferralLogFilters = {
  /** Which direction the order should be in. */
  direction?: InputMaybe<Direction>;
  /** How you want to order the results. */
  order?: InputMaybe<UserAffiliateReferralLogOrder>;
  /** What to search by: whop username, access pass name, or bot title */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The order to sort the logs by */
export enum UserAffiliateReferralLogOrder {
  Id = "id",
}

/** The configuration for a chart. */
export type UserChartConfigInput = {
  /** The currency to use for the chart. */
  currency?: InputMaybe<Currencies>;
  /** The start date to take into account. */
  from: Scalars["Timestamp"]["input"];
  /** The interval to group the data by. */
  interval?: InputMaybe<ChartIntervals>;
  /** The time zone used for start of day calculations. */
  timeZone?: InputMaybe<Scalars["String"]["input"]>;
  /** The end date to take into account. */
  to: Scalars["Timestamp"]["input"];
  /** The week mode to group the data by. For details, look at https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#toweek */
  weekMode?: InputMaybe<Scalars["Int"]["input"]>;
};

/** Stats for a user. */
export type UserCharts = {
  __typename?: "UserCharts";
  /** The time zone used for the charts. */
  timeZone: Scalars["String"]["output"];
  /** Total company referrals. */
  totalCompanyReferrals: ChartsDataNumber;
  /** Total referrals. */
  totalReferrals: ChartsDataNumber;
  /** Total rewards. */
  totalRewards: ChartsDataNumber;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: "UserConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** Values to filter content rewards submissions on */
export type UserContentRewardsSubmissionsFilters = {
  /** The campaign ID to filter by */
  campaignId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The direction to order by */
  direction?: InputMaybe<Direction>;
  /** The experience ID to filter by */
  experienceId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The order to sort the results by */
  order?: InputMaybe<UserContentRewardsSubmissionsOrder>;
  /** The status of the submissions */
  status?: InputMaybe<ContentRewardsSubmissionStatus>;
};

/** The ordering options for content rewards submissions */
export enum UserContentRewardsSubmissionsOrder {
  AmountPaidOut = "amount_paid_out",
  CreatedAt = "created_at",
  ExpiresAt = "expires_at",
  TotalViewCount = "total_view_count",
}

/** An edge in a connection. */
export type UserEdge = {
  __typename?: "UserEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** A user's notification preferences */
export type UserNotificationPreference = {
  __typename?: "UserNotificationPreference";
  /** The channel of the user notification preference */
  channel?: Maybe<UserNotificationPreferenceChannel>;
  /** The company ID of the user notification preference */
  companyId?: Maybe<Scalars["ID"]["output"]>;
  /** The company team ID of the user notification preference */
  companyTeamId?: Maybe<Scalars["ID"]["output"]>;
  /** Whether notifications for this topic are enabled */
  enabled: Scalars["Boolean"]["output"];
  /** The experience ID of the user notification preference */
  experience?: Maybe<PublicExperience>;
  /** The ID of the user notification preference */
  id: Scalars["ID"]["output"];
  /** The topic this preference belongs to */
  notificationTopic?: Maybe<NotificationTopic>;
  /** The ID of the user that owns this preference */
  userId?: Maybe<Scalars["ID"]["output"]>;
};

/** The channel of the user notification preference */
export enum UserNotificationPreferenceChannel {
  /** In App */
  InApp = "in_app",
  /** Mobile */
  Mobile = "mobile",
}

/** The connection type for UserNotificationPreference. */
export type UserNotificationPreferenceConnection = {
  __typename?: "UserNotificationPreferenceConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserNotificationPreferenceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserNotificationPreference>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserNotificationPreferenceEdge = {
  __typename?: "UserNotificationPreferenceEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserNotificationPreference>;
};

/** The data representing a specific onboarding step */
export type UserOnboardingStep = {
  __typename?: "UserOnboardingStep";
  /** Whether or not the onboarding step has been completed */
  completed: Scalars["Boolean"]["output"];
  /** The identifier of the onboarding step */
  identifier: UserOnboardingStepsTypes;
  /** Whether or not the onboarding step is required */
  required: Scalars["Boolean"]["output"];
};

/** The steps a user must follow to complete onboarding */
export type UserOnboardingSteps = {
  __typename?: "UserOnboardingSteps";
  /** The array of steps */
  allSteps: Array<UserOnboardingStep>;
  /** Whether or not all steps have been completed. */
  allStepsCompleted: Scalars["Boolean"]["output"];
  /** The current step */
  currentStep?: Maybe<UserOnboardingStepsTypes>;
};

/** The steps a user can follow to complete onboarding */
export enum UserOnboardingStepsTypes {
  AddBirthday = "add_birthday",
  AddEmail = "add_email",
  AddName = "add_name",
  AddPhone = "add_phone",
  AddProfilePicture = "add_profile_picture",
  AddUsername = "add_username",
  DownloadMobileApp = "download_mobile_app",
  JoinAWhop = "join_a_whop",
  VerifyEmail = "verify_email",
  VerifyPhone = "verify_phone",
}

/** A user's preferences */
export type UserPreference = {
  __typename?: "UserPreference";
  /** Whether or not to show the user's earnings on their profile */
  showEarnings: Scalars["Boolean"]["output"];
  /** Whether or not to show the whops they joined on their profile */
  showJoinedWhops: Scalars["Boolean"]["output"];
  /** Whether or not to show the user's location on their profile */
  showLocation: Scalars["Boolean"]["output"];
  /** Whether or not to show the whops they own on their profile */
  showOwnedWhops: Scalars["Boolean"]["output"];
  /** Whether or not to show the user's ranking on their profile */
  showUserRanking: Scalars["Boolean"]["output"];
};

/** Values to filter user receipts on */
export type UserReceiptFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What to order the results by. */
  order?: InputMaybe<UserReceiptOrder>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The order to sort the results by. */
export enum UserReceiptOrder {
  PaidAt = "paid_at",
}

/** An object representing how a user was referred. */
export type UserReferral = {
  __typename?: "UserReferral";
  /** The date the referral was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that referred this user. */
  referredByUser: PublicProfileUser;
};

/** An object representing a report on a User. */
export type UserReport = {
  __typename?: "UserReport";
  /** The date and time the report was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The evidence of the report. */
  evidence?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the Twitter account. */
  id: Scalars["ID"]["output"];
  /** The reason of the report. */
  reason?: Maybe<Scalars["String"]["output"]>;
  /** The source of the report. */
  source: UserReportSources;
  /** The status of the report. */
  status: UserReportStatuses;
  /** The user that was reported. */
  user: PublicProfileUser;
};

/** The source of the user report */
export enum UserReportSources {
  /** Auto Banned Words */
  AutoBannedWords = "auto_banned_words",
  /** Company Ban */
  CompanyBan = "company_ban",
  /** Dms Request */
  DmsRequest = "dms_request",
  /** User Profile */
  UserProfile = "user_profile",
}

/** The status of the user report */
export enum UserReportStatuses {
  /** Confirmed */
  Confirmed = "confirmed",
  /** Dismissed */
  Dismissed = "dismissed",
  /** Pending */
  Pending = "pending",
}

/** A user's eligibility to review an access pass. */
export type UserReviewEligibility = {
  __typename?: "UserReviewEligibility";
  /** Whether or not this user can be reviewed by the current user */
  canReview: Scalars["Boolean"]["output"];
  /** The reason this user cannot be reviewed by the current user. */
  reason?: Maybe<Scalars["String"]["output"]>;
};

/** The different websites you can have social links for */
export enum UserSocialLinkWebsites {
  Facebook = "facebook",
  Instagram = "instagram",
  Linkedin = "linkedin",
  Tiktok = "tiktok",
  Twitch = "twitch",
  Website = "website",
  X = "x",
  Youtube = "youtube",
}

/** A social link attached to a user's profile on the site. */
export type UserSocialLinks = {
  __typename?: "UserSocialLinks";
  /** The account ID from the social platform */
  accountId?: Maybe<Scalars["String"]["output"]>;
  /** The full name from the social platform */
  fullName?: Maybe<Scalars["String"]["output"]>;
  /** The ID */
  id: Scalars["ID"]["output"];
  /** The profile picture URL from the social platform */
  profilePic?: Maybe<Scalars["String"]["output"]>;
  /** The URL */
  url: Scalars["String"]["output"];
  /** The username from the social platform */
  username?: Maybe<Scalars["String"]["output"]>;
  /** The token used for verification */
  verificationToken?: Maybe<Scalars["String"]["output"]>;
  /** Whether the account has been verified */
  verified: Scalars["Boolean"]["output"];
  /** The website */
  website: UserSocialLinkWebsites;
};

/** The connection type for UserSocialLinks. */
export type UserSocialLinksConnection = {
  __typename?: "UserSocialLinksConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserSocialLinksEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<UserSocialLinks>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type UserSocialLinksEdge = {
  __typename?: "UserSocialLinksEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<UserSocialLinks>;
};

/** Earning statistics for this user. */
export type UserStat = {
  __typename?: "UserStat";
  /** How much the user has earned in the last 7 days. */
  moneyEarned7Days?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned in the last 24 hours. */
  moneyEarned24Hours?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned in the last 30 days. */
  moneyEarned30Days?: Maybe<Scalars["Float"]["output"]>;
  /** How much the user has earned all time. */
  moneyEarnedLifetime?: Maybe<Scalars["Float"]["output"]>;
};

/** Filters for the user withdrawals search */
export type UserWithdrawalFilters = {
  /** Which direction the order should be in. */
  direction?: InputMaybe<Direction>;
  /** How you want to order the results. */
  order?: InputMaybe<UserWithdrawalOrder>;
};

/** The order to sort the withdrawals by */
export enum UserWithdrawalOrder {
  Id = "id",
}

/** The order to sort the results by. */
export enum ValidMembershipsOrder {
  ExpiresAt = "expires_at",
  Id = "id",
}

/** A vaulting method for a payment token. */
export enum VaultMethods {
  /** Paypal Wallet */
  PaypalWallet = "paypal_wallet",
  /** Venmo Wallet */
  VenmoWallet = "venmo_wallet",
}

/** An object representing an identity verification session */
export type Verification = {
  __typename?: "Verification";
  /** A unique identifier for the verification. */
  id: Scalars["ID"]["output"];
  /** The last error code that occurred during the verification. */
  lastErrorCode?: Maybe<VerificationErrorCodes>;
  /** The last error reason that occurred during the verification. */
  lastErrorReason?: Maybe<Scalars["String"]["output"]>;
  /** The status of the verification. */
  status: VerificationStatuses;
};

/** An error code for a verification attempt. */
export enum VerificationErrorCodes {
  /** Abandoned */
  Abandoned = "abandoned",
  /** Consent Declined */
  ConsentDeclined = "consent_declined",
  /** Country Not Supported */
  CountryNotSupported = "country_not_supported",
  /** Device Not Supported */
  DeviceNotSupported = "device_not_supported",
  /** Document Expired */
  DocumentExpired = "document_expired",
  /** Document Type Not Supported */
  DocumentTypeNotSupported = "document_type_not_supported",
  /** Document Unverified Other */
  DocumentUnverifiedOther = "document_unverified_other",
  /** Email Unverified Other */
  EmailUnverifiedOther = "email_unverified_other",
  /** Email Verification Declined */
  EmailVerificationDeclined = "email_verification_declined",
  /** Id Number Insufficient Document Data */
  IdNumberInsufficientDocumentData = "id_number_insufficient_document_data",
  /** Id Number Mismatch */
  IdNumberMismatch = "id_number_mismatch",
  /** Id Number Unverified Other */
  IdNumberUnverifiedOther = "id_number_unverified_other",
  /** Phone Unverified Other */
  PhoneUnverifiedOther = "phone_unverified_other",
  /** Phone Verification Declined */
  PhoneVerificationDeclined = "phone_verification_declined",
  /** Selfie Document Missing Photo */
  SelfieDocumentMissingPhoto = "selfie_document_missing_photo",
  /** Selfie Face Mismatch */
  SelfieFaceMismatch = "selfie_face_mismatch",
  /** Selfie Manipulated */
  SelfieManipulated = "selfie_manipulated",
  /** Selfie Unverified Other */
  SelfieUnverifiedOther = "selfie_unverified_other",
  /** Under Supported Age */
  UnderSupportedAge = "under_supported_age",
}

/** A status for a verification. */
export enum VerificationStatuses {
  /** Canceled */
  Canceled = "canceled",
  /** Processing */
  Processing = "processing",
  /** Requires Input */
  RequiresInput = "requires_input",
  /** Verified */
  Verified = "verified",
}

/** The status of a bots Whop Verified. */
export enum VerifiedStatuses {
  Accepted = "accepted",
  Applied = "applied",
  Rejected = "rejected",
}

/** Autogenerated input type of VerifyEmail */
export type VerifyEmailInput = {
  /** The token (included in the email message) that confirms the request is legitimate */
  changeEmailToken?: InputMaybe<Scalars["String"]["input"]>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The token (included in the email message) that confirms the request is legitimate */
  verifyEmailToken?: InputMaybe<Scalars["String"]["input"]>;
};

/** Autogenerated input type of VerifyPhoneCode */
export type VerifyPhoneCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** A one time passcode to confirm the number. */
  otp: Scalars["String"]["input"];
  /** A 10 digit phone number. */
  phone: Scalars["String"]["input"];
  /** Whether two factor should be enabled with this phone. */
  twoFactor: Scalars["Boolean"]["input"];
};

/** Autogenerated input type of VerifyUserSocialLink */
export type VerifyUserSocialLinkInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the social link to verify */
  id: Scalars["ID"]["input"];
};

/** An object representing creations, updates, and deletions of resources */
export type Version = {
  __typename?: "Version";
  /** The changes that occurred. */
  changes?: Maybe<Array<Scalars["String"]["output"]>>;
  /** The time the version was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The event that occurred. */
  event: VersionEventTypes;
  /** A unique identifier for the version. */
  id: Scalars["ID"]["output"];
  /** A name, title, or username to help identify the resource. */
  identifier?: Maybe<Scalars["String"]["output"]>;
  /** The ID of the resource. */
  itemId: Scalars["ID"]["output"];
  /** The type of resource this is. */
  itemType: Scalars["String"]["output"];
  /**
   * The user that performed the action.
   * @deprecated This type has been deprecated
   */
  user?: Maybe<PublicUser>;
  /** The user account that performed the action. */
  userAccount?: Maybe<PublicProfileUser>;
};

/** The connection type for Version. */
export type VersionConnection = {
  __typename?: "VersionConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Version>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type VersionEdge = {
  __typename?: "VersionEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Version>;
};

/** The types of version events that are possible. */
export enum VersionEventTypes {
  Create = "create",
  Destroy = "destroy",
  Update = "update",
}

/** Filters for the version search */
export type VersionFilters = {
  /** The direction to filter the audit logs */
  direction?: InputMaybe<Direction>;
  /** To get all Audit Logs created before this certain time. */
  endDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The event type to filter by. */
  eventType?: InputMaybe<Array<VersionEventTypes>>;
  /** The object type to filter by. */
  objectType?: InputMaybe<Array<VersionObjects>>;
  /** What to order the results by. */
  order?: InputMaybe<VersionOrder>;
  /** The text that is being searched. Searches the version's identifier, which is usually a name or ID related to the object. */
  query?: InputMaybe<Scalars["String"]["input"]>;
  /** To get all Audit Logs created after this certain time. */
  startDate?: InputMaybe<Scalars["Timestamp"]["input"]>;
  /** The ID of the user who triggered this audit log */
  userId?: InputMaybe<Array<Scalars["String"]["input"]>>;
};

/** The types of objects that have versions available for them. */
export enum VersionObjects {
  AccessPass = "access_pass",
  Affiliate = "affiliate",
  AuthorizedUser = "authorized_user",
  Bot = "bot",
  DiscordServer = "discord_server",
  Experience = "experience",
  Plan = "plan",
  PromoCode = "promo_code",
  StripeAccount = "stripe_account",
}

/** The order to sort the memberships by */
export enum VersionOrder {
  Event = "event",
  Id = "id",
}

/** Represents a video attachment */
export type VideoAttachment = AttachmentInterface & {
  __typename?: "VideoAttachment";
  /** Whether the attachment has been analyzed */
  analyzed: Scalars["Boolean"]["output"];
  /** The aspect ratio of the video */
  aspectRatio?: Maybe<Scalars["Float"]["output"]>;
  /** The blurhash of the video preview */
  blurhash?: Maybe<Scalars["String"]["output"]>;
  /**
   * The size of the file in bytes
   * @deprecated Use byteSizeV2 instead
   */
  byteSize?: Maybe<Scalars["Int"]["output"]>;
  /** The size of the file in bytes */
  byteSizeV2?: Maybe<Scalars["BigInt"]["output"]>;
  /** The attachment's content type (e.g., image/jpg, video/mp4) */
  contentType?: Maybe<Scalars["String"]["output"]>;
  /** The duration of the video in milliseconds */
  duration?: Maybe<Scalars["Float"]["output"]>;
  /** The name of the file */
  filename?: Maybe<Scalars["String"]["output"]>;
  /** The height of the video */
  height?: Maybe<Scalars["Int"]["output"]>;
  /** The ID of the attachment */
  id: Scalars["ID"]["output"];
  /** The moderation result of the attachment */
  moderationResult?: Maybe<ModerationResults>;
  /** The position of the attachment */
  position?: Maybe<Scalars["Int"]["output"]>;
  /** The preview of the video */
  preview: AttachmentSource;
  /** A signed ID of the attachment to directly query the attachment */
  signedId?: Maybe<Scalars["ID"]["output"]>;
  /** The source of the attachment */
  source: AttachmentSource;
  /** The source URL of the attachment */
  sourceUrl?: Maybe<Scalars["String"]["output"]>;
  /** The width of the video */
  width?: Maybe<Scalars["Int"]["output"]>;
};

/** Represents a video attachment */
export type VideoAttachmentPreviewArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Represents a video attachment */
export type VideoAttachmentSourceArgs = {
  variant?: InputMaybe<ImageAttachmentVariants>;
};

/** Autogenerated input type of ViewReceiptDetails */
export type ViewReceiptDetailsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars["String"]["input"]>;
  /** The ID of the company that this membership is on behalf of. */
  companyBuyerId?: InputMaybe<Scalars["ID"]["input"]>;
  /** The ID of the receipt to view details on. */
  id: Scalars["ID"]["input"];
  /** The URL you want to take the user to when they return */
  redirectUrl?: InputMaybe<Scalars["UrlString"]["input"]>;
};

/** The current viewer/scope of the query. */
export type Viewer = {
  __typename?: "Viewer";
  /** The company the viewer is in scope of. */
  company?: Maybe<Company>;
  /** The user the viewer is in scope of. */
  user: User;
};

/** Visibility of a resource */
export enum Visibility {
  /** Archived */
  Archived = "archived",
  /** Hidden */
  Hidden = "hidden",
  /** Quick Link */
  QuickLink = "quick_link",
  /** Visible */
  Visible = "visible",
}

/** The different levels of visibility for resources */
export enum VisibilityFilter {
  All = "all",
  /** Archived */
  Archived = "archived",
  /** Hidden */
  Hidden = "hidden",
  NotArchived = "not_archived",
  NotQuickLink = "not_quick_link",
  /** Quick Link */
  QuickLink = "quick_link",
  /** Visible */
  Visible = "visible",
}

/** A webhook object, which can be configured to be sent updates about a company */
export type Webhook = {
  __typename?: "Webhook";
  /** The API version for this webhook */
  apiVersion: ApiVersion;
  /** The timestamp of when the webhook was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** Whether or not this webhook is turned on or not */
  enabled: Scalars["Boolean"]["output"];
  /** The number of events this webhooks is configured to receive */
  events: Array<WebhookEvent>;
  /** The ID of the webhook */
  id: Scalars["ID"]["output"];
  /** The resource ID */
  resourceId: Scalars["ID"]["output"];
  /** The URL the webhook events will be sent to */
  url: Scalars["UrlString"]["output"];
  /** The webhook logs for a specific webhook. */
  webhookLogs: WebhookLogConnection;
  /** A unique secret key that will be sent with each webhook event */
  webhookSecret: Scalars["String"]["output"];
};

/** A webhook object, which can be configured to be sent updates about a company */
export type WebhookWebhookLogsArgs = {
  after?: InputMaybe<Scalars["String"]["input"]>;
  before?: InputMaybe<Scalars["String"]["input"]>;
  first?: InputMaybe<Scalars["Int"]["input"]>;
  last?: InputMaybe<Scalars["Int"]["input"]>;
  successful?: InputMaybe<Scalars["Boolean"]["input"]>;
};

/** The connection type for Webhook. */
export type WebhookConnection = {
  __typename?: "WebhookConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WebhookEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Webhook>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type WebhookEdge = {
  __typename?: "WebhookEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<Webhook>;
};

/** The different event types available */
export enum WebhookEvent {
  AppMembershipCancelAtPeriodEndChanged = "app_membership_cancel_at_period_end_changed",
  AppMembershipWentInvalid = "app_membership_went_invalid",
  AppMembershipWentValid = "app_membership_went_valid",
  AppPaymentFailed = "app_payment_failed",
  AppPaymentPending = "app_payment_pending",
  AppPaymentSucceeded = "app_payment_succeeded",
  DisputeCreated = "dispute_created",
  DisputeUpdated = "dispute_updated",
  MembershipCancelAtPeriodEndChanged = "membership_cancel_at_period_end_changed",
  MembershipExperienceClaimed = "membership_experience_claimed",
  MembershipMetadataUpdated = "membership_metadata_updated",
  MembershipWentInvalid = "membership_went_invalid",
  MembershipWentValid = "membership_went_valid",
  PaymentAffiliateRewardCreated = "payment_affiliate_reward_created",
  PaymentFailed = "payment_failed",
  PaymentPending = "payment_pending",
  PaymentSucceeded = "payment_succeeded",
  RefundCreated = "refund_created",
  RefundUpdated = "refund_updated",
}

/** A log for a webhook for a resource. */
export type WebhookLog = {
  __typename?: "WebhookLog";
  /** The time the webhook was created. */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the webhook log. */
  id: Scalars["ID"]["output"];
  /** The request body of the webhook. */
  requestBody: Scalars["JSON"]["output"];
  /** The response code of the webhook. */
  responseCode: Scalars["Int"]["output"];
  /** Whether or not the webhook was successful. */
  success: Scalars["Boolean"]["output"];
  /** The URL of the webhook. */
  url: Scalars["UrlString"]["output"];
};

/** The connection type for WebhookLog. */
export type WebhookLogConnection = {
  __typename?: "WebhookLogConnection";
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WebhookLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WebhookLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The total number of items in this connection. */
  totalCount: Scalars["Int"]["output"];
};

/** An edge in a connection. */
export type WebhookLogEdge = {
  __typename?: "WebhookLogEdge";
  /** A cursor for use in pagination. */
  cursor: Scalars["String"]["output"];
  /** The item at the end of the edge. */
  node?: Maybe<WebhookLog>;
};

/** The response of a testing a webhook */
export type WebhookTestResult = {
  __typename?: "WebhookTestResult";
  /** The body of the webhook response */
  body: Scalars["JSON"]["output"];
  /** The HTTP response code of this request */
  status: Scalars["Int"]["output"];
  /** Whether or not the webhook test was successful */
  success: Scalars["Boolean"]["output"];
};

/** The anchor for when the Connected Account will be paid out */
export enum WeeklyAnchors {
  Friday = "friday",
  Monday = "monday",
  Saturday = "saturday",
  Sunday = "sunday",
  Thursday = "thursday",
  Tuesday = "tuesday",
  Wednesday = "wednesday",
}

/** Represents a wheel with its details */
export type Wheel = {
  __typename?: "Wheel";
  /** When the wheel was created */
  createdAt: Scalars["Timestamp"]["output"];
  /** The ID of the wheel */
  id: Scalars["ID"]["output"];
};

/** An experience activity card about a wheel */
export type WheelCard = ExperienceActivityCardInterface & {
  __typename?: "WheelCard";
  /** The type of the activity card */
  cardType: ExperienceActivityCardTypes;
  /** When this activity happened */
  createdAt: Scalars["Timestamp"]["output"];
  /** The user that authored this activity */
  user?: Maybe<PublicProfileUser>;
  /** The wheel that this card is about */
  wheel?: Maybe<Wheel>;
};

/** Who can post on a chat feed */
export enum WhoCanPostTypes {
  Admins = "admins",
  Everyone = "everyone",
}

/** Who can react on a chat feed */
export enum WhoCanReactTypes {
  Everyone = "everyone",
  NoOne = "no_one",
}

/** Values to filter users on */
export type WhopSidebarFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What to order the results by. */
  order?: InputMaybe<WhopSidebarOrderEnum>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The order to sort the results by. */
export enum WhopSidebarOrderEnum {
  DateJoined = "date_joined",
  LastSeenAt = "last_seen_at",
  Name = "name",
  PaidOutByCompany = "paid_out_by_company",
  TimeSpentInWhop = "time_spent_in_whop",
}

/** Values to filter users on */
export type WhopSidebarWithEarningsFilters = {
  /** How to order the results. */
  direction?: InputMaybe<Direction>;
  /** What to order the results by. */
  order?: InputMaybe<WhopSidebarWithEarningsOrderEnum>;
  /** The text that is being searched. */
  query?: InputMaybe<Scalars["String"]["input"]>;
};

/** The order to sort the results by. */
export enum WhopSidebarWithEarningsOrderEnum {
  Last_7Days = "last_7_days",
  Last_24Hours = "last_24_hours",
  Last_30Days = "last_30_days",
  Lifetime = "lifetime",
}

/** Values to filter the withdrawals on. */
export type WithdrawalFilters = {
  /** Filter by currency */
  currency?: InputMaybe<Currencies>;
  /** The withdrawal status/state */
  statuses?: InputMaybe<Array<WithdrawalStatus>>;
};

/** The method used for withdrawing Whop credits. */
export enum WithdrawalMethods {
  Ach = "ach",
  Btc = "btc",
  CashApp = "cash_app",
  Check = "check",
  Echeck = "echeck",
  Manual = "manual",
  Paypal = "paypal",
  Stripe = "stripe",
  Venmo = "venmo",
  WireTransfer = "wire_transfer",
  Zelle = "zelle",
}

/** The statuses a review can have */
export enum WithdrawalProviders {
  /** Manual */
  Manual = "manual",
  /** Stripe */
  Stripe = "stripe",
  /** Tipalti */
  Tipalti = "tipalti",
}

/** The different speeds of withdrawals */
export enum WithdrawalSpeeds {
  /** Instant */
  Instant = "instant",
  /** Standard */
  Standard = "standard",
}

/** The status of a withdrawal request */
export enum WithdrawalStatus {
  AwaitingPayment = "awaiting_payment",
  Canceled = "canceled",
  Completed = "completed",
  Denied = "denied",
  Failed = "failed",
  InTransit = "in_transit",
  Requested = "requested",
}

/** A timeline event for a withdrawal. */
export type WithdrawalTimelineEvent = {
  __typename?: "WithdrawalTimelineEvent";
  /** The description of the event, if applicable. */
  description?: Maybe<Scalars["String"]["output"]>;
  /** Whether the event is completed. */
  isCompleted: Scalars["Boolean"]["output"];
  /** The status for the event */
  status: Scalars["String"]["output"];
  /** The timestamp of the event. */
  timestamp?: Maybe<Scalars["Timestamp"]["output"]>;
};

/** The types of withdrawals */
export enum WithdrawalTypes {
  /** Clawback */
  Clawback = "clawback",
  /** Regular */
  Regular = "regular",
}

/** Which columns can be used to sort. */
export enum WithdrawalsSortableColumns {
  Amount = "amount",
  CreatedAt = "created_at",
  Id = "id",
}

export type SendMessageMutationVariables = Exact<{
  input: SendMessageInput;
}>;

export type SendMessageMutation = {
  __typename?: "PublicMutation";
  sendMessage?: string | null;
};

export type CreateCompanyMutedUserMutationVariables = Exact<{
  input: CreateCompanyMutedUserInput;
}>;

export type CreateCompanyMutedUserMutation = {
  __typename?: "PublicMutation";
  createCompanyMutedUser?: boolean | null;
};

export const SendMessageDocument = gql`
  mutation SendMessage($input: SendMessageInput!) {
    sendMessage(input: $input)
  }
`;
export type SendMessageMutationFn = Apollo.MutationFunction<
  SendMessageMutation,
  SendMessageMutationVariables
>;

/**
 * __useSendMessageMutation__
 *
 * To run a mutation, you first call `useSendMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendMessageMutation, { data, loading, error }] = useSendMessageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSendMessageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    SendMessageMutation,
    SendMessageMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<SendMessageMutation, SendMessageMutationVariables>(
    SendMessageDocument,
    options
  );
}
export type SendMessageMutationHookResult = ReturnType<
  typeof useSendMessageMutation
>;
export type SendMessageMutationResult =
  Apollo.MutationResult<SendMessageMutation>;
export type SendMessageMutationOptions = Apollo.BaseMutationOptions<
  SendMessageMutation,
  SendMessageMutationVariables
>;
export const CreateCompanyMutedUserDocument = gql`
  mutation CreateCompanyMutedUser($input: CreateCompanyMutedUserInput!) {
    createCompanyMutedUser(input: $input)
  }
`;
export type CreateCompanyMutedUserMutationFn = Apollo.MutationFunction<
  CreateCompanyMutedUserMutation,
  CreateCompanyMutedUserMutationVariables
>;

/**
 * __useCreateCompanyMutedUserMutation__
 *
 * To run a mutation, you first call `useCreateCompanyMutedUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCompanyMutedUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCompanyMutedUserMutation, { data, loading, error }] = useCreateCompanyMutedUserMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCompanyMutedUserMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CreateCompanyMutedUserMutation,
    CreateCompanyMutedUserMutationVariables
  >
) {
  const options = { ...defaultOptions, ...baseOptions };
  return Apollo.useMutation<
    CreateCompanyMutedUserMutation,
    CreateCompanyMutedUserMutationVariables
  >(CreateCompanyMutedUserDocument, options);
}
export type CreateCompanyMutedUserMutationHookResult = ReturnType<
  typeof useCreateCompanyMutedUserMutation
>;
export type CreateCompanyMutedUserMutationResult =
  Apollo.MutationResult<CreateCompanyMutedUserMutation>;
export type CreateCompanyMutedUserMutationOptions = Apollo.BaseMutationOptions<
  CreateCompanyMutedUserMutation,
  CreateCompanyMutedUserMutationVariables
>;
